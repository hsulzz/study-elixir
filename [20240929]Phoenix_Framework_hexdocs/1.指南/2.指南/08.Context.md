
# Context

> 需求：本指南期望您已经通过了介绍性指南，并成功启动了Phoenix应用程序。

> 需求：本指南期望您已经通过了请求生命周期指南。

> 需求：本指南期望您已经通过了Ecto指南。

到目前为止，我们已经构建了页面，通过路由器连接控制器操作，并了解了Ecto如何允许数据进行验证和持久化。现在是时候将所有内容结合在一起，编写与我们更大的Elixir应用程序交互的Web功能。

在构建一个Phoenix项目时，我们首先要构建的是一个Elixir应用程序。Phoenix的职责是为我们的Elixir应用程序提供Web接口。自然地，我们用模块和函数来组合我们的应用程序，但我们经常将特定的责任分配给某些模块，并为它们命名，例如控制器、路由器和现场视图。

在Phoenix中，上下文是模块，但具有明确的责任来划定边界和分组功能。换句话说，它们使我们能够推理和讨论应用程序设计。

## 考虑上下文

上下文是专用模块，用于暴露和分组相关功能。例如，每当您调用Elixir的标准库，无论是Logger.info/1还是Stream.map/2，您都在访问不同的上下文。在内部，Elixir的日志记录器由多个模块组成，但我们从不直接与这些模块交互。我们称Logger模块为上下文，正是因为它暴露并分组了所有的日志记录功能。

通过给暴露和分组相关功能的模块命名为上下文，我们帮助开发人员识别这些模式并讨论它们。归根结底，上下文仅仅是模块，就像你的控制器、视图等。

在Phoenix中，上下文通常封装数据访问和数据验证。它们通常与数据库或API进行通信。总体而言，将它们视为边界，以解耦和隔离应用程序的各个部分。让我们利用这些想法来构建我们的Web应用程序。我们的目标是构建一个电子商务系统，展示产品，允许用户将产品添加到购物车并完成订单。

如何阅读本指南：使用上下文生成器是初学者和中级Elixir程序员获得快速上手的好方法，同时又能深思熟虑地编写应用程序。本指南重点关注这些读者。

## 添加一个目录上下文

电子商务平台在代码库中具有广泛的耦合，因此考虑编写定义良好的模块非常重要。考虑到这一点，我们的目标是构建一个处理在系统中创建、更新和删除产品的产品目录API。我们将首先实现展示产品的基本功能，稍后添加购物车功能。我们将看到，从一个坚实的基础开始，具有隔离的边界，使我们能够随着功能的添加自然而然地扩展我们的应用程序。

Phoenix包括mix phx.gen.html、mix phx.gen.json、mix phx.gen.live和mix phx.gen.context生成器，这些生成器将应用程序中功能隔离的想法应用于上下文。这些生成器是让您快速上手的极好方法，而Phoenix会引导您朝着正确的方向发展应用程序。让我们为新的产品目录上下文使用这些工具。

为了运行上下文生成器，我们需要想出一个模块名称，以分组我们正在构建的相关功能。在Ecto指南中，我们看到如何使用Changesets和Repos来验证和持久化用户模式，但我们并没有将其与我们的大应用程序集成。实际上，我们也没有考虑“用户”在我们的应用程序中应该在哪个位置。让我们先退一步，思考我们系统的不同部分。我们知道，我们将在销售页面上展示产品，附上描述、定价等。除了销售产品外，我们知道我们还需要支持购物、订单结账等。虽然购买的产品与购物和结账过程相关，但展示产品和管理我们的产品展示与跟踪用户放入购物车的内容或订单是截然不同的。目录上下文是管理我们产品细节和展示这些可销售产品的自然场所。

## 命名事物是困难的

如果您在尝试想出上下文名称时卡住了，而系统中的分组功能尚不清晰，您可以简单地使用您正在创建的资源的复数形式。例如，管理产品的Products上下文。随着应用程序的增长，系统的各个部分变得清晰，您可以简单地将上下文重命名为更精炼的名称。
为了启动我们的目录上下文，我们将使用mix phx.gen.html，它创建一个上下文模块，该模块封装了Ecto访问，用于创建、更新和删除产品，以及Web文件，例如控制器和模板，用于我们上下文的Web接口。在您的项目根目录下运行以下命令：

mix phx.gen.html Catalog Product products title:string \
description:string price:decimal views:integer

* creating lib/hello_web/controllers/product_controller.ex
* creating lib/hello_web/controllers/product_html/edit.html.heex
* creating lib/hello_web/controllers/product_html/index.html.heex
* creating lib/hello_web/controllers/product_html/new.html.heex
* creating lib/hello_web/controllers/product_html/show.html.heex
* creating lib/hello_web/controllers/product_html/product_form.html.heex
* creating lib/hello_web/controllers/product_html.ex
* creating test/hello_web/controllers/product_controller_test.exs
* creating lib/hello/catalog/product.ex
* creating priv/repo/migrations/20210201185747_create_products.exs
* creating lib/hello/catalog.ex
* injecting lib/hello/catalog.ex
* creating test/hello/catalog_test.exs
* injecting test/hello/catalog_test.exs
* creating test/support/fixtures/catalog_fixtures.ex
* injecting test/support/fixtures/catalog_fixtures.ex

将资源添加到您的浏览器范围内，在lib/hello_web/router.ex中：

    resources "/products", ProductController


记得通过运行迁移来更新您的存储库：

    $ mix ecto.migrate

注意到Phoenix按预期在lib/hello_web/中生成了Web文件。我们还可以看到我们的上下文文件是在lib/hello/catalog.ex文件中生成的，以及我们的产品模式在同名目录中。注意lib/hello和lib/hello_web之间的区别。我们有一个Catalog模块作为产品目录功能的公共API，以及一个Catalog.Product结构，这是一个Ecto架构，用于转换和验证产品数据。Phoenix还为我们提供了Web和上下文测试，还为我们提供了通过Hello.Catalog上下文创建实体的测试助手，我们稍后会查看。现在，让我们遵循说明并根据控制台指令在lib/hello_web/router.ex中添加路由：

  scope "/", HelloWeb do
    pipe_through :browser

    get "/", PageController, :index
+   resources "/products", ProductController
  end

现在在新路由就位的情况下，Phoenix提醒我们更新我们的存储库，通过运行mix ecto.migrate，但首先我们需要对priv/repo/migrations/*_create_products.exs中生成的迁移进行一些调整：

  def change do
    create table(:products) do
      add :title, :string
      add :description, :string
-     add :price, :decimal
+     add :price, :decimal, precision: 15, scale: 6, null: false
-     add :views, :integer
+     add :views, :integer, default: 0, null: false

      timestamps()
    end
  end

我们将价格列修改为特定的精度为15，比例为6，以及一个非空约束。确保我们以适当的精度存储货币，以便执行任何可能的数学操作。接下来，我们为我们的查看计数添加了默认值和非空约束。我们有了这些更改，就可以准备将我们的数据库迁移到上面。现在就让我们这样做：

mix ecto.migrate

14:09:02.260 [info] == 运行 20210201185747 Hello.Repo.Migrations.CreateProducts.change/0 向前

14:09:02.262 [info] 创建表产品

14:09:02.273 [info] == 以0.0秒迁移20210201185747

在我们检查生成的代码之前，让我们用mix phx.server启动服务器，并访问http://localhost:4000/products。跟随“新产品”链接并点击“保存”按钮而不提供任何输入。我们应该看到以下输出：

哎呀，发生了一些错误！请检查下面的错误。
当我们提交表单时，我们可以看到所有验证错误在输入框内。不错！在开箱即用的情况下，上下文生成器在我们的表单模板中包含了架构字段，我们可以看到我们的默认验证对于必填输入生效。让我们输入一些示例产品数据并重新提交表单：

产品创建成功。

标题：Metaprogramming Elixir
说明：少写代码, 多做事(开心一下!)
价格：15.000000
查看：0

如果我们跟随“返回”链接，我们将看到所有产品的列表，其中应该包含我们刚刚创建的那个。同样，我们可以更新此记录或将其删除。现在我们已经在浏览器中看到了效果，是时候查看生成的代码了。

## 从生成器开始

那个小小的mix phx.gen.html命令产生了惊人的效果。我们开箱即用地获得了很多功能，用于创建、更新和删除我们目录中的产品。这离完整应用程序还有很远，但请记住，生成器首先是学习工具，并为您构建真实功能的起点。代码生成不能解决所有问题，但它将教您使用Phoenix的方方面面，并在设计应用程序时引导您走向正确的思维方式。

首先让我们检查在lib/hello_web/controllers/product_controller.ex中生成的ProductController：

```elixir
defmodule HelloWeb.ProductController do
  use HelloWeb, :controller

  alias Hello.Catalog
  alias Hello.Catalog.Product

  def index(conn, _params) do
    products = Catalog.list_products()
    render(conn, :index, products: products)
  end

  def new(conn, _params) do
    changeset = Catalog.change_product(%Product{})
    render(conn, :new, changeset: changeset)
  end

  def create(conn, %{"product" => product_params}) do
    case Catalog.create_product(product_params) do
      {:ok, product} ->
        conn
        |> put_flash(:info, "Product created successfully.")
        |> redirect(to: ~p"/products/#{product}")

      {:error, %Ecto.Changeset{} = changeset} ->
        render(conn, :new, changeset: changeset)
    end
  end

  def show(conn, %{"id" => id}) do
    product = Catalog.get_product!(id)
    render(conn, :show, product: product)
  end
  ...
end
```

我们在控制器指南中已经看到控制器是如何工作的，因此代码可能并不让人很惊讶。值得注意的是我们的控制器如何调用Catalog上下文。我们可以看到index操作如何通过Catalog.list_products/0获取产品列表，以及产品如何在create操作中持久化，调用Catalog.create_product/1。我们尚未查看目录上下文，因此我们还不知道产品获取和创建在后台是如何发生的——但这正是重点。我们的Phoenix控制器是连接我们的更大应用程序的Web接口。它不应该关心如何从数据库中获取产品或如何将其持久化的细节。我们只关心让我们的应用程序为我们执行某些工作。这是伟大的，因为我们的业务逻辑和存储细节与我们应用程序的Web层解耦。如果我们后来需要将产品的获取更改为使用全文本存储引擎，而不是SQL查询，我们的控制器不需要更改。同样，我们可以从我们应用程序的任何其他接口重用我们的上下文代码，无论是通道、mix任务还是长时间运行的过程导入CSV数据。

在我们的create操作的情况下，当我们成功创建了产品时，我们使用Phoenix.Controller.put_flash/3显示成功消息，然后重定向到路由器的产品显示页面。相反,如果Catalog.create_product/1失败,我们渲染我们的“new.html”模板并传递Ecto changeset，以使模板提升错误消息。

接下来，让我们深入看看我们在lib/hello/catalog.ex中的Catalog上下文：

```elixir
defmodule Hello.Catalog do
  @moduledoc """
  The Catalog context.
  """

  import Ecto.Query, warn: false
  alias Hello.Repo

  alias Hello.Catalog.Product

  @doc """
  Returns the list of products.

  ## Examples

      iex> list_products()
      [%Product{}, ...]

  """
  def list_products do
    Repo.all(Product)
  end
  ...
end
```

这个模块将是我们系统中所有产品目录功能的公共API。例如，除了产品详细管理，我们可能还会处理产品类别分类和产品变种，如可选的尺寸、修整等。如果我们查看list_products/0函数，我们可以看到获取产品的私有细节。其实是很简单的。我们调用Repo.all(Product)。我们在Ecto指南中看到过Ecto repo查询是如何工作的，这个调用应该很熟悉。我们的list_products函数是一个通用的函数名称，指定了我们代码的意图——即列出产品。关于这个意图的细节，我们使用Repo从我们的PostgreSQL数据库中获取产品的地方是对调用者隐藏的。这是我们将在使用Phoenix生成器时看到的一个常见主题。Phoenix会推动我们思考在哪里有不同的责任，然后将这些不同的领域封装在具有良好命名模块和函数后面，使我们代码的意图明确，同时封装细节。

这里的文档比代码多，但有几个重要的内容需要强调。首先，我们再次看到我们的 Ecto Repo 在后台用于数据库访问。你可能也注意到了对 Product.changeset/2 的调用。我们之前谈过变化集，现在我们在上下文中看到了它们的实际应用。

如果我们打开 lib/hello/catalog/product.ex 中的 Product 模式，它看起来立即很熟悉：

```elixir
defmodule Hello.Catalog.Product do
  use Ecto.Schema
  import Ecto.Changeset

  schema "products" do
    field :description, :string
    field :price, :decimal
    field :title, :string
    field :views, :integer

    timestamps()
  end

  @doc false
  def changeset(product, attrs) do
    product
    |> cast(attrs, [:title, :description, :price, :views])
    |> validate_required([:title, :description, :price, :views])
  end
end
```

这正是我们在运行 mix phx.gen.schema 时看到的，除了这里在我们的 changeset/2 函数上方增加了 @doc false。这告诉我们，虽然这个函数可以公开调用，但它不是公共上下文 API 的一部分。构建变化集的调用者通过上下文 API 进行。例如，Catalog.create_product/1 调用我们的 Product.changeset/2 以从用户输入构建变化集。调用者（例如我们的控制器操作）不会直接访问 Product.changeset/2。与我们的产品变化集的所有交互都是通过公共的 Catalog 上下文进行的。

### 添加 Catalog 函数
如我们所见，您的上下文模块是专门用于公开和组合相关功能的模块。Phoenix 生成的通用函数，如 list_products 和 update_product，仅作为您扩展业务逻辑和应用程序的基础。让我们通过跟踪产品页面的查看次数来添加我们的目录的基本功能之一。

对于任何电子商务系统，跟踪产品页面被查看多少次的能力对营销、建议、排名等都是至关重要的。虽然我们可以尝试使用现有的 Catalog.update_product 函数，例如 Catalog.update_product(product, %{views: product.views + 1})，但这不仅容易产生竞争条件，而且还需要调用者对我们的 Catalog 系统了解过多。为了理解为什么存在竞争条件，让我们逐步分析事件的可能执行：

直观上，你会假设以下事件发生：

1. 用户 1 加载产品页面，计数为 13
2. 用户 1 保存产品页面，计数为 14
3. 用户 2 加载产品页面，计数为 14
4. 用户 2 保存产品页面，计数为 15

但实际上会发生这样的情况：

1. 用户 1 加载产品页面，计数为 13
2. 用户 2 加载产品页面，计数为 13
3. 用户 1 保存产品页面，计数为 14
4. 用户 2 保存产品页面，计数为 14

竞争条件使得这种更新现有表的方法不可靠，因为多个调用者可能会更新过时的查看值。有更好的办法。

让我们考虑一个描述我们想要实现功能的函数。我们希望这样使用它：

```elixir
product = Catalog.inc_page_views(product)
```

看起来很不错。我们的调用者不会对这个函数的用途感到困惑，我们可以将增量操作封装在一个原子操作中，以防止竞争条件。

打开你的目录上下文（lib/hello/catalog.ex），并添加这个新函数：

```elixir
def inc_page_views(%Product{} = product) do
  {1, [%Product{views: views}]} =
    from(p in Product, where: p.id == ^product.id, select: [:views])
    |> Repo.update_all(inc: [views: 1])

  put_in(product.views, views)
end
```

我们建立了一个用于获取给定 ID 的当前产品的查询，然后将其传递给 Repo.update_all。Ecto 的 Repo.update_all 使我们能够对数据库执行批量更新，非常适合原子地更新值，例如增加我们的查看计数。仓库操作的结果返回更新的记录数，以及通过选择选项指定的选定模式值。当我们接收到新的产品查看数时，我们使用 put_in(product.views, views) 将新的查看计数放入产品结构中。

在我们上下文函数就位后，让我们在产品控制器中使用它。更新 lib/hello_web/controllers/product_controller.ex 中的 show 操作以调用我们的新函数：

```elixir
def show(conn, %{"id" => id}) do
  product =
    id
    |> Catalog.get_product!()
    |> Catalog.inc_page_views()

  render(conn, :show, product: product)
end
```

我们修改了我们的 show 操作，将获取的产品传递给 Catalog.inc_page_views/1，这将返回更新后的产品。然后我们如之前一样渲染模板。让我们试一试。刷新你的一些产品页面几次，看看查看计数是否增加。

我们还可以在 Ecto 调试日志中看到我们的原子更新：

```
[debug] QUERY OK source="products" db=0.5ms idle=834.5ms
UPDATE "products" AS p0 SET "views" = p0."views" + $1 WHERE (p0."id" = $2) RETURNING p0."views" [1, 1]
```

干得好！

正如我们所见，使用上下文进行设计为您提供了一个良好的基础来扩展您的应用程序。使用明确、良定义的 API 来公开系统的意图，可以让您编写更易于维护的应用程序，并重用代码。现在我们知道如何开始扩展我们的上下文 API，接下来让我们探讨如何在上下文中处理关系。

## 上下文中的关系

我们的基本目录功能很好，但让我们通过对产品进行分类来更进一步。许多电子商务解决方案允许以不同方式对产品进行分类，比如一个产品可以标记为时尚商品、电动工具等。最开始如果我们只建立产品与类别之间的一对一关系，等之后需要支持多类别时会导致代码的大规模变更。因此，我们需要建立一个类别关联，使我们可以以每个产品跟踪一个类别开始，但在未来可以轻松支持更多类别，随着我们的功能扩大而调整。

目前，类别将仅包含文本信息。我们需要首先决定类别在应用程序中的位置。我们有一个目录上下文，它管理我们的产品展示，产品分类在这里非常合适。Phoenix 也足够智能，可以在现有上下文中生成代码，这使得将新资源添加到上下文变得轻而易举。在您的项目根目录下运行以下命令：

有时，确定两个资源是否属于同一上下文可能比较棘手。在这种情况下，优先考虑每个资源都有独立的上下文，如果有必要，再进行重构。否则，您可能会轻易得到一个包含松散相关实体的大上下文。还要记住，两资源之间的关系并不一定意味着它们属于同一上下文，否则您将很快得到一个大型上下文，因为应用程序中的大多数资源是相互连接的。总结一下：如果您不确定，您应该优先选择独立模块（上下文）。

```elixir
mix phx.gen.context Catalog Category categories \
title:string:unique
```

您是在现有上下文中生成...
...
您想继续吗？ [是/否] y
* 创建 lib/hello/catalog/category.ex
* 创建 priv/repo/migrations/20210203192325_create_categories.exs
* 注入 lib/hello/catalog.ex
* 注入 test/hello/catalog_test.exs
* 注入 test/support/fixtures/catalog_fixtures.ex

记得通过运行迁移来更新您的数据库：

```elixir
$ mix ecto.migrate
```

这一次我们使用了 `mix phx.gen.context`，它与 `mix phx.gen.html` 类似，但它不会为我们生成网页文件。由于我们已经有了管理产品的控制器和模板，我们可以将新的类别功能集成到我们现有的网页表单和产品展示页面中。我们可以看到，现在在 `lib/hello/catalog/category.ex` 下我们有了一个新的类别模式，Phoenix 告诉我们它在我们现有的目录上下文中注入了类别功能的新函数。被注入的函数与我们的产品函数看起来非常相似，新增了像 `create_category`、`list_categories` 等函数。在我们执行迁移之前，需要进行第二次代码生成。我们的类别模式能很好地表示系统中的单个类别，但我们需要支持产品与类别之间的多对多关系。幸运的是，Ecto 允许我们简单地通过加入表来实现这一点，因此让我们现在用 `ecto.gen.migration` 命令生成它：

```elixir
mix ecto.gen.migration create_product_categories
```

* 创建 priv/repo/migrations/20210203192958_create_product_categories.exs

接下来，打开新的迁移文件并在 `change` 函数中添加以下代码：

```elixir
defmodule Hello.Repo.Migrations.CreateProductCategories do
  use Ecto.Migration

  def change do
    create table(:product_categories, primary_key: false) do
      add :product_id, references(:products, on_delete: :delete_all)
      add :category_id, references(:categories, on_delete: :delete_all)
    end

    create index(:product_categories, [:product_id])
    create unique_index(:product_categories, [:category_id, :product_id])
  end
end
```

我们创建了一个 `product_categories` 表，并使用 `primary_key: false` 选项，因为我们的连接表不需要主键。接下来，我们定义了 `:product_id` 和 `:category_id` 外键字段，并传递 `on_delete: :delete_all` 来确保数据库在删除相关的产品或类别时会自动清理我们的连接表记录。通过使用数据库约束，我们在数据库层面上强制数据完整性，而不是依赖于临时和容易出错的应用程序逻辑。

接下来，我们为我们的外键创建索引，其中一个是唯一索引，以确保一个产品不能拥有重复的类别。请注意，我们不一定需要 `category_id` 的单列索引，因为它已经在多列索引的最左前缀中，这对于数据库优化器来说已经足够。另一方面，添加冗余索引只会在写入时增加开销。

随着我们的迁移到位，我们可以继续进行迁移。

```elixir
mix ecto.migrate
```

```plaintext
18:20:36.489 [info] == 运行 20210222231834 Hello.Repo.Migrations.CreateCategories.change/0 向前
18:20:36.493 [info] 创建表 categories
18:20:36.508 [info] 创建索引 categories_title_index
18:20:36.512 [info] == 迁移 20210222231834 进行中
18:20:36.547 [info] == 运行 20210222231930 Hello.Repo.Migrations.CreateProductCategories.change/0 向前
18:20:36.547 [info] 创建表 product_categories
18:20:36.557 [info] 创建索引 product_categories_product_id_index
18:20:36.560 [info] 创建索引 product_categories_category_id_product_id_index
18:20:36.562 [info] == 迁移 20210222231930 进行中
```

现在我们有了 `Catalog.Product` 模式和一个连接表来关联产品与类别，我们几乎准备好开始实现我们的新功能了。在此之前，我们首先需要在我们的网页 UI 中选择真实的类别。让我们快速在应用程序中录入一些新类别。在 `priv/repo/seeds.exs` 的种子文件中添加以下代码：

```elixir
for title <- ["家居改善", "电动工具", "园艺", "书籍", "教育"] do
  {:ok, _} = Hello.Catalog.create_category(%{title: title})
end
```

我们只是遍历类别标题的列表，并利用我们目录上下文生成的 `create_category/1` 函数来持久化新记录。我们可以使用以下命令运行种子：

```elixir
mix run priv/repo/seeds.exs
```

完美。在我们将类别整合到网页层之前，我们需要让我们的上下文知道如何关联产品和类别。首先，打开 `lib/hello/catalog/product.ex` 并添加以下关联：

```elixir
+ alias Hello.Catalog.Category

schema "products" do
  field :description, :string
  field :price, :decimal
  field :title, :string
  field :views, :integer

+ many_to_many :categories, Category, join_through: "product_categories", on_replace: :delete

  timestamps()
end
```

我们使用了 `Ecto.Schema` 的 `many_to_many` 宏来让 Ecto 知道如何通过 "product_categories" 连接表将我们的产品与多个类别关联起来。我们还使用了 `on_replace: :delete` 选项，以声明在更改类别时，任何现有的连接记录应该被删除。

现在，设置好我们的模式关联后，我们可以在产品表单中实现类别选择。为此，我们需要将前端的目录 ID 用户输入转换为我们的多对多关联。幸运的是，Ecto 使这一切变得简单，因为我们的模式已经设置好。打开您的目录上下文并进行以下更改：

```elixir
+ alias Hello.Catalog.Category

- def get_product!(id), do: Repo.get!(Product, id)
+ def get_product!(id) do
+   Product |> Repo.get!(id) |> Repo.preload(:categories)
+ end

def create_product(attrs \\ %{}) do
  %Product{}
-   |> Product.changeset(attrs)
+   |> change_product(attrs)
  |> Repo.insert()
end

def update_product(%Product{} = product, attrs) do
  product
-   |> Product.changeset(attrs)
+   |> change_product(attrs)
  |> Repo.update()
end

def change_product(%Product{} = product, attrs \\ %{}) do
-   Product.changeset(product, attrs)
+   categories = list_categories_by_id(attrs["category_ids"])

+   product
+   |> Repo.preload(:categories)
+   |> Product.changeset(attrs)
+   |> Ecto.Changeset.put_assoc(:categories, categories)
end

+ def list_categories_by_id(nil), do: []
+ def list_categories_by_id(category_ids) do
+   Repo.all(from c in Category, where: c.id in ^category_ids)
+ end
```

首先，我们添加了 `Repo.preload`，以在获取产品时预加载类别。这将使我们能够在控制器、模板以及我们想要使用类别信息的任何地方引用 `product.categories`。接下来，我们修改了 `create_product` 和 `update_product` 函数，以调用现有的 `change_product` 函数来生成更改集。在 `change_product` 内，我们检查 "category_ids" 属性是否存在，如果存在就查找所有类别。然后，我们预加载类别并调用 `Ecto.Changeset.put_assoc` 将获取的类别放入更改集。最后，我们实现了 `list_categories_by_id/1` 函数，以查询与类别 ID 匹配的类别，或者在没有 "category_ids" 属性时返回一个空列表。现在，当我们的 `create_product` 和 `update_product` 函数尝试对我们的 repo 进行插入或更新时，会接收到一个带有类别关联的更改集。

接下来，让我们通过在产品表单中添加类别输入来将新功能公开到网页上。为了保持我们的表单模板整洁，让我们写一个新函数来封装为我们的产品呈现类别选择输入的细节。打开 `lib/hello_web/controllers/product_html.ex`，并键入以下内容：

```elixir
def category_opts(changeset) do
  existing_ids =
    changeset
    |> Ecto.Changeset.get_change(:categories, [])
    |> Enum.map(& &1.data.id)

  for cat <- Hello.Catalog.list_categories(),
      do: [key: cat.title, value: cat.id, selected: cat.id in existing_ids]
end
```

我们添加了一个新的 `category_opts/1` 函数，它生成我们稍后将添加的多选择标签的选择选项。我们从更改集计算现有的类别 ID，然后在生成输入标签的选择选项时使用这些值。通过遍历所有类别并返回适当的键、值和选中的值来实现。如果类别 ID 在我们的更改集中找到，则将该选项标记为选中。

有了 `category_opts` 函数，我们可以打开 `lib/hello_web/controllers/product_html/product_form.html.heex` 并添加：

```elixir
...
<input field={f[:views]} type="number" label="Views" />

+ <.input field={f[:category_ids]} type="select" multiple={true} options={category_opts(@changeset)} />

<:actions>
  <.button>Save Product</.button>
</:actions>
```

我们在保存按钮上方添加了一个类别选择。现在让我们试试。接下来，让我们在产品展示模板中显示产品的类别。在 `lib/hello_web/controllers/product_html/show.html.heex` 的列表中添加以下代码：

```elixir
<.list>
  ...
+ <:item title="类别">
+   <%= for cat <- @product.categories do %>
+     <%= cat.title %>
+     <br/>
+   <% end %>
+ </:item>
</.list>
```

现在，如果我们启动服务器并访问 http://localhost:4000/products/new，我们将看到新的类别多选输入。输入一些有效的产品细节，选择一两个类别，然后点击保存。

标题：Elixir 闪卡  
描述：Elixir 编程语言的闪卡集合  
价格：5.000000  
查看次数：0  
类别：  
教育  
书籍  

这看上去还不算太好，但它有效！我们在上下文中添加了关系，并通过数据库强制执行数据完整性。不错的开始。让我们继续构建！