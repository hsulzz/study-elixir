# 路由

> 前提：本指南假定您已经阅读过入门指南，并且成功运行了 Phoenix 应用程序。

> 前提：本指南假定您已经阅读过请求生命周期指南。

路由器是 Phoenix 应用程序的主要中心。它们将 HTTP 请求匹配到控制器操作，连接实时通道处理程序，并定义一系列针对特定路由的管道转换。

Phoenix 生成的路由文件 lib/hello_web/router.ex 看起来类似于以下内容：

```elixir
defmodule HelloWeb.Router do
  use HelloWeb, :router

  pipeline :browser do
    plug :accepts, ["html"]
    plug :fetch_session
    plug :fetch_live_flash
    plug :put_root_layout, html: {HelloWeb.Layouts, :root}
    plug :protect_from_forgery
    plug :put_secure_browser_headers
  end

  pipeline :api do
    plug :accepts, ["json"]
  end

  scope "/", HelloWeb do
    pipe_through :browser

    get "/", PageController, :home
  end

  # 其他路由可能使用自定义栈。
  # scope "/api", HelloWeb do
  #   pipe_through :api
  # end
  # ...
end
```

路由器和控制器模块的名称前缀将是您为应用程序指定的名称，后缀为 Web。

该模块的第一行 `use HelloWeb, :router`，简单地使得 Phoenix 路由器函数在我们特定的路由器中可用。

在本指南中，`scope`有其自己的章节，所以我们不会在此花时间讨论 `scope "/", HelloWeb do` 块。`pipe_through :browser` 行将在本指南的“管道”部分得到充分讨论。目前，您只需知道管道允许一组插头应用于不同的路由集合。

然而，在这段`scope`块内，我们有我们第一个实际的路由：

```elixir
get "/", PageController, :home
```

`get` 是一个对应于 HTTP 动词 GET 的 Phoenix 宏。其他 HTTP 动词有类似的宏，包括 POST、PUT、PATCH、DELETE、OPTIONS、CONNECT、TRACE 和 HEAD。

---

**为什么使用宏？**

Phoenix 尽量减少宏的使用。但是，您可能已经注意到，Phoenix.Router 在很大程度上依赖于宏。这是什么原因呢？

我们使用 `get`、`post`、`put` 和 `delete` 来定义路由。我们使用宏有两个目的：

1. 它们定义了路由引擎，用于每个请求，以选择要将请求分配给哪个控制器。借助宏，Phoenix 将您的所有路由编译为一个巨大的案例语句，具有模式匹配规则，这得到了 Erlang VM 的高度优化。
2. 对于每个定义的路由，我们还定义元数据来实现 `Phoenix.VerifiedRoutes`。正如我们将很快了解的那样，经过验证的路由允许我们将任何路由引用为普通字符串，编译器会验证它是否有效（使得将无效链接、表单、邮件等发送到生产环境变得更加困难）。

换句话说，路由器依赖宏构建更快、更安全的应用程序。同时请记住，Elixir 中的宏仅在编译时生效，这在代码编译后提供了相当的稳定性。如我们将要了解的，Phoenix 还通过 `mix phx.routes` 提供对所有定义路由的自省。

---

## 审查路由

Phoenix 提供了一个优秀的工具来调查应用程序中的路由：`mix phx.routes`。

让我们看看这如何工作。转到一个新生成的 Phoenix 应用程序的根目录并运行 `mix phx.routes`。您应该会看到类似以下内容，生成了您当前拥有的所有路由：

```
mix phx.routes
GET  /  HelloWeb.PageController :home
...
```

上述路由告诉我们，任何对应用程序根目录的 HTTP GET 请求都将由 `HelloWeb.PageController` 的 `home` 动作处理。

## 资源

路由器支持除了像 `get`、`post` 和 `put` 等 HTTP 动词之外的其他宏。其中最重要的是 `resources`。让我们在 `lib/hello_web/router.ex` 文件中添加一个资源，如下所示：

```elixir
scope "/", HelloWeb do
  pipe_through :browser

  get "/", PageController, :home
  resources "/users", UserController
  ...
end
```

目前我们没有实际的 `HelloWeb.UserController` 并不重要。

再次在项目的根目录运行 `mix phx.routes`。您应该会看到如下内容：

```
...
GET     /users           HelloWeb.UserController :index
GET     /users/:id/edit  HelloWeb.UserController :edit
GET     /users/new       HelloWeb.UserController :new
GET     /users/:id       HelloWeb.UserController :show
POST    /users           HelloWeb.UserController :create
PATCH   /users/:id       HelloWeb.UserController :update
PUT     /users/:id       HelloWeb.UserController :update
DELETE  /users/:id       HelloWeb.UserController :delete
...
```

这是 HTTP 动词、路径和控制器动作的标准矩阵。曾几何时，这被称为 RESTful 路由，但现在大多数人认为这并不准确。我们来逐一看看它们。

- 对 `/users` 的 GET 请求将调用 `index` 动作以显示所有用户。
- 对 `/users/:id/edit` 的 GET 请求将调用 `edit` 动作，通过 ID 从数据存储中检索单个用户，并在表单中呈现信息以进行编辑。
- 对 `/users/new` 的 GET 请求将调用 `new` 动作以呈现创建新用户的表单。
- 对 `/users/:id` 的 GET 请求将调用 `show` 动作，通过 ID 显示由该 ID 标识的单个用户。
- 对 `/users` 的 POST 请求将调用 `create` 动作以将新用户保存到数据存储中。
- 对 `/users/:id` 的 PATCH 请求将调用 `update` 动作以通过 ID 保存更新后的用户到数据存储中。
- 对 `/users/:id` 的 PUT 请求也将调用 `update` 动作以通过 ID 保存更新后的用户到数据存储中。
- 对 `/users/:id` 的 DELETE 请求将调用 `delete` 动作以从数据存储中移除单个用户。

如果我们不需要所有这些路由，我们可以使用 `:only` 和 `:except` 选项有选择地过滤特定动作。

假设我们有一个只读的帖子资源。我们可以这样定义：

```elixir
resources "/posts", PostController, only: [:index, :show]
```

运行 `mix phx.routes` 显示我们现在只有指向 `index` 和 `show` 动作的路由。

```
GET     /posts      HelloWeb.PostController :index
GET     /posts/:id  HelloWeb.PostController :show
```

同样，如果我们有一个评论资源，并且我们不想提供删除一个的路由，我们可以这样定义一个路由。

```elixir
resources "/comments", CommentController, except: [:delete]
```

运行 `mix phx.routes` 现在显示我们有所有路由，除了指向删除动作的 DELETE 请求。

```
GET    /comments           HelloWeb.CommentController :index
GET    /comments/:id/edit  HelloWeb.CommentController :edit
GET    /comments/new       HelloWeb.CommentController :new
GET    /comments/:id       HelloWeb.CommentController :show
POST   /comments           HelloWeb.CommentController :create
PATCH  /comments/:id       HelloWeb.CommentController :update
PUT    /comments/:id       HelloWeb.CommentController :update
```

`Phoenix.Router.resources/4` 宏描述了自定义资源路由的其他选项。

## 经过验证的路由

Phoenix 包括 `Phoenix.VerifiedRoutes` 模块，通过使用 `~p` 符号提供编译时路由路径检查，以确保这些路径与路由器中的路由匹配。例如，您可以在控制器、测试和模板中编写路径，编译器将确保这些路径确实与您在路由中定义的路由匹配。

让我们看看它如何在行动中运行。在项目的根目录运行 `iex -S mix`。我们将定义一个临时的示例模块，构建一对 `~p` 路由路径。

```elixir
defmodule RouteExample do
  use HelloWeb, :verified_routes

  def example do
    ~p"/comments"
    ~p"/unknown/123"
  end
end
```

注意，第一次调用现有路由 `~p"/comments"` 没有警告，但错误的路由路径 `~p"/unknown/123"` 产生了编译器警告，正如它应该的。这是重要的，因为它允许我们在应用程序中编写硬编码路径，编译器会在我们编写无效路由或更改路由结构时提醒我们。

Phoenix 项目开箱即用地允许在整个 Web 层（包括测试中）使用经过验证的路由。例如，在您的模板中，您可以呈现 `~p` 链接：

```elixir
<.link href={~p"/"}>欢迎页面!</.link>
<.link href={~p"/comments"}>查看评论</.link>
```

或者在控制器中发出重定向：

```elixir
redirect(conn, to: ~p"/comments/#{comment}")
```

使用 `~p` 进行路由路径确保我们的应用程序路径和 URL 与路由定义保持最新。编译器将为我们捕获错误，并在我们更改在应用程序其他地方引用的路由时提醒我们。

## 经过验证的路由更多信息

如果路径中带有查询字符串怎么办？您可以直接添加查询字符串键值，或提供一个键值对字典，例如：

```elixir
~p"/users/17?admin=true&active=false"
"/users/17?admin=true&active=false"

~p"/users/17?#{[admin: true]}"
"/users/17?admin=true"
```

如果我们需要完整的 URL 而不是路径怎么办？只需将路径包装在 `Phoenix.VerifiedRoutes.url/1` 的调用中，该调用在任何 `~p` 可用的地方都可以导入：

```elixir
url(~p"/users")
"http://localhost:4000/users"
```

这个 url 调用将获取构造完整 URL 所需的主机、端口、代理端口和 SSL 信息，这些信息是根据为每个环境设置的配置参数构建的。我们稍后将在单独的指南中详细讨论配置。现在，您可以查看您项目中的 `config/dev.exs` 文件以查看这些值。

## 嵌套资源

在 Phoenix 路由器中嵌套资源也是可能的。假设我们还有一个帖子资源，它与用户有多对一的关系。也就是说，一个用户可以创建多篇帖子，而一篇帖子只属于一个用户。我们可以通过在 `lib/hello_web/router.ex` 中添加一个嵌套路由来表示这一点，如下所示：

```elixir
resources "/users", UserController do
  resources "/posts", PostController
end
```

当我们现在运行 `mix phx.routes` 时，除了我们之前看到的用户路由外，还得到了以下一系列路由：

```
...
GET     /users/:user_id/posts           HelloWeb.PostController :index
GET     /users/:user_id/posts/:id/edit  HelloWeb.PostController :edit
GET     /users/:user_id/posts/new       HelloWeb.PostController :new
GET     /users/:user_id/posts/:id       HelloWeb.PostController :show
POST    /users/:user_id/posts           HelloWeb.PostController :create
PATCH   /users/:user_id/posts/:id       HelloWeb.PostController :update
PUT     /users/:user_id/posts/:id       HelloWeb.PostController :update
DELETE  /users/:user_id/posts/:id       HelloWeb.PostController :delete
...
```

我们看到这些路由的每一个都将帖子范围限制为用户 ID。对于第一个，调用 PostController 的 index 动作，但我们将传入一个 user_id。这暗示着我们只会显示该用户的所有帖子。这种范围适用于所有这些路由。

在为嵌套路由构建路径时，我们需要在路由定义中插入 IDs。在以下的 show 路由中，42 是 user_id，17 是 post_id。

```elixir
user_id = 42
post_id = 17
~p"/users/#{user_id}/posts/#{post_id}"
"/users/42/posts/17"
```

经过验证的路由也支持 `Phoenix.Param` 协议，但我们不需要担心 Elixir 协议。只需知道，一旦我们开始使用像 `%User{}` 和 `%Post{}` 这样的结构构建我们的应用程序，我们将能够直接将这些数据结构插入到我们的 `~p` 路径中，Phoenix 将提取出用于路由的正确字段。

```elixir
~p"/users/#{user}/posts/#{post}"
"/users/42/posts/17"
```

注意，我们不需要插入 `user.id` 或 `post.id`？如果我们后来决定希望让我们的 URL 更好看，开始使用别名（slug），这尤其好。我们不需要更改任何 `~p`！

## 作用域路由

作用域是一种将路由组合在一起并具有共同路径前缀和范围集插头的方式。我们可能希望为管理功能、API 尤其是版本化的 API 这样做。假设我们在一个网站上有用户生成的评论，并且这些评论首先需要由管理员批准。这些资源的语义是非常不同的，它们可能不会共享相同的控制器。作用域使我们能够隔离这些路由。

面向用户的评论路径将看起来像标准资源。

```
/reviews
/reviews/1234
/reviews/1234/edit
...
```

管理评论路径可以以 `/admin` 为前缀。

```
/admin/reviews
/admin/reviews/1234
/admin/reviews/1234/edit
...
```

我们通过设置作用域选项为 `/admin` 来实现这一点。我们可以将此作用域嵌套在另一个作用域中，但这次，让我们独立设置它，将以下内容添加到 `lib/hello_web/router.ex` 中：

```elixir
scope "/admin", HelloWeb.Admin do
  pipe_through :browser

  resources "/reviews", ReviewController
end
```

我们定义了一个新作用域，其中所有路由都以 `/admin` 为前缀，所有控制器都位于 `HelloWeb.Admin` 命名空间下。

再次运行 `mix phx.routes`，除了之前的路由集，我们得到以下内容：

```
...
GET     /admin/reviews           HelloWeb.Admin.ReviewController :index
GET     /admin/reviews/:id/edit  HelloWeb.Admin.ReviewController :edit
GET     /admin/reviews/new       HelloWeb.Admin.ReviewController :new
GET     /admin/reviews/:id       HelloWeb.Admin.ReviewController :show
POST    /admin/reviews           HelloWeb.Admin.ReviewController :create
PATCH   /admin/reviews/:id       HelloWeb.Admin.ReviewController :update
PUT     /admin/reviews/:id       HelloWeb.Admin.ReviewController :update
DELETE  /admin/reviews/:id       HelloWeb.Admin.ReviewController :delete
...
```

这看起来不错，但这里有一个问题。记住我们想要面向用户的评论路径 `/reviews` 和管理路径 `/admin/reviews`。如果我们现在在路由器中将面向用户的评论包含在根作用域中，如下所示：

```elixir
scope "/", HelloWeb do
  pipe_through :browser

  ...
  resources "/reviews", ReviewController
end

scope "/admin", HelloWeb.Admin do
  pipe_through :browser

  resources "/reviews", ReviewController
end
```

当我们运行 `mix phx.routes` 时，我们为每个作用域路由得到了输出：

```
...
GET     /reviews                 HelloWeb.ReviewController :index
GET     /reviews/:id/edit        HelloWeb.ReviewController :edit
GET     /reviews/new             HelloWeb.ReviewController :new
GET     /reviews/:id             HelloWeb.ReviewController :show
POST    /reviews                 HelloWeb.ReviewController :create
PATCH   /reviews/:id             HelloWeb.ReviewController :update
PUT     /reviews/:id             HelloWeb.ReviewController :update
DELETE  /reviews/:id             HelloWeb.ReviewController :delete
...
GET     /admin/reviews           HelloWeb.Admin.ReviewController :index
GET     /admin/reviews/:id/edit  HelloWeb.Admin.ReviewController :edit
GET     /admin/reviews/new       HelloWeb.Admin.ReviewController :new
GET     /admin/reviews/:id       HelloWeb.Admin.ReviewController :show
POST    /admin/reviews           HelloWeb.Admin.ReviewController :create
PATCH   /admin/reviews/:id       HelloWeb.Admin.ReviewController :update
PUT     /admin/reviews/:id       HelloWeb.Admin.ReviewController :update
DELETE  /admin/reviews/:id       HelloWeb.Admin.ReviewController :delete
```

如果我们有许多资源都由管理员处理怎么办？我们可以将它们全部放在同一个作用域内，如下所示：

```elixir
scope "/admin", HelloWeb.Admin do
  pipe_through :browser

  resources "/images",  ImageController
  resources "/reviews", ReviewController
  resources "/users",   UserController
end
```

这是 `mix phx.routes` 告诉我们的内容：

```
...
GET     /admin/images            HelloWeb.Admin.ImageController :index
GET     /admin/images/:id/edit   HelloWeb.Admin.ImageController :edit
GET     /admin/images/new        HelloWeb.Admin.ImageController :new
GET     /admin/images/:id        HelloWeb.Admin.ImageController :show
POST    /admin/images            HelloWeb.Admin.ImageController :create
PATCH   /admin/images/:id        HelloWeb.Admin.ImageController :update
PUT     /admin/images/:id        HelloWeb.Admin.ImageController :update
DELETE  /admin/images/:id        HelloWeb.Admin.ImageController :delete
GET     /admin/reviews           HelloWeb.Admin.ReviewController :index
GET     /admin/reviews/:id/edit  HelloWeb.Admin.ReviewController :edit
GET     /admin/reviews/new       HelloWeb.Admin.ReviewController :new
GET     /admin/reviews/:id       HelloWeb.Admin.ReviewController :show
POST    /admin/reviews           HelloWeb.Admin.ReviewController :create
PATCH   /admin/reviews/:id       HelloWeb.Admin.ReviewController :update
PUT     /admin/reviews/:id       HelloWeb.Admin.ReviewController :update
DELETE  /admin/reviews/:id       HelloWeb.Admin.ReviewController :delete
GET     /admin/users             HelloWeb.Admin.UserController :index
GET     /admin/users/:id/edit    HelloWeb.Admin.UserController :edit
GET     /admin/users/new         HelloWeb.Admin.UserController :new
GET     /admin/users/:id         HelloWeb.Admin.UserController :show
POST    /admin/users             HelloWeb.Admin.UserController :create
PATCH   /admin/users/:id         HelloWeb.Admin.UserController :update
PUT     /admin/users/:id         HelloWeb.Admin.UserController :update
DELETE  /admin/users/:id         HelloWeb.Admin.UserController :delete
```

这很好，非常符合我们的要求。注意每条路由和控制器的命名空间都正确。

作用域也可以任意嵌套，但您应该小心使用，因为嵌套有时会使我们的代码变得混乱和不清晰。话虽如此，假设我们有一个带有资源定义的版本化 API，该资源包括图像、评论和用户。然后，从技术上讲，我们可以像这样设置版本化 API 的路由：

```elixir
scope "/api", HelloWeb.Api, as: :api do
  pipe_through :api

  scope "/v1", V1, as: :v1 do
    resources "/images",  ImageController
    resources "/reviews", ReviewController
    resources "/users",   UserController
  end
end
```

您可以运行 `mix phx.routes` 查看这些定义将如何展示。

有趣的是，只要我们小心不重复路由，我们可以为相同路径使用多个作用域。以下路由器在为相同路径定义两个作用域时是完全可以的：

```elixir
defmodule HelloWeb.Router do
  use Phoenix.Router
  ...
  scope "/", HelloWeb do
    pipe_through :browser

    resources "/users", UserController
  end

  scope "/", AnotherAppWeb do
    pipe_through :browser

    resources "/posts", PostController
  end
  ...
end
```

如果我们确实复制了一个路由，即两个路由有相同的路径，我们将收到这个熟悉的警告：

```
warning: this clause cannot match because a previous clause at line 16 always matches
```

## 管道

在本指南中，我们已经走过了一段不短的路程，而没有谈论我们在路由器中看到的第一行之一：`pipe_through :browser`。现在是时候解决这个问题了。

管道是一系列可以附加到特定作用域的插件。如果您不熟悉插件，我们有一个关于它们的[深入指南](https://hexdocs.pm/phoenix/plug.html)。

路由是在作用域内定义的，作用域可以通过多个管道进行处理。一旦路由匹配，Phoenix 将调用与该路由关联的所有管道中定义的所有插件。例如，访问 `/` 将通过 `:browser` 管道，因此会调用其所有插件。

Phoenix 默认定义两个管道，`:browser` 和 `:api`，可用于多种常见任务。我们可以根据需要自定义这些管道以及创建新的管道。

## `:browser` 和 `:api` 管道

正如其名称所暗示的，`:browser` 管道准备用于渲染请求的路由，而 `:api` 管道则准备产生 API 数据的路由。

`:browser` 管道有六个插件：插件 `:accepts, ["html"]` 定义了接受的请求格式或格式。`:fetch_session`，自然地，它提取会话数据并使其在连接中可用。`:fetch_live_flash`，它提取任何来自 LiveView 的闪现消息并将其与控制器的闪现消息合并。然后，插件 `:put_root_layout` 将存储根布局以用于渲染。随后，`:protect_from_forgery` 和 `:put_secure_browser_headers` 保护表单提交以防止跨站点伪造。

目前，`:api` 管道只定义插件 `:accepts, ["json"]`。

路由在作用域内调用管道。作用域外的路由没有管道。尽管不建议使用嵌套作用域（见上面的版本化 API 示例），但如果我们在嵌套作用域内调用 `pipe_through`，路由器将调用来自父作用域的所有 `pipe_through`，然后再调用嵌套作用域的管道。

这些是很多密集在一起的词。让我们看一些示例以拆解它们的含义。

这是一个新生成的 Phoenix 应用程序中的路由器的再次展示，这次将 `/api` 作用域取消注释并添加一个路由。

```elixir
defmodule HelloWeb.Router do
  use HelloWeb, :router

  pipeline :browser do
    plug :accepts, ["html"]
    plug :fetch_session
    plug :fetch_live_flash
    plug :put_root_layout, html: {HelloWeb.Layouts, :root}
    plug :protect_from_forgery
    plug :put_secure_browser_headers
  end

  pipeline :api do
    plug :accepts, ["json"]
  end

  scope "/", HelloWeb do
    pipe_through :browser

    get "/", PageController, :home
  end

  # 其他作用域可能使用自定义栈。
  scope "/api", HelloWeb do
    pipe_through :api

    resources "/reviews", ReviewController
  end
  # ...
end
```

当服务器接受请求时，请求将首先通过我们端点中的插件，之后将尝试在路径和 HTTP 动词上进行匹配。

假设请求与我们第一个路由匹配：对 `/` 的 GET 请求。路由器将首先通过 `:browser` 管道处理该请求——这将提取会话数据、提取闪现消息并执行伪造保护，然后在将请求分配给 `PageController` 的 `home` 动作之前。

相反，假设请求与通过 `resources/2` 宏定义的任何路由匹配。在这种情况下，路由器将通过 `:api` 管道进行处理——目前，仅执行内容协商，然后再进一步分配给 `HelloWeb.ReviewController` 的正确动作。

如果没有路由匹配，则不会调用任何管道，并引发 404 错误。

## 创建新管道

Phoenix 允许我们在路由器的任何地方创建自己的自定义管道。为此，我们通过调用 `pipeline/2` 宏，传入一个原子作为新管道的名称，以及一个包含我们想要的所有插件的块。

```elixir
defmodule HelloWeb.Router do
  use HelloWeb, :router

  pipeline :browser do
    plug :accepts, ["html"]
    plug :fetch_session
    plug :fetch_live_flash
    plug :put_root_layout, html: {HelloWeb.Layouts, :root}
    plug :protect_from_forgery
    plug :put_secure_browser_headers
  end

  pipeline :auth do
    plug HelloWeb.Authentication
  end

  scope "/reviews", HelloWeb do
    pipe_through [:browser, :auth]

    resources "/", ReviewController
  end
end
```

上述代码假设存在一个名为 `HelloWeb.Authentication` 的插件，用于进行身份认证，并且现在是 `:auth` 管道的一部分。

注意，管道本身也是插件，因此我们可以将一个管道嵌入到另一个管道中。例如，我们可以将上述 auth 管道重写为自动调用浏览器，从而简化后续管道调用：

```elixir
pipeline :auth do
  plug :browser
  plug :ensure_authenticated_user
  plug :ensure_user_owns_review
end

scope "/reviews", HelloWeb do
  pipe_through :auth

  resources "/", ReviewController
end
```

## 如何组织我的路由？

在 Phoenix 中，我们倾向于定义多个管道，以提供特定的功能。例如，`:browser` 和 `:api` 管道旨在被特定客户端访问，分别是浏览器和 http 客户端。

更重要的是，定义特定于身份验证和授权的管道是非常常见的。例如，您可能有一个管道要求所有用户都经过身份验证。另一个管道可能强制只有管理员用户可以访问某些路由。

一旦定义了您的管道，您可以在所需的作用域中重用这些管道，将路由分组在它们的管道周围。例如，回到我们的评论示例。假设任何人都可以阅读评论，但只有经过身份验证的用户才能创建评论。您的路由可以如下所示：

```elixir
pipeline :browser do
  ...
end

pipeline :auth do
  plug HelloWeb.Authentication
end

scope "/" do
  pipe_through [:browser]

  get "/reviews", PostController, :index
  get "/reviews/:id", PostController, :show
end

scope "/" do
  pipe_through [:browser, :auth]

  get "/reviews/new", PostController, :new
  post "/reviews", PostController, :create
end
```

注意上述代码中，路由在不同的作用域中分开。虽然这种分离初看会令人困惑，但它有一个重大优点：非常容易检查您的路由，查看所有需要身份验证的路由和不需要身份验证的路由。这有助于审计并确保您的路由具有适当的作用域。

您可以创建尽可能少或尽可能多的作用域。由于管道可以在作用域之间重用，它们有助于封装共同功能，并且可以根据需要在您定义的每个作用域中组合它们。

## 转发

`Phoenix.Router.forward/4` 宏可用于将以特定路径开头的所有请求发送到特定插件。假设我们有一个系统部分负责在后台运行作业，它甚至可以有自己的 Web 界面来检查作业的状态。我们可以使用以下代码将其转发到该管理界面：

```elixir
defmodule HelloWeb.Router do
  use HelloWeb, :router

  ...

  scope "/", HelloWeb do
    ...
  end

  forward "/jobs", BackgroundJob.Plug
end
```

这意味着所有以 `/jobs` 开头的路由将发送到 `HelloWeb.BackgroundJob.Plug` 模块。在插件内部，您可以匹配子路由，例如 `/pending` 和 `/active`，以显示某些作业的状态。

我们甚至可以将 `forward/4` 宏与管道混合。如果我们希望确保用户经过身份验证并且是管理员才能查看作业页面，我们可以在路由器中使用以下代码。

```elixir
defmodule HelloWeb.Router do
  use HelloWeb, :router

  ...

  scope "/" do
    pipe_through [:authenticate_user, :ensure_admin]
    forward "/jobs", BackgroundJob.Plug
  end
end
```

这意味着 `authenticate_user` 和 `ensure_admin` 管道中的插件将在 `BackgroundJob.Plug` 之前被调用，使它们能够发送适当的响应并相应地停止请求。

在 `Module Plug` 的 `init/1` 回调中接收的 opts 可以作为第三个参数传递。例如，也许该后台作业让您设置要在页面上显示的应用程序名称。可以通过以下方式传递：

```elixir
forward "/jobs", BackgroundJob.Plug, name: "Hello Phoenix"
```

可以传递第四个 router_opts 参数。这些选项在 `Phoenix.Router.scope/2` 文档中列出。

`BackgroundJob.Plug` 可以实现为在 Plug 指南中讨论的任何模块插件。请注意，不建议转发到另一个 Phoenix 端点。这是因为您应用程序定义的插件和转发的端点的插件将被调用两次，这可能导致错误。

## 总结

路由是一个大主题，我们已经涵盖了很多领域。本指南的重要要点包括：

- 以 HTTP 动词名称开头的路由扩展为匹配函数的单一子句。
- 用 `resources` 声明的路由扩展为匹配函数的 8 个子句。
- 资源可以使用 `only:` 或 `except:` 选项限制匹配函数子句的数量。
- 这些路由都可以嵌套。
- 这些路由都可以作用于给定路径。
- 使用 `~p` 进行的经过验证的路由可以在编译时进行检查。