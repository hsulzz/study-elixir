# 组件和HEEx

>要求：本指南期待你已经阅读了入门指南并成功运行了一个Phoenix应用程序。

>要求：本指南期待你已经阅读了请求生命周期指南。

Phoenix端点管道接收请求，将其路由到控制器，并调用视图模块来渲染模板。控制器与视图的接口很简单——控制器调用一个视图函数，提供连接的赋值，而该函数的任务是返回一个HEEx模板。我们称任何接受赋值参数并返回HEEx模板的函数为功能组件。功能组件是借助Phoenix.Component模块定义的。

功能组件是Phoenix中任何基于标记的模板渲染的基本构建块。它们为标准MVC控制器应用程序、LiveView应用程序、布局以及在其他模板中使用的小型UI定义提供了一个共享的抽象。

在本章中，我们将回顾之前章节中如何使用组件，并寻找它们的新用例。

功能组件
在请求生命周期章节的最后，我们在lib/hello_web/controllers/hello_html/show.html.heex中创建了一个模板，接下来打开它：

<section>
  <h2>你好，来自<%= @messenger %>!</h2>
</section>

这个模板是作为HelloHTML的一部分嵌入在lib/hello_web/controllers/hello_html.ex中：

```elixir
defmodule HelloWeb.HelloHTML do
  use HelloWeb, :html

  embed_templates "hello_html/*"
end
```

这很简单。只有两行，使用HelloWeb, :html。这一行调用了HelloWeb中定义的html/0函数，该函数为我们的功能组件和模板设置了基本的导入和配置。

我们在模块中所做的所有导入和别名在我们的模板中也会可用。这是因为模板实际上被编译成它们各自模块内的函数。例如，如果你在模块中定义了一个函数，你将能够直接从模板中调用它。让我们看一下实践中的例子。

假设我们想重构我们的show.html.heex，将<h2>你好，来自<%= @messenger %>!</h2>的渲染移到一个独立的函数中。我们可以把它移到HelloHTML中的一个功能组件中，让我们这样做：

```elixir
defmodule HelloWeb.HelloHTML do
  use HelloWeb, :html

  embed_templates "hello_html/*"

  attr :messenger, :string, required: true

  def greet(assigns) do
    ~H"""
    <h2>你好，来自<%= @messenger %>!</h2>
    """
  end
end
```

我们通过Phoenix.Component提供的attr/3宏声明了我们接受的属性，然后定义了返回HEEx模板的greet/1函数。

接下来我们需要更新show.html.heex：

<section>
  <.greet messenger={@messenger} />
</section>

当我们重新加载http://localhost:4000/hello/Frank时，我们应该看到与之前相同的内容。

由于模板嵌入在HelloHTML模块中，我们能够简单地调用视图函数<.greet messenger="..." />。

如果组件定义在其他地方，我们也可以输入<HelloWeb.HelloHTML.greet messenger="..." />。

通过将属性声明为必需，Phoenix会在编译时发出警告，如果我们在未传递属性的情况下调用<.greet />组件。如果某个属性是可选的，可以使用：default选项指定一个值：

```elixir
attr :messenger, :string, default: nil
```

尽管这只是一个快速的例子，但它展示了功能组件在Phoenix中扮演的不同角色：

- 功能组件可以定义为接收分配作为参数并调用~H字面量的函数，就像我们在greet/1中做的那样。
- 功能组件可以从模板文件中嵌入，这就是我们如何将show.html.heex加载到HelloWeb.HelloHTML中的。
- 功能组件可以声明期望的属性，这些属性在编译时进行验证。
- 功能组件可以直接从控制器中渲染。
- 功能组件可以直接从其他功能组件中渲染，就像我们从show.html.heex中调用<.greet messenger={@messenger} />那样。

还有更多。在深入之前，让我们充分理解HEEx模板语言的表达能力。

## HEEx

功能组件和模板文件由HEEx模板语言支持，它代表“HTML+EEx”。EEx是一个Elixir库，使用<%=表达式%>来执行Elixir表达式并将其结果插入模板中。这通常用于显示我们通过@快捷方式设置的赋值。在控制器中，如果你调用：

```elixir
render(conn, :show, username: "joe")
```

那么你可以在模板中访问该用户名，如<%= @username %>。除了显示赋值和函数外，我们几乎可以使用任何Elixir表达式。例如，为了使用条件：

```elixir
<%= if some_condition? do %>
  <p>Some condition is true for user: <%= @username %></p>
<% else %>
  <p>Some condition is false for user: <%= @username %></p>
<% end %>
```

甚至循环：

```elixir
<table>
  <tr>
    <th>编号</th>
    <th>平方</th>
  </tr>
  <%= for number <- 1..10 do %>
    <tr>
      <td><%= number %></td>
      <td><%= number * number %></td>
    </tr>
  <% end %>
</table>
```

你注意到使用<%= %>与<% %>的区别了吗？所有输出内容到模板的表达式必须使用等号（=）。如果没有这个，代码仍然会执行，但什么也不会插入到模板中。

HEEx还带有实用的HTML扩展，我们将在接下来学习。

## HTML扩展

除了允许通过<%= %>插入Elixir表达式外，.heex模板还带有HTML感知扩展。例如，如果你尝试插入一个包含"<"或">"的值，这将导致HTML注入：

```elixir
<%= "<b>加粗?</b>" %>
```

一旦你渲染模板，你将在页面上看到字面量<b>。这意味着用户无法在页面上注入HTML内容。如果你想允许他们这样做，可以调用raw，但请谨慎使用：

```elixir
<%= raw "<b>加粗?</b>" %>
```

HEEx模板的另一个强大功能是HTML验证和属性插值语法的简化。你可以写：

```elixir
<div title="我的div" class={@class}>
  <p>你好<%= @username %></p>
</div>
```

注意你可以简单地使用key={value}。HEEx会自动处理例如false以删除属性或类列表等特殊值。

要在关键字列表或映射中插入动态数量的属性，可以执行：

```elixir
<div title="我的div" {@many_attributes}>
  <p>你好<%= @username %></p>
</div>
```

此外，尝试删除闭合标签</div>或重命名为</div-typo>。HEEx模板将会通知你你的错误。

HEEx还通过特殊的：if和：for属性支持简写语法。例如，与以下内容相比：

```elixir
<%= if @some_condition do %>
  <div>...</div>
<% end %>
```

你可以写：

```elixir
<div :if={@some_condition}>...</div>
```

同样，for理解可以写成：

```elixir
<ul>
  <li :for={item <- @items}><%= item.name %></li>
</ul>
```

## 布局

布局就是功能组件。它们在模块中定义，就像其他所有功能组件模板一样。在一个新生成的应用中，这是lib/hello_web/components/layouts.ex。你还会在layouts文件夹中找到两个由Phoenix生成的内置布局。默认的根布局称为root.html.heex，它是所有模板默认渲染的布局。第二个是应用布局，称为app.html.heex，它在根布局内渲染并包含我们的内容。

你可能想知道，从渲染视图得到的字符串是如何放入布局中的。这是个好问题！如果我们查看lib/hello_web/components/layouts/root.html.heex，几乎在<body>的末尾，我们会看到这个。

```elixir
<%= @inner_content %>
```

换句话说，在渲染页面后，结果被放置在`@inner_content`赋值中。

Phoenix提供了各种便利工具来控制应该渲染哪个布局。例如，`Phoenix.Controller`模块提供了`put_root_layout/2`函数，让我们切换根布局。这个函数的第一个参数是`conn`，第二个参数是格式和它们的布局的关键字列表。你可以将其设置为false以完全禁用布局。

你可以编辑`lib/hello_web/controllers/hello_controller.ex`中的`HelloController`的`index`操作，让它看起来像这样。

```elixir
def index(conn, _params) do
  conn
  |> put_root_layout(html: false)
  |> render(:index)
end
```

重新加载`http://localhost:4000/hello`后，我们应该会看到一个非常不同的页面，没有标题或CSS样式。

要自定义应用布局，我们可以调用一个类似的名为put_layout/2的函数。让我们实际上创建另一个布局并将index模板渲染到它中。作为例子，假设我们在应用的管理部分有一个不同的布局，没有logo图像。为此，将现有的app.html.heex复制到lib/hello_web/components/layouts中一个新的文件admin.html.heex中。然后在新文件中删除<header>...</header>标签内的所有内容（或者根据你的需求进行更改）。

现在，在lib/hello_web/controllers/hello_controller.ex的控制器的index操作中，添加以下内容：

```elixir
def index(conn, _params) do
  conn
  |> put_layout(html: :admin)
  |> render(:index)
end
```

当我们加载页面时，我们应该正在渲染没有头部的admin布局（或你编写的自定义布局）。

此时，你可能会想，为什么Phoenix有两个布局？

首先，它给我们灵活性。在实践中，我们很少会有多个根布局，因为它们通常只包含HTML头。这使我们能够专注于不同的应用布局，仅包含它们之间变化的部分。其次，Phoenix配备了一个名为LiveView的功能，允许我们构建丰富且实时的用户体验，这些体验基于服务器渲染的HTML。LiveView能够动态地改变页面的内容，但它只会更改应用布局，而不会更改根布局。请查看LiveView文档以了解更多信息。

## CoreComponents

在新的Phoenix应用中，你还会在组件文件夹中找到core_components.ex模块。这个模块是定义在我们应用中可重用的功能组件的一个很好的例子。这确保了随着我们应用的发展，我们的组件看起来保持一致。

如果你查看lib/hello_web.ex中的HelloWeb的`def html`，你会看到CoreComponents会通过`use HelloWeb, :html`自动导入到所有HTML视图中。这也是CoreComponents本身在顶部执行`use Phoenix.Component`而不是`use HelloWeb, :html`的原因：这样做会导致死锁，因为我们会尝试将CoreComponents导入到它自身中。

CoreComponents在Phoenix代码生成器中也发挥着重要作用，因为代码生成器假设这些组件是可用的，以便快速构建你的应用。如果你想了解更多关于这些部分的信息，你可以：

- 探索生成的CoreComponents模块，从实际示例中获得更多信息
- 阅读[Phoenix.Component](https://hexdocs.pm/phoenix_live_view/Phoenix.Component.html)的官方文档
- 阅读[HEEx和~H字面量的官方文档](https://hexdocs.pm/phoenix_live_view/Phoenix.Component.html#sigil_H/2)