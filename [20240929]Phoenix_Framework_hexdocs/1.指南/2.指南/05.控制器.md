# 控制器

> 要求：本指南假设您已阅读入门指南并成功运行 Phoenix 应用程序。

> 要求：本指南假设您已阅读请求生命周期指南。Phoenix 控制器充当中介模块。它们的功能 — 被称为动作 — 是根据 HTTP 请求由路由器调用的。这些动作汇集所有必要的数据并执行所有必要的步骤，然后调用视图层来渲染模板或返回 JSON 响应。

Phoenix 控制器还基于 Plug 包，并且本身就是 plugs。控制器提供在动作中执行几乎所有需要的功能。如果我们发现自己在寻找 Phoenix 控制器没有提供的东西，我们可能会在 Plug 本身找到我们需要的。有关更多信息，请参见 Plug 指南或 Plug 文档。

新生成的 Phoenix 应用将有一个名为 PageController 的控制器，可以在 lib/hello_web/controllers/page_controller.ex 中找到，它的代码如下：

```elixir
defmodule HelloWeb.PageController do
  use HelloWeb, :controller

  def home(conn, _params) do
    render(conn, :home, layout: false)
  end
end
```

在模块定义下面的第一行调用了 HelloWeb 模块的 `__using__/1` 宏，这会导入一些有用的模块。PageController 提供了 home 动作，以显示与路由器中定义的默认路由相关的 Phoenix 欢迎页面。

动作 控制器的动作只是函数。只要遵循 Elixir 的命名规则，我们可以给它们任何名字。我们必须满足的唯一要求是动作名称与路由器中定义的路由匹配。

例如，在 lib/hello_web/router.ex 中，我们可以将新应用中 Phoenix 给我们的默认路由的动作名称从 home 改为 index：

```elixir
get "/", PageController, :index
```

只要我们在 PageController 中将动作名称也改为 index，欢迎页面就会照常加载。

```elixir
defmodule HelloWeb.PageController do
  ...

  def index(conn, _params) do
    render(conn, :index)
  end
end
```

虽然我们可以随意命名我们的动作，但有一些命名约定是我们应尽可能遵循的。我们在路由指南中讨论过这些，但这里再快速回顾一下。

* index - 渲染给定资源类型的所有项的列表
* show - 通过 ID 渲染单个项
* new - 渲染用于创建新项的表单
* create - 接收一个新项的参数并将其保存到数据存储中
* edit - 通过 ID 检索单个项，并在表单中显示以进行编辑
* update - 接收一个编辑项的参数并将项保存到数据存储中
* delete - 接收要删除的项的 ID，并从数据存储中删除它

这些动作都接受两个参数，这些参数由 Phoenix 在后台提供。第一个参数始终是 conn，这是一种结构，包含有关请求的信息，例如主机、路径元素、端口、查询字符串等。conn 通过 Elixir 的 Plug 中间件框架传递给 Phoenix。有关 conn 的更详细信息，请参见 Plug.Conn 文档。

第二个参数是 params。显而易见，这是一个映射，包含在 HTTP 请求中传递的任何参数。在函数签名中对参数进行模式匹配是一个好习惯，这样可以以简单的方式打包数据，便于传递给渲染。我们在请求生命周期指南中看到过这种做法，当时我们在 lib/hello_web/controllers/hello_controller.ex 中为 show 路由添加了一个 messenger 参数。

```elixir
defmodule HelloWeb.HelloController do
  ...

  def show(conn, %{"messenger" => messenger}) do
    render(conn, :show, messenger: messenger)
  end
end
```

在某些情况下 — 通常在 index 动作中 — 我们并不在乎参数，因为我们的行为并不依赖于它们。在这些情况下，我们不使用传入的参数，只需将变量名以下划线开头，称之为 _params。这将使编译器不对未使用变量报错，同时仍保持正确的参数数目。

渲染 控制器可以通过多种方式渲染内容。最简单的方法是使用 Phoenix 提供的 `text/2` 函数渲染一些纯文本。 

例如，让我们将 HelloController 中的 show 动作重写为返回文本。我们可以执行以下操作。

```elixir
def show(conn, %{"messenger" => messenger}) do
  text(conn, "来自 messenger #{messenger}")
end
```

现在在浏览器中访问 /hello/Frank 应该会显示 “来自 messenger Frank” 的纯文本，而没有任何 HTML。 

更进一步的是使用 `json/2` 函数渲染纯 JSON。我们需要传递一些 Jason 库可以解码为 JSON 的内容，例如一个映射。（Jason 是 Phoenix 的依赖之一。）

```elixir
def show(conn, %{"messenger" => messenger}) do
  json(conn, %{id: messenger})
end
```

如果我们再次在浏览器中访问 /hello/Frank，我们应该看到一块 JSON，其中键 id 映射到字符串 “Frank” 上。

```json
{"id": "Frank"}
```

`json/2` 函数对于编写 APIs 很有用，还有 `html/2` 函数用于渲染 HTML，但大多数情况下我们使用 Phoenix 视图来构建响应。为此，Phoenix 包含 `render/3` 函数。对于 HTML 响应，它尤其重要，因为 Phoenix 视图提供性能和安全优势。
****