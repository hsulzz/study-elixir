# Ecto

> 需求：本指南假设您已经完成了入门指南，并使 Phoenix 应用程序正常运行。

如今，大多数 Web 应用程序都需要某种形式的数据验证和持久性。在 Elixir 生态系统中，我们有 Ecto 来实现这一点。在我们开始构建数据库支持的 Web 特性之前，我们将专注于 Ecto 的细节，以便为构建我们的 Web 特性打下坚实的基础。让我们开始吧！

Phoenix 使用 Ecto 提供对以下数据库的内置支持：

- PostgreSQL（通过 postgrex）
- MySQL（通过 myxql）
- MSSQL（通过 tds）
- ETS（通过 etso）
- SQLite3（通过 ecto_sqlite3）

新生成的 Phoenix 项目默认包含 Ecto 和 PostgreSQL 适配器。您可以传递 --database 选项来更改或 --no-ecto 标志来排除这一选项。

Ecto 还支持其他数据库，并且有很多学习资源可供使用。请查看 Ecto 的 README 以获取一般信息。

本指南假定我们生成了集成 Ecto 的新应用程序，并且我们将使用 PostgreSQL。入门指南涵盖了如何使您的第一个应用程序正常运行。有关使用其他数据库的信息，请参见使用其他数据库部分。

## 使用模式和迁移生成器

一旦我们安装并配置了 Ecto 和 PostgreSQL，使用 Ecto 的最简单方法是通过 `phx.gen.schema` 任务生成一个 Ecto schema。Ecto schema是我们指定 Elixir 数据类型如何映射到外部源（例如数据库表）的一种方式。让我们生成一个包含 name、email、bio 和 number_of_pets 字段的 User schema。

```elixir
mix phx.gen.schema User users name:string email:string \
bio:string number_of_pets:integer
```

* 创建 ./lib/hello/user.ex
* 创建 priv/repo/migrations/20170523151118_create_users.exs

记得通过运行迁移来更新您的数据库：

```elixir
$ mix ecto.migrate
```

此任务生成了几个文件。首先，我们有一个 user.ex 文件，包含我们的 Ecto schema以及我们传递给任务的字段定义。接下来，生成了一个位于 priv/repo/migrations/ 中的迁移文件，它将创建我们的数据库表，模式映射到该表。

文件准备好后，让我们按照说明运行迁移：

```elixir
mix ecto.migrate
```

编译 1 个文件（.ex）
生成 hello 应用程序

[信息] == 运行 Hello.Repo.Migrations.CreateUsers.change/0 向前

[信息] 创建表用户

[信息] == 在 0.0 秒内迁移
Mix 假定我们在开发环境中，除非我们通过 `MIX_ENV=prod mix ecto.migrate` 告诉它。

如果我们登录到数据库服务器，并连接到 hello_dev 数据库，我们应该能看到我们的用户表。Ecto 假定我们希望一个名为 id 的整数列作为主键，因此我们也应该看到一个为其生成的序列。

```sql
psql -U postgres

Type "help" for help.

postgres=# \connect hello_dev
You are now connected to database "hello_dev" as user "postgres".
hello_dev=# \d
                关系列表
模式 |       名称        |   类型   |  拥有者
--------+-------------------+----------+----------
 public | schema_migrations | 表      | postgres
 public | users             | 表      | postgres
 public | users_id_seq      | 序列    | postgres
(3 行)
hello_dev=# \q
```

如果我们查看 priv/repo/migrations/ 中由 phx.gen.schema 生成的迁移文件，我们会看到它将添加我们指定的列。它还将添加 `inserted_at` 和 `updated_at` 的时间戳列，这些来自 `timestamps/1` 函数。

```elixir
defmodule Hello.Repo.Migrations.CreateUsers do
  use Ecto.Migration

  def change do
    create table(:users) do
      add :name, :string
      add :email, :string
      add :bio, :string
      add :number_of_pets, :integer

      timestamps()
    end
  end
end
```

那么这在实际的用户表中会变成什么样呢？

```sql
psql
hello_dev=# \d users
表 "public.users"
列          |            类型             | 修饰符
---------------+-----------------------------+----------------------------------------------------
id             | bigint                      | not null default nextval('users_id_seq'::regclass)
name           | character varying(255)      |
email          | character varying(255)      |
bio            | character varying(255)      |
number_of_pets | integer                     |
inserted_at    | timestamp without time zone | not null
updated_at     | timestamp without time zone | not null
索引：
"users_pkey" PRIMARY KEY, btree (id)
```

请注意，尽管我们的迁移中并没有将其列为字段，但我们仍然默认得到一个 id 列作为我们的主键。

Repo 配置
我们的 Hello.Repo 模块是与 Phoenix 应用程序中的数据库交互所需的基础。Phoenix 为我们在 lib/hello/repo.ex 中生成了它，它的样子如下：

```elixir
defmodule Hello.Repo do
  use Ecto.Repo,
    otp_app: :hello,
    adapter: Ecto.Adapters.Postgres
end
```

它首先定义了存储库模块。然后，它配置了我们的 otp_app 名称和适配器 - 在我们的情况下是 Postgres。

我们的 repo 有三个主要任务 - 引入所有来自 [Ecto.Repo] 的常用查询函数，使 otp_app 名称等于我们的应用程序名称并配置我们的数据库适配器。关于如何使用 Hello.Repo，我们稍后将详细讨论。

当 phx.new 生成我们的应用程序时，它还包括了一些基本的存储库配置。让我们看看 config/dev.exs。

```elixir
...
# 配置您的数据库
config :hello, Hello.Repo,
  username: "postgres",
  password: "postgres",
  hostname: "localhost",
  database: "hello_dev",
  show_sensitive_data_on_connection_error: true,
  pool_size: 10
```

我们在 config/test.exs 和 config/runtime.exs（以前的 config/prod.secret.exs）中也有类似的配置，可以更改为匹配您的实际凭据。

## Schema

Ecto 模式负责将 Elixir 值映射到外部数据源，并将外部数据映射回 Elixir 数据结构。我们还可以在应用程序中定义与其他模式的关系。例如，我们的 User 模式可能会有多个帖子，而每个帖子将属于一个用户。Ecto 还通过 changesets 处理数据验证和类型转换，我们将在稍后讨论。

下面是 Phoenix 为我们生成的 User 模式。

```elixir
defmodule Hello.User do
  use Ecto.Schema
  import Ecto.Changeset

  schema "users" do
    field :bio, :string
    field :email, :string
    field :name, :string
    field :number_of_pets, :integer

    timestamps()
  end

  @doc false
  def changeset(user, attrs) do
    user
    |> cast(attrs, [:name, :email, :bio, :number_of_pets])
    |> validate_required([:name, :email, :bio, :number_of_pets])
  end
end
```

Ecto 模式在其核心实际上只是 Elixir 结构。我们的模式块告诉 Ecto 如何将我们的 `%User{}` 结构字段映射到外部的用户表。通常，仅仅能够将数据从数据库中简单地转换是不够的，需要额外的数据验证。这就是 Ecto changesets 的作用。让我们深入了解！

## Changesets 和验证

Changesets 定义了我们数据在准备好为应用程序使用之前需要经历的转换管道。这些转换可能包括类型转换、用户输入验证以及过滤掉任何多余的参数。我们通常使用 changesets 来验证用户输入是否可以写入数据库。Ecto 存储库也支持 changeset，这使得它们不仅可以拒绝无效数据，还可以通过检查 changeset 来执行最小的数据库更新，从而知道哪些字段已更改。

让我们更仔细地查看我们默认的 changeset 函数。

```elixir
def changeset(user, attrs) do
  user
  |> cast(attrs, [:name, :email, :bio, :number_of_pets])
  |> validate_required([:name, :email, :bio, :number_of_pets])
end
```

现在，我们在管道中有两个转换。在第一次调用中，我们调用了 Ecto.Changeset.cast/3，传入了外部参数并标记了哪些字段是必须进行验证的。

cast/3 首先接受一个结构体，然后是参数（拟议的更新），最后一个字段是要更新的列列表。cast/3 还将仅接受在schema中存在的字段。

接下来，Ecto.Changeset.validate_required/3 检查这个字段列表是否存在于 cast/3 返回的 changeset 中。与生成器一起使用时，所有字段都是必需的。

我们可以在 IEx 中验证此功能。让我们通过运行 `iex -S mix` 启动我们的应用程序。为了减少输入并使其更易于阅读，让我们将我们的 Hello.User 结构重命名为别名。

```elixir
iex -S mix

iex> alias Hello.User
Hello.User
```

接下来，让我们从我们的schema构建一个 changeset，使用一个空的 User 结构和一个空的参数映射。

```elixir
changeset = User.changeset(%User{}, %{})
#Ecto.Changeset<
  action: nil,
  changes: %{},
  errors: [
    name: {"can't be blank", [validation: :required]},
    email: {"can't be blank", [validation: :required]},
    bio: {"can't be blank", [validation: :required]},
    number_of_pets: {"can't be blank", [validation: :required]}
  ],
  data: #Hello.User<>,
  valid?: false
>
```

一旦我们有了 changeset，我们可以检查它是否有效。

```elixir
changeset.valid?
false
```

因为这个 changeset 无效，我们可以询问它的错误是什么。

```elixir
changeset.errors
[
  name: {"can't be blank", [validation: :required]},
  email: {"can't be blank", [validation: :required]},
  bio: {"can't be blank", [validation: :required]},
  number_of_pets: {"can't be blank", [validation: :required]}
]
```

现在，让我们让 number_of_pets 变为可选。为此，我们只需将其从 changeset/2 函数中的列表中移除，放在 Hello.User 中。

```elixir
    |> validate_required([:name, :email, :bio])
```

现在，转换 changeset 时应该只告诉我们 name、email 和 bio 不能留空。我们可以通过在 IEx 中运行 `recompile()` 来测试，然后重建我们的 changeset。

```elixir
recompile()
编译 1 个文件（.ex）
:ok

changeset = User.changeset(%User{}, %{})
#Ecto.Changeset<
  action: nil,
  changes: %{},
  errors: [
    name: {"can't be blank", [validation: :required]},
    email: {"can't be blank", [validation: :required]},
    bio: {"can't be blank", [validation: :required]}
  ],
  data: #Hello.User<>,
  valid?: false
>

changeset.errors
[
  name: {"can't be blank", [validation: :required]},
  email: {"can't be blank", [validation: :required]},
  bio: {"can't be blank", [validation: :required]}
]
```

如果我们传递一个既不在模式中定义又不是必需的键值对，会发生什么？

在我们现有的 IEx shell 中，让我们创建一个包含有效值和一个额外 random_key: "random value" 的参数映射。

```elixir
params = %{name: "Joe Example", email: "joe@example.com", bio: "An example to all", number_of_pets: 5, random_key: "random value"}
%{
  bio: "An example to all",
  email: "joe@example.com",
  name: "Joe Example",
  number_of_pets: 5,
  random_key: "random value"
}
```

接下来，让我们使用我们的新参数映射创建另一个 changeset。

```elixir
changeset = User.changeset(%User{}, params)
#Ecto.Changeset<
  action: nil,
  changes: %{
    bio: "An example to all",
    email: "joe@example.com",
    name: "Joe Example",
    number_of_pets: 5
  },
  errors: [],
  data: #Hello.User<>,
  valid?: true
>
```

我们新的 changeset 是有效的。

```elixir
changeset.valid?
true
```

我们还可以检查 changeset 的更改 - 即在所有转换完成后我们获得的映射。

```elixir
changeset.changes
%{bio: "An example to all", email: "joe@example.com", name: "Joe Example",
  number_of_pets: 5}
```

请注意，我们的 random_key 键和 "random_value" 值已从最终的 changeset 中移除。Changesets 允许我们将外部数据（例如，Web 表单上的用户输入或来自 CSV 文件的数据）转换为系统中的有效数据。无效的参数将被去除，无法根据我们的模式转换的错误数据将在 changeset 错误中突出显示。

我们可以验证的不仅仅是字段是否必需。让我们看看一些更细粒度的验证。

假设我们有一个要求，系统中的所有简历必须至少有两个字符长。我们可以很容易地通过向 changeset 中添加另一个转换来验证 bio 字段的长度。

```elixir
def changeset(user, attrs) do
  user
  |> cast(attrs, [:name, :email, :bio, :number_of_pets])
  |> validate_required([:name, :email, :bio, :number_of_pets])
  |> validate_length(:bio, min: 2)
end
```

现在，如果我们尝试将包含字符 "A" 的值赋给用户的 bio，我们应该在 changeset 的错误中看到Failed validation。

```elixir
recompile()

changeset = User.changeset(%User{}, %{bio: "A"})

changeset.errors[:bio]
{"should be at least %{count} character(s)",
 [count: 2, validation: :length, kind: :min, type: :string]}
```

如果我们还有一个要求，规定简历字段的最大长度，我们可以简单地添加另一条验证。

```elixir
def changeset(user, attrs) do
  user
  |> cast(attrs, [:name, :email, :bio, :number_of_pets])
  |> validate_required([:name, :email, :bio, :number_of_pets])
  |> validate_length(:bio, min: 2)
  |> validate_length(:bio, max: 140)
end
```

假设我们想对 email 字段执行至少一些基本的格式验证。我们想要检查的只是 @ 的存在。Ecto.Changeset.validate_format/3 函数正是我们所需要的。

```elixir
def changeset(user, attrs) do
  user
  |> cast(attrs, [:name, :email, :bio, :number_of_pets])
  |> validate_required([:name, :email, :bio, :number_of_pets])
  |> validate_length(:bio, min: 2)
  |> validate_length(:bio, max: 140)
  |> validate_format(:email, ~r/@/)
end
```

如果我们尝试将 email 设置为 "example.com" 的用户，我们应该看到类似于以下内容的错误消息：

```elixir
recompile()

changeset = User.changeset(%User{}, %{email: "example.com"})

changeset.errors[:email]
{"has invalid format", [validation: :format]}
```

在 changeset 中，我们可以执行许多更多的验证和转换。有关更多信息，请参见 Ecto Changeset 文档。

## 数据持久性

我们已经探索了migration和schema，但尚未持久化任何我们的schema或 changesets。我们之前简要查看了位于 lib/hello/repo.ex 的存储库模块，现在是时候开始使用它了。

Ecto 存储库是与存储系统交互的接口，可以是像 PostgreSQL 这样的数据库，也可以是像 RESTful API 这样的外部服务。Repo 模块的目的就是处理持久化和数据查询的细节。作为调用者，我们只关心获取和持久化数据。Repo 模块负责与底层数据库适配器通信、连接池和数据库约束违规的错误翻译。

让我们回到 IEx 通过 `iex -S mix`，并向数据库插入几个用户。

```elixir
alias Hello.{Repo, User}
[Hello.Repo, Hello.User]

Repo.insert(%User{email: "user1@example.com"})
[debug] QUERY OK db=6.5ms queue=0.5ms idle=1358.3ms
INSERT INTO "users" ("email","inserted_at","updated_at") VALUES ($1,$2,$3) RETURNING "id" ["user1@example.com", ~N[2021-02-25 01:58:55], ~N[2021-02-25 01:58:55]]
{:ok,
 %Hello.User{
   __meta__: #Ecto.Schema.Metadata<:loaded, "users">,
   bio: nil,
   email: "user1@example.com",
   id: 1,
   inserted_at: ~N[2021-02-25 01:58:55],
   name: nil,
   number_of_pets: nil,
   updated_at: ~N[2021-02-25 01:58:55]
 }}

Repo.insert(%User{email: "user2@example.com"})
[debug] QUERY OK db=1.3ms idle=1402.7ms
INSERT INTO "users" ("email","inserted_at","updated_at") VALUES ($1,$2,$3) RETURNING "id" ["user2@example.com", ~N[2021-02-25 02:03:28], ~N[2021-02-25 02:03:28]]
{:ok,
 %Hello.User{
   __meta__: #Ecto.Schema.Metadata<:loaded, "users">,
   bio: nil,
   email: "user2@example.com",
   id: 2,
   inserted_at: ~N[2021-02-25 02:03:28],
   name: nil,
   number_of_pets: nil,
   updated_at: ~N[2021-02-25 02:03:28]
 }}
```

我们开始通过别名化我们的 User 和 Repo 模块来方便访问。接下来，我们使用 User 结构调用 Repo.insert/2。因为我们处于开发环境，所以可以看到存储库在插入底层 `%User{}` 数据时所进行的查询的调试日志。我们收到了一个包含 {:ok, %User{}} 的二元元组，告知我们插入成功。

我们也可以通过将一个 changeset 传递给 Repo.insert/2 来插入用户。如果 changeset 有效，存储库将使用最优的数据库查询来插入记录，并像上面一样返回一个二元素元组。如果 changeset 无效，我们将收到一个包含 :error 及无效 changeset 的二元元组。

插入几个用户后，让我们从 repo 中获取它们。

```elixir
Repo.all(User)
[debug] QUERY OK source="users" db=5.8ms queue=1.4ms idle=1672.0ms
SELECT u0."id", u0."bio", u0."email", u0."name", u0."number_of_pets", u0."inserted_at", u0."updated_at" FROM "users" AS u0 []
[
  %Hello.User{
    __meta__: #Ecto.Schema.Metadata<:loaded, "users">,
    bio: nil,
    email: "user1@example.com",
    id: 1,
    inserted_at: ~N[2021-02-25 01:58:55],
    name: nil,
    number_of_pets: nil,
    updated_at: ~N[2021-02-25 01:58:55]
  },
  %Hello.User{
    __meta__: #Ecto.Schema.Metadata<:loaded, "users">,
    bio: nil,
    email: "user2@example.com",
    id: 2,
    inserted_at: ~N[2021-02-25 02:03:28],
    name: nil,
    number_of_pets: nil,
    updated_at: ~N[2021-02-25 02:03:28]
  }
]
```

这很简单！Repo.all/1 接受一个数据源（在这种情况下是我们的 User 模式），并将其转换为对我们数据库的底层 SQL 查询。在抓取数据后，Repo 使用我们的 Ecto 模式将数据库值映射回 Elixir 数据结构，符合我们的 User 模式。我们不仅限于基本查询 - Ecto 包含一套完整的查询 DSL，可用于高级 SQL 生成。除了自然的 Elixir DSL 外，Ecto 的查询引擎还为我们提供了多个良好的功能，例如 SQL 注入防护和查询的编译时优化。让我们试试看。

```elixir
import Ecto.Query
Ecto.Query

Repo.all(from u in User, select: u.email)
[debug] QUERY OK source="users" db=0.8ms queue=0.9ms idle=1634.0ms
SELECT u0."email" FROM "users" AS u0 []
["user1@example.com", "user2@example.com"]
```

首先，我们导入了 [Ecto.Query]，它导入 Ecto 查询 DSL 的 from/2 宏。接下来，我们构建了一个选择我们用户表中所有电子邮件地址的查询。让我们再试一个示例。

```elixir
Repo.one(from u in User, where: ilike(u.email, "%1%"),
                               select: count(u.id))
[debug] QUERY OK source="users" db=1.6ms SELECT count(u0."id") FROM "users" AS u0 WHERE (u0."email" ILIKE '%1%') []
1
```

现在我们开始领略 Ecto 丰富的查询功能。我们使用 Repo.one/2 抓取所有电子邮件地址中包含 1 的用户的计数，并收到了预期的计数作为返回。这仅仅是 Ecto 查询接口的冰山一角，还有更多功能，例如子查询、时间间隔查询和高级选择语句。例如，让我们构建一个查询，以获取所有用户 id 到其电子邮件地址的映射。

```elixir
Repo.all(from u in User, select: %{u.id => u.email})
[debug] QUERY OK source="users" db=0.9ms
SELECT u0."id", u0."email" FROM "users" AS u0 []
[
  %{1 => "user1@example.com"},
  %{2 => "user2@example.com"}
]
```

这个小查询非常强大。它一方面从数据库中提取了所有的用户电子邮件，另一方面在一次操作中高效地构建了结果映射。您应该浏览 Ecto.Query 文档，以了解支持的查询功能的广度。

除了插入，我们还可以使用 Repo.update/2 和 Repo.delete/2 来更新或删除单个模式。Ecto 还支持使用 Repo.insert_all/3、Repo.update_all/3 和 Repo.delete_all/2 函数进行批量持久化。

Ecto 可以做的事情还有很多，我们只是触及了表面。随着扎实的 Ecto 基础的建立，我们现在准备继续构建我们的应用程序，并将 Web 界面与后端持久性集成。在此过程中，我们将扩展我们的 Ecto 知识，并学习如何正确隔离 Web 界面与系统的底层细节。请查看 Ecto 文档，以获取更多信息。

在我们的上下文指南中，我们将了解如何将 Ecto 访问和业务逻辑封装在分组相关功能的模块后面。我们将看到 Phoenix 如何帮助我们设计可维护的应用程序，并在此过程中发现其他有趣的 Ecto 功能。

## 使用其他数据库

Phoenix 应用程序默认配置为使用 PostgreSQL，但如果我们想使用其他数据库，例如 MySQL，怎么办？在本节中，我们将逐步讲解如何更改此默认设置，不论我们是要创建一个新应用程序，还是已有一个配置为 PostgreSQL 的应用程序。

如果我们准备创建一个新应用程序，配置我们的应用程序以使用 MySQL 是很简单的。我们只需将 --database mysql 标志传递给 phx.new，所有内容将被正确配置。

```elixir
mix phx.new hello_phoenix --database mysql
```

这将自动为我们设置所有正确的依赖关系和配置。一旦通过 `mix deps.get` 安装这些依赖项，我们就可以开始在应用程序中使用 Ecto。

如果我们有一个现有的应用程序，我们所需要做的就是切换适配器并进行一些小的配置更改。

要切换适配器，我们需要移除 Postgrex 依赖项，然后为 MyXQL 添加一个新的依赖项。

让我们打开我们的 mix.exs 文件并执行此操作。

```elixir
defmodule HelloPhoenix.MixProject do
  use Mix.Project

  . . .
  # 指定您的项目依赖项。
  #
  # 输入 `mix help deps` 查看例子和选项。
  defp deps do
    [
      {:phoenix, "~> 1.4.0"},
      {:phoenix_ecto, "~> 4.4"},
      {:ecto_sql, "~> 3.10"},
      {:myxql, ">= 0.0.0"},
      ...
    ]
  end
end
```

接下来，我们需要通过更新 config/dev.exs 来配置我们的适配器以使用默认的 MySQL 凭据：

```elixir
config :hello_phoenix, HelloPhoenix.Repo,
  username: "root",
  password: "",
  database: "hello_phoenix_dev"
```

如果我们有 HelloPhoenix.Repo 的现有配置块，我们只需更改值以匹配我们的新值。您还需要在 config/test.exs 和 config/runtime.exs（以前的 config/prod.secret.exs）文件中配置正确的值。

最后的更改是打开 lib/hello_phoenix/repo.ex，并确保将 :adapter 设置为 Ecto.Adapters.MyXQL。

现在，我们需要做的就是获取我们的新依赖关系，我们就准备好了。

```elixir
mix deps.get
```

安装并配置好新的适配器后，我们已准备好创建数据库。

```elixir
mix ecto.create
```

HelloPhoenix.Repo 的数据库已经创建。我们还准备好运行任何迁移，或者执行其他任何与 Ecto 参与的操作。

```elixir
mix ecto.migrate
[info] == 运行 HelloPhoenix.Repo.Migrations.CreateUser.change/0 向前
[info] 创建表用户
[info] == 在 0.2 秒内迁移
```

## 其他选项

虽然 Phoenix 使用 Ecto 项目与数据访问层进行交互，但还有许多其他数据访问选项，其中一些甚至内置于 Erlang 标准库。ETS（通过 etso 在 Ecto 中可用）和 DETS 是内置于 OTP 的键值数据存储。OTP 还提供了一种关系型数据库，名为 Mnesia，其有自己的一种查询语言称为 QLC。Elixir 和 Erlang 还有许多库可用于使用多种流行数据存储。

数据世界是您的舞台，但我们不会在这些指南中覆盖这些选项。