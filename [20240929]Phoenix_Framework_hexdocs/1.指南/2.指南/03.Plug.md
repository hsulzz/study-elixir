# Plug

> 需求：本指南期望您已阅读入门指南，并成功运行了一个Phoenix应用程序。

> 需求：本指南期望您已阅读请求生命周期指南。

Plug位于Phoenix HTTP层的核心，Phoenix将Plug置于中心位置。我们在请求生命周期的每个步骤都与plugs交互，像端点、路由器和控制器这样的核心Phoenix组件在内部都是plugs。让我们深入了解一下Plug的独特之处。

Plug是一种在网络应用之间组合模块的规范。它也是不同Web服务器的连接适配器的抽象层。Plug的基本思想是统一我们操作的“连接”概念。这与其他HTTP中间件层（如Rack）有所不同，后者在中间件堆栈中将请求和响应分开。

在最简单的层面上，Plug规范有两种类型：函数plug和模块plug。

## 函数plug

要作为plug，函数需要：

1. 将连接结构（%Plug.Conn{}）作为第一个参数，连接选项作为第二个参数；
2. 返回一个连接结构。
3. 
任何满足这两个条件的函数都可以。下面是一个示例。

```elixir
def introspect(conn, _opts) do
  IO.puts """
  Verb: #{inspect(conn.method)}
  Host: #{inspect(conn.host)}
  Headers: #{inspect(conn.req_headers)}
  """

  conn
end
```
这个函数的工作原理如下：

1. 接收一个连接和选项（我们不使用选项）
2. 将一些连接信息打印到终端
3. 返回连接

简单吧？让我们通过将其添加到`lib/hello_web/endpoint.ex`中的端点来看看这个函数的实际效果。我们可以在任何位置插入它，因此就在我们将请求委托给路由器之前插入`plug :introspect`：

```elixir
defmodule HelloWeb.Endpoint do
  ...

  plug :introspect
  plug HelloWeb.Router

  def introspect(conn, _opts) do
    IO.puts """
    Verb: #{inspect(conn.method)}
    Host: #{inspect(conn.host)}
    Headers: #{inspect(conn.req_headers)}
    """

    conn
  end
end
```

函数plugs通过将函数名称作为原子传递来插入。试试这个plug，回到浏览器并访问http://localhost:4000。您应该看到类似这样的信息在您的shell终端中打印出来：

Verb: "GET"
Host: "localhost"
Headers: [...]

我们的plug仅仅打印来自连接的信息。虽然我们的初始plug非常简单，但您可以在其中做几乎任何事情。要了解连接中可用的所有字段以及与之相关的所有功能，请查看Plug.Conn的文档。

现在让我们来看一下另一个plug变体，模块plugs。

## 模块plug

模块plugs是另一种plug类型，可以让我们在模块中定义连接转换。模块只需要实现两个函数：

- `init/1`，用于初始化要传递给`call/2`的任何参数或选项
- `call/2`，用于执行连接转换。`call/2`就是我们之前看到的函数plug

要看看这个的实际效果，让我们编写一个模块plug，将`locale`键和值放入连接中，以便在其他plugs、控制器操作和我们的视图中使用。将下面的内容放入名为`lib/hello_web/plugs/locale.ex`的文件中：

```elixir
defmodule HelloWeb.Plugs.Locale do
  import Plug.Conn

  @locales ["en", "fr", "de"]

  def init(default), do: default

  def call(%Plug.Conn{params: %{"locale" => loc}} = conn, _default) when loc in @locales do
    assign(conn, :locale, loc)
  end

  def call(conn, default) do
    assign(conn, :locale, default)
  end
end
```
为了试试看，我们将这个模块plug添加到我们的路由器中，通过在lib/hello_web/router.ex中的`:browser`管道上追加`plug HelloWeb.Plugs.Locale, "en"`：

```elixir
defmodule HelloWeb.Router do
  use HelloWeb, :router

  pipeline :browser do
    plug :accepts, ["html"]
    plug :fetch_session
    plug :fetch_flash
    plug :protect_from_forgery
    plug :put_secure_browser_headers
    plug HelloWeb.Plugs.Locale, "en"
  end
  ...
```

在`init/1`回调中，如果params中不存在，则传递一个默认的locale来使用。我们还使用模式匹配来定义多个`call/2`函数头，以验证params中的locale，并在没有匹配时回退到"en"。`assign/3`是Plug.Conn模块的一部分，它用于在conn数据结构中存储值。

要查看`assign`的实际效果，请转到lib/hello_web/controllers/page_html/home.html.heex中的模板，并在`</h1>`标签关闭后添加以下代码：

```elixir
<p>Locale: <%= @locale %></p>
```
访问http://localhost:4000/，您应该能看到显示的locale。访问http://localhost:4000/?locale=fr，您应该看到assign更改为"fr"。用户可以使用此信息与Gettext结合，提供一个完全国际化的Web应用程序。

这就是Plug的全部功能。Phoenix全力支持组合转换的plug设计。让我们看看一些示例！

## 插入位置

Phoenix中的端点、路由器和控制器都接受plugs。

### 端点plugs

端点组织所有与每个请求相关的plugs，并在将请求分派到路由器之前应用它们及其自定义管道。我们这样将plug添加到端点：

```elixir
defmodule HelloWeb.Endpoint do
  ...

  plug :introspect
  plug HelloWeb.Router
```

默认的端点plugs做了很多工作。以下是它们的顺序：

- `Plug.Static` - 提供静态资源。由于这个plug出现在logger之前，因此对静态资源的请求不会记录。

- `Phoenix.LiveDashboard.RequestLogger` - 为Phoenix LiveDashboard设置请求记录器，这将允许您选择是传递查询参数以流式传输请求日志，还是启用/禁用从仪表板流式传输请求日志的cookie。

- `Plug.RequestId` - 为每个请求生成一个唯一的请求ID。

- `Plug.Telemetry` - 添加仪器点，以便Phoenix可以默认记录请求路径、状态代码和请求时间。

- `Plug.Parsers` - 当已知的解析器可用时，解析请求正文。默认情况下，这个plug可以处理URL编码、multipart和JSON内容（使用Jason）。如果请求的内容类型无法解析，请求正文将保持不变。

- `Plug.MethodOverride` - 将POST请求的请求方法转换为PUT、PATCH或DELETE（针对有效的_method参数）。

- `Plug.Head` - 将HEAD请求转换为GET请求。

- `Plug.Session` - 用于设置会话管理的plug。请注意，在使用会话之前，`fetch_session/2`仍然必须被显式调用，因为这个plug只是设置了如何获取会话。

在端点的中间部分，还有一个条件块：

```elixir
if code_reloading? do
  socket "/phoenix/live_reload/socket", Phoenix.LiveReloader.Socket
  plug Phoenix.LiveReloader
  plug Phoenix.CodeReloader
  plug Phoenix.Ecto.CheckRepoStatus, otp_app: :hello
end
```

这个块只在开发中执行。它启用了：

- 实时重载 - 如果您更改了CSS文件，它们会在浏览器中自动更新，而无需刷新页面；
- 代码重载 - 我们可以在不重启服务器的情况下查看对应用程序的更改；
- 检查仓库状态 - 确保我们的数据库是最新的，否则引发可读和可操作的错误。

## 路由器plugs

在路由器中，我们可以在管道内声明plugs：

```elixir
defmodule HelloWeb.Router do
  use HelloWeb, :router

  pipeline :browser do
    plug :accepts, ["html"]
    plug :fetch_session
    plug :fetch_live_flash
    plug :put_root_layout, html: {HelloWeb.LayoutView, :root}
    plug :protect_from_forgery
    plug :put_secure_browser_headers
    plug HelloWeb.Plugs.Locale, "en"
  end

  scope "/", HelloWeb do
    pipe_through :browser

    get "/", PageController, :index
  end
```

路由是在作用域内定义的，作用域可以通过多个管道。路由匹配后，Phoenix会调用与该路由关联的所有管道中定义的所有plugs。例如，访问"/"将通过`:browser`管道，因此会依次调用其所有plugs。

正如我们将在路由指南中看到的，管道本身也是plugs。我们将在那里讨论`:browser`管道中的所有plugs。

## 控制器plugs

最后，控制器也是plugs，因此我们可以这样做：

```elixir
defmodule HelloWeb.PageController do
  use HelloWeb, :controller

  plug HelloWeb.Plugs.Locale, "en"
```

特别地，控制器plugs提供的功能，可让我们仅在某些操作内执行plugs。例如，您可以这样做：

```elixir
defmodule HelloWeb.PageController do
  use HelloWeb, :controller

  plug HelloWeb.Plugs.Locale, "en" when action in [:index]
```

这样，这个plug仅在索引操作中执行。

## 组合plugs

通过遵循plug合同，我们将应用程序请求转变为一系列明确的转换。但这还不止于此。为了真正看到Plug设计的有效性，让我们假设一种场景，其中我们需要检查一系列条件，然后在条件失败时重定向或停止。如果没有plug，我们最终会得到这样的代码：

```elixir
defmodule HelloWeb.MessageController do
  use HelloWeb, :controller

  def show(conn, params) do
    case Authenticator.find_user(conn) do
      {:ok, user} ->
        case find_message(params["id"]) do
          nil ->
            conn |> put_flash(:info, "That message wasn't found") |> redirect(to: ~p"/")
          message ->
            if Authorizer.can_access?(user, message) do
              render(conn, :show, page: message)
            else
              conn |> put_flash(:info, "You can't access that page") |> redirect(to: ~p"/")
            end
        end
      :error ->
        conn |> put_flash(:info, "You must be logged in") |> redirect(to: ~p"/")
    end
  end
end
```

注意，几步身份验证和授权需要复杂的嵌套和重复？让我们用几个plugs来改进这一点。

```elixir
defmodule HelloWeb.MessageController do
  use HelloWeb, :controller

  plug :authenticate
  plug :fetch_message
  plug :authorize_message

  def show(conn, params) do
    render(conn, :show, page: conn.assigns[:message])
  end

  defp authenticate(conn, _) do
    case Authenticator.find_user(conn) do
      {:ok, user} ->
        assign(conn, :user, user)
      :error ->
        conn |> put_flash(:info, "You must be logged in") |> redirect(to: ~p"/") |> halt()
    end
  end

  defp fetch_message(conn, _) do
    case find_message(conn.params["id"]) do
      nil ->
        conn |> put_flash(:info, "That message wasn't found") |> redirect(to: ~p"/") |> halt()
      message ->
        assign(conn, :message, message)
    end
  end

  defp authorize_message(conn, _) do
    if Authorizer.can_access?(conn.assigns[:user], conn.assigns[:message]) do
      conn
    else
      conn |> put_flash(:info, "You can't access that page") |> redirect(to: ~p"/") |> halt()
    end
  end
end
```

为了让这个效果正常工作，我们将嵌套代码块转换为一系列扁平的plug转换，并在到达失败路径时使用`halt(conn)`。`halt(conn)`的功能在这里至关重要：它告诉Plug不要调用下一个plug。

归根结底，通过用一系列明确的plug转换替换嵌套代码块，我们便能够以更加组合、清晰和可重用的方式实现相同的功能。

要了解更多关于plugs的内容，请查看Plug项目的文档，该文档提供了许多内置的plugs和功能。