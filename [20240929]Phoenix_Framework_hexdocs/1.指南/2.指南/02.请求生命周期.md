# 请求生命周期

> 要求：本指南假定你已经阅读过入门指南，并成功地启动了Phoenix应用程序。 

本指南的目标是讲解Phoenix的请求生命周期。我们将采用实践方法，通过实际操作学习：我们将向Phoenix项目添加两个新页面，并在过程中评论各个部分如何协调工作。

让我们开始创建我们的第一个新Phoenix页面吧！

## 添加新页面

当你的浏览器访问`http://localhost:4000/`时，它会向在该地址上运行的服务（在本例中是我们的Phoenix应用程序）发送一个HTTP请求。HTTP请求由一个动词和一个路径组成。例如，以下浏览器请求可以翻译为：

| 浏览器地址栏                      | 动词 | 路径         |
| --------------------------------- | ---- | ------------ |
| http://localhost:4000/            | GET  | /            |
| http://localhost:4000/hello       | GET  | /hello       |
| http://localhost:4000/hello/world | GET  | /hello/world |

还有其他HTTP动词。例如，提交表单通常使用POST动词。

Web应用程序通常通过将每个动词/路径对映射到应用程序的特定部分来处理请求。在Phoenix中，这种匹配是由路由器完成的。例如，我们可以将“/articles”映射到应用程序中的一个部分，以显示所有文章。因此，添加新页面的第一步是添加一个新的路由。

## 新的路由

路由器将独特的HTTP `verb/path对` 映射到处理它们的 `controller/action对`。Phoenix中的controller只是Elixir模块。action是在这些控制器中定义的函数。

Phoenix会在新应用程序中为我们生成一个路由文件，位于`lib/hello_web/router.ex`。这就是我们本节要操作的地方。

我们在之前的“启动”指南中为“欢迎来到Phoenix！”页面设置的路由看起来是这样的。

```elixir
get "/", PageController, :home  
```

让我们理解一下这个路由的含义。访问`http://localhost:4000/`会发出一个HTTP GET请求到根路径。所有这样的请求都将由位于`lib/hello_web/controllers/page_controller.ex`中定义的`HelloWeb.PageController`模块中的`home/2`函数处理。

当我们将浏览器指向`http://localhost:4000/hello`时，我们将构建的页面将显示“你好，来自Phoenix！”

我们需要做的第一件事是为新页面创建页面路由。让我们在文本编辑器中打开`lib/hello_web/router.ex`。对于一个全新的应用程序，它看起来是这样的：

```elixir
defmodule HelloWeb.Router do
  use HelloWeb, :router

  pipeline :browser do
    plug :accepts, ["html"]
    plug :fetch_session
    plug :fetch_live_flash
    plug :put_root_layout, html: {HelloWeb.Layouts, :root}
    plug :protect_from_forgery
    plug :put_secure_browser_headers
  end

  pipeline :api do
    plug :accepts, ["json"]
  end

  scope "/", HelloWeb do
    pipe_through :browser

    get "/", PageController, :home
  end

  # 其他作用域可能使用自定义堆栈。
  # scope "/api", HelloWeb do
  #   pipe_through :api
  # end

  # ...
end
```

目前，我们将忽略管道和作用域的使用，并仅专注于添加路由。我们将在路由指南中讨论这些内容。

让我们向路由器添加一个新路由，将对`/hello`的`GET`请求映射到即将创建的`HelloWeb.HelloController`的`index`动作中：

```elixir
scope "/", HelloWeb do
  pipe_through :browser

  get "/", PageController, :home
  get "/hello", HelloController, :index
end
```

## 新的控制器

控制器是Elixir模块，动作是在其中定义的Elixir函数。动作的目的是收集数据并执行渲染所需的任务。我们的路由指定我们需要一个具有`index/2`函数的`HelloWeb.HelloController`模块。

为了实现index动作，让我们创建一个新的`lib/hello_web/controllers/hello_controller.ex`文件，并使其看起来像这样：

```elixir
defmodule HelloWeb.HelloController do
  use HelloWeb, :controller

  def index(conn, _params) do
    render(conn, :index)
  end
end
```

我们先把`use HelloWeb, :controller`的讨论留到控制器指南中。目前，让我们专注于`index` 动作(action)。

所有控制器动作都有两个参数。第一个是conn，这是一个结构体，包含关于请求的大量数据。第二个是params，即请求参数。在这里，我们没有使用params，并通过前缀“_”来避免编译器警告。

这个动作的核心是`render(conn, :index)`。它告诉Phoenix渲染index模板。负责渲染的模块称为视图。默认情况下，Phoenix视图以控制器（`HelloController`）和格式（在本例中为HTML）命名，因此Phoenix期望存在`HelloWeb.HelloHTML`并定义`index/1`函数。

## 新的视图

Phoenix视图充当表示层。例如，我们期望渲染`index`的输出是完整的HTML页面。为了简化我们的生活，我们通常使用模板来创建这些HTML页面。

让我们创建一个新的视图。创建`lib/hello_web/controllers/hello_html.ex`，并使其看起来像这样：

```elixir
defmodule HelloWeb.HelloHTML do
  use HelloWeb, :html
end
```

要向该视图添加模板，我们可以在模块中将其定义为函数组件或分别在文件中定义。

让我们开始定义一个函数组件：

```elixir
defmodule HelloWeb.HelloHTML do
  use HelloWeb, :html

  def index(assigns) do
    ~H"""
    Hello!
    """
  end
end
```

我们定义了一个接收`assigns`作为参数的函数，并使用`~H`符号放置我们想要渲染的内容。在`~H`符号内部，我们使用一种称为HEEx的模板语言，它代表“HTML+EEx”。EEx是嵌入Elixir的库，是Elixir自身的一部分。"HTML+EEx"是Phoenix对EEx的扩展，支持HTML验证、组件和自动转义值。后者可以防止诸如跨站脚本等安全漏洞，而你无需额外的工作。

模板文件的工作方式相同。函数组件适合较小的模板，单独的文件则适合当你有大量标记或函数开始变得难以管理时。

让我们通过在自己的文件中定义模板来试一试。首先从上面删除我们的`def index(assigns)`函数，并用`embed_templates`声明替换它：

```elixir
defmodule HelloWeb.HelloHTML do
  use HelloWeb, :html

  embed_templates "hello_html/*"
end
```

在这里，我们告诉Phoenix.Component将发现的所有.heex模板嵌入到我们模块中作为函数定义。

接下来，我们需要向`lib/hello_web/controllers/hello_html`目录添加文件。

注意控制器名称（HelloController），视图名称（HelloHTML）以及模板目录（hello_html）都遵循相同的命名约定，并以彼此命名。它们也在目录树中紧密结合在一起：

注意：我们可以将hello_html目录重命名为任何我们想要的名称，并放入lib/hello_web/controllers的子目录，只要我们相应地更新embed_templates设置。然而，最好保持相同的命名约定，以避免任何混淆。

```
lib/hello_web
├── controllers
│   ├── hello_controller.ex
│   ├── hello_html.ex
│   ├── hello_html
|       ├── index.html.heex
```

模板文件的结构为：`NAME.FORMAT.TEMPLATING_LANGUAGE`。在我们的例子中，让我们在`lib/hello_web/controllers/hello_html/`目录下创建一个`index.html.heex`文件：

```html
<section>
  <h2>Hello World, from Phoenix!</h2>
</section>
```

模板文件会作为函数组件本身编译到模块中，这两种风格之间没有运行时或性能差异。

现在我们已经有了路由、控制器、视图和模板，我们应该能够将浏览器指向`http://localhost:4000/hello`，并看到我们来自Phoenix的问候！（如果你在此过程中停止了服务器，重启服务器的任务是mix phx.server。）

## Phoenix问候我们

我们刚刚做的事情还有几个有趣的地方需要注意。在我们进行这些更改时，我们不需要停止并重启服务器。是的，Phoenix具备热代码重载！此外，尽管我们的index.html.heex文件仅由一个<section>标签组成，但我们获得的页面是完整的HTML文档。我们的index模板实际上是渲染到布局中的：首先，它渲染`lib/hello_web/components/layouts/root.html.heex`，然后渲染`lib/hello_web/components/layouts/app.html.heex`，最后包含我们的内容。如果你打开这些文件，你会看到底部有一行看起来像这样：

```html
<%= @inner_content %>
```

该行在HTML发送到浏览器之前将我们的模板注入到布局中。我们将在控制器指南中进一步讨论布局。

关于热代码重载的注意事项：某些具有自动检查器的编辑器可能会阻止热代码重载的工作。如果它不工作，请查看该问题中的讨论。

## 从端点到视图

当我们构建第一个页面时，我们可以开始理解请求生命周期是如何组合在一起的。现在让我们更全面地看一下它。

所有HTTP请求都始于我们的应用程序端点。你可以在`lib/hello_web/endpoint.ex`中找到它，模块名为`HelloWeb.Endpoint`。当你打开端点文件时，你将看到，类似于路由器，端点有许多对plug的调用。Plug是一个库和规范，用于将Web应用程序连接在一起。它是Phoenix处理请求的重要组成部分，我们将在即将到来的Plug指南中详细讨论。

目前，仅需说明每个plug定义了一段请求处理。在端点中，你将发现一个骨架，大致如下：

```elixir
defmodule HelloWeb.Endpoint do
  use Phoenix.Endpoint, otp_app: :hello

  plug Plug.Static, ...
  plug Plug.RequestId
  plug Plug.Telemetry, ...
  plug Plug.Parsers, ...
  plug Plug.MethodOverride
  plug Plug.Head
  plug Plug.Session, ...
  plug HelloWeb.Router
end
```

这些plug中的每一个都有特定的职责，我们将在后面的学习中了解。最后一个plug正是HelloWeb.Router模块。这使得端点可以将所有进一步的请求处理委托给路由器。正如我们现在所知道的，它的主要职责是将动词/路径对映射到控制器。控制器然后告诉视图渲染模板。

这时，你可能会想，这样渲染一个页面可能需要很多步骤。然而，随着我们的应用程序在复杂性上增长，我们将看到每一层都服务于不同的目的：

* 端点（Phoenix.Endpoint） - 端点包含所有请求通过的公共和最初的路径。如果你想在所有请求上执行某些操作，它就放在端点中。

* 路由器（Phoenix.Router） - 路由器负责将动词/路径分派给控制器。路由器还允许我们对功能进行分组。例如，你应用程序中的某些页面可能需要用户身份验证，其他页面则不需要。

* 控制器（Phoenix.Controller） - 控制器的工作是检索请求信息，与业务域对话，并为呈现层准备数据。

* 视图 - 视图处理来自控制器的结构化数据，并将其转换为展示给用户的内容。视图通常以他们呈现的内容格式命名。

让我们通过添加另一个页面快速回顾一下最后三个组件是如何协同工作的。

## 另一个新页面

让我们为应用程序添加一些复杂性。我们将添加一个新页面，该页面会识别URL的一部分，将其标记为“messenger”，并通过控制器传递到模板中，以便我们的messenger可以说你好。

与上次一样，首先我们要做的是创建一个新路由。

另一个新路由

在这次练习中，我们将重用之前步骤中创建的HelloController并添加一个新的show动作。我们将在最后一个路由的下方添加一行，如下所示：

```elixir
scope "/", HelloWeb do
  pipe_through :browser

  get "/", PageController, :home
  get "/hello", HelloController, :index
  get "/hello/:messenger", HelloController, :show
end
```

请注意，我们在路径中使用了`:messenger`语法。Phoenix会将出现在URL该位置的任何值转换为参数。例如，如果我们将浏览器指向：`http://localhost:4000/hello/Frank`，那么“messenger”的值将是“Frank”。

## 另一个新动作

对我们新路由的请求将由`HelloWeb.HelloController`的`show`动作处理。我们已经在`lib/hello_web/controllers/hello_controller.ex`中有了控制器，因此我们只需编辑该控制器，向其添加`show`动作。这一次，我们需要从参数中提取`messenger`，以便将其传递到模板中。为此，我们向控制器添加这个`show`函数：

```elixir
def show(conn, %{"messenger" => messenger}) do
  render(conn, :show, messenger: messenger)
end
```

在`show`动作的主体内，我们还向render函数传递第三个参数，一个键值对，其中`：messenger`是键，`messenger`变量作为值传递。

如果动作的主体需要访问绑定到`params`变量的完整参数映射，除了绑定的`messenger`变量，我们可以这样定义`show/2`：

```elixir
def show(conn, %{"messenger" => messenger} = params) do
  ...
end
```

要记住的一点是，params映射的键将始终是字符串，并且等号并不表示赋值，而是模式匹配断言。

## 另一个新模板

要解开这个谜题的最后一部分，我们需要一个新的模板。由于它是`HelloController`的`show`动作，因此它将放到`lib/hello_web/controllers/hello_html`目录，并命名为`show.html.heex`。它的结构出奇地像我们的`index.html.heex`模板，只是我们需要显示`messenger`的名称。

为此，我们将使用执行Elixir表达式的特殊HEEx标签：`<%= %>`。请注意，初始标签像这样带有等号：`<%=` .这意味着在这些标签之间的任何Elixir代码都将被执行，并且结果值将替换HTML输出中的标签。如果缺少等号，代码仍会被执行，但值不会出现在页面上。

记住我们的模板是用HEEx（HTML+EEx）编写的。HEEx是EEx的超集，这就是它与`<%= %>`语法共享的原因。

模板应如下所示：

```html
<section>
  <h2>Hello World, from <%= @messenger %>!</h2>
</section>
```

我们的`messenger`以`@messenger`的形式出现。

从控制器传递到视图的值统称为我们的“assigns”。我们可以通过`assigns.messenger`访问我们的messenger值，但通过一些元编程，Phoenix为我们提供了在模板中使用更简洁的`@`语法。

我们完成了。如果你将浏览器指向http://localhost:4000/hello/Frank，你应该看到一个如下的页面：

Frank Greets Us from Phoenix

玩一下。你在/hello/之后输入的任何内容都会作为你的messenger出现在页面上。