# 模块 <small>行为</small>

提供在编译期间处理模块的功能。它允许开发人员动态添加、删除和注册属性、附加文档等。编译模块后，使用此模块中的许多函数会引发错误，因为它超出了检查运行时数据的范围。大多数运行时数据可以通过附加到每个编译模块的`__info__/1`函数进行检查。

## 模块属性

每个模块都可以用一个或多个属性进行装饰。`Elixir`目前定义了以下内容：

### `@after_compile`

一个钩子，在当前模块编译完后立即被执行。 接受一个模块或者`{module, function_name}`

### `@after_verify`

一个钩子，在当前模块的未定义函数，弃用内容等验证完成后会立即被执行。接受一个模块或者`{module, function_name}`

### `@before_compile`

一个钩子，在模块被编译前调用，接受一个模块或者`{module, function_or_macro_name}`

### `@behaviour`

行为可以被模块引用，以确保它们实现行为模块中被`@callback`定义的必须实现的函数签名。

```elixir
# 定义`URI.Parser`的行为
defmodule URI.Parser do
    @doc "定义一个默认接口"
    @callback default_port() :: integer

    @doc "解析给定的URL"
    @callback parse(uri_info :: URI.t()) :: URI.t()

# 在模块中使用
defmodule URI.HTTP do
    @behaviour URI.Parser
    def default_port(), do: 80
    def parse(info), do: info
```

### `@impl`

为了帮助正确实现行为，您可以选择声明`@impl`以实现行为的回调。这使回调变得明确，并可以帮助您捕捉代码中的错误。在这些情况下，编译器将发出警告：

- 如果您用`@impl`标记一个函数，当该函数不是回调时。
- 如果您在其他函数用`@impl`标记时没有用`@impl`标记一个函数。(如果您使用`@impl`标记一个函数，您必须将该行为的所有其他回调标记为`@impl`)

`@impl`在上下文的基础上工作。如果您通过宏生成一个函数，并用`@impl`标记它，这不会影响生成该函数的模块。`@impl`还通过向其他开发人员明确表示该函数正在实现回调，有助于维护。

```elixir
# 定义`URI.Parser`的行为
defmodule URI.Parser do
    @doc "定义一个默认接口"
    @callback default_port() :: integer

    @doc "解析给定的URL"
    @callback parse(uri_info :: URI.t()) :: URI.t()

# 在模块中使用
defmodule URI.HTTP do
    @behaviour URI.Parser

    @impl true
    def default_port(), do: 80

    @impl true
    def parse(info), do: info
```

可以传递`true`,`false`,或者一个特定的行为给`@impl`

```elixir
defmodule Foo do
    @behaviour Bar
    @behaviour Baz

    # Bar或者Baz任意一个行为没有定义`bar/0`的回调时，会告警
    @impl true
    def bar(), do: :ok

    # Baz没有定义一个名为`baz/0`的回调时，会告警
    @impl Baz
    def baz(), do: :ok
end
```

代码现在更容易阅读，因为现在清楚哪些函数是API的一部分，哪些是回调实现。为了强化这一想法，`@impl true`会自动将函数标记为`@doc false`，除非`@doc`显式设置，否则将禁用文档。

### `@compile`

定义模块编译的选项,这用于配置Elixir和Erlang编译器，就像外部工具添加的任何其他编译器一样。`@compile`的多次使用将累积，而不是覆盖前一个。
```elixir
defmodule MyModule do
    @compile {:inline, my_fun: 1}

    def my_fun(arg) do
        to_string(arg)
    end
end
```

### `@deprecated`

提供弃用函数的理由,Mix编译器会自动查找弃用模块的调用，并在编译时发出警告。

使用`@deprecated`还会反应到相应函数或宏的文档中，可以在`@deprecated`属性或者在文档元数据中选择，可以提供`hard-deprecations`(带警告) 和 `soft-deprecations`（不带警告）

目前`@deprecated`只支持函数和宏，但是可以使用`:deprecated`在元数据中标注模块，类型和或回调的文档。

```elixir
# 使用模块属性，提供硬弃用
defmodule Keyword do
    @deprecated "Use Kernel.length/1 instead"
    def size(keyword) do
        length(keyword)
    end
end

# 使用文档元数据， 提供软弃用（不会提供报警）
@doc deprecated: "Use Kernel.length/1 instead"
def size(keyword)
```

### `@doc`和`@typedoc`

为属性后的实体提供文档。`@doc`用于函数，宏，回调或者宏回调，`@typedoc`用于类型（公共或者透明类型）

接受以下类型：

- 字符串
- `fasle`,会让该实体对文档导出工具不可见
- 关键字列表

```elixir
defmodule MyModule do
    @typedoc "This type"
    @typedoc since: "1.1.0"
    @type t :: term

    @doc "hello world"
    @doc since: "1.1.0"
    def hello do 
        "world"
    end

    @doc """
    Sums `a` to `b`
    """
    def sum(a, b) do
        a + b
    end
end
```

如示例所示，在实体之前可以多次使用这些属性。然而，如果与二进制文件一起使用两次，编译器将发出警告，因为它取代了之前使用的文档文本。关键字列表的多次使用会将列表合并为一个列表。

请注意，由于编译器还定义了一些额外的元数据，因此有一些保留keys在使用时将被忽略并发出警告。目前有`:opaque`和`:defaults`。

模块一旦编译完成，这些信息可以通过`Code.fetch_docs/1`函数获许。

### `@dialyzer`

定义要请求或抑制的警告, 接受原子，原子的列表和元组。
`@dialyzer`的多次使用将累积，而不是覆盖之前的。

```elixir
defmodule MyModule do
    @dialyzer {:nowarn_function, [my_fun: 1]}

    def my_fun(arg) do
        M.not_a_function(arg)
    end
end
```

### `@external_resource`

为当前模块指定外部资源。有时，模块会嵌入来自外部文件的信息。此属性允许模块注释已经使用的外部资源。工具可能会使用此信息来确保在任何外部资源发生变化的情况下重新编译模块。

提供的指定文件路径被解释为相对于包含项目mix.exs的文件夹，该文件夹是当前工作目录，而不是声明`@external_resource`的文件。

如果模块依赖的外部资源不存在，文件添加后，模块会立即重新编译。

### `@file`

更改模块属性后面的函数或宏的堆栈跟踪中使用的文件名

```elixir
defmodule MyModule do
    @doc "Hello world"
    @file "hello.ex"
    def hello do
        "world"
    end
end
```

请注意，这仅适用于来自定义内部范围（包括其模式和守卫）的异常/诊断。

如果您将第二个`unused`定义注释后运行此代码，将看到`hello.ex`在报告警告时用作堆栈跟踪，但如果您取消注释，您将看到错误不会提及`bye.ex`，因为它是模块级错误，而不是表达式级错误。

```elixir
defmodule MyModule do # <-- 模块定义
    @file "hello.ex"
    defp unused(a) do # <-- 函数定义
        "world" # <-- 函数作用域
    end

    @file "bye.ex"
    def unused(_), do: true
end
```

### `@moduledoc`

为当前模块提供文档
接受 字符串或者`false`，`@moduledoc false`会使得模块对文档导出工具不可见。与`@doc`类似，可以通过传递关键字列表提供元数据。模块一旦编译完成，可以通过`Code.fetch_docs/1`函数访问这些信息。

```elixir
defmodule MyModule do
    @moduledoc """
    A very useful module.
    """

    @moduledoc authors: ["Alice","Bob"]
end
```

### `@nifs`

函数和其参数数量的列表，将会被`NIF(native implementation)`重写。

```elixir
defmodule MyLibrary.MyModule do
    @nifs [foo: 1, bar: 2]

    def foo(arg1), do: :erlang.nif_error(:not_loaded)
    def bar(arg1, arg2), do: :erlang.nif_error(:not_loaded)
end
```
更多信息参考:[Erlang文档](https://www.erlang.org/doc/man/erl_nif)


### `@on_definition`

一个钩子，在当前模块定义任意函数或宏时会触发调用，注解函数时很有用。接受一个模块或者`{module, function_name}`元组，该函数必须使用以下6个参数。

- 模块环境
- 函数/宏的类型： `:def`,`:defp`,`:defmacro`,`:defmacrop`
- 函数/宏的名称
- quoted参数列表
- quoted守卫列表
- quoted函数体

如果被定义的函数/宏有多个字句，每个字句都会触发一次钩子。与其他钩子不同，`@on_definition`只会调用函数，永远不会调用宏。这是为了避免`@on_definition`回调重新定义刚刚定义的函数，以支持更明确的方法。当只提供一个模块时，该函数被假定为`__on_definition__/6`。

```elixir
defmodule Hooks do
    def on_def(_env, kind, name, args, guards, body) do
        IO.puts("Defining #{kind} named #{name} with args:")
        IO.inspect(args)
        IO.puts("and guards")
        IO.inspect(guards)
        IO.puts("and body")
        IO.puts(Macro.to_string(body))
  end
end

defmodule MyModule do 
    @on_definition {Hooks, :on_def}

    def hello(arg) when is_binary(arg) or is_list(arg) do
        "Hello" <> to_string(arg)
    end

    def hello(_) do
        :ok
    end
end
```

### `@on_load`

一个钩子，模块被加载时触发，接受当前模块的函数名，且该函数必须没有参数。如果该函数没有返回`:ok`,模块加载会被中止。

```elixir
defmodule MyModule do
    @on_load :load_check

    def load_check do
        if some_condition() do
            :ok
        else
            :abort
        end
    end

    def some_condition do
        false
    end
end
```

### `@vsn`

指定当前模块版本，接受任何合法的`Elixir`值

```elixir
defmodule MyModule do
    @vsn "1.0"
end
```

### 结构体属性

- `@derive`: 为当前模块中定义的结构提供推导出给定结构的实现。
- `@enforce_keys`: 当前模块定义的结构体实例化时确保所有给定key都被设值

### 类型系统的属性

下面是部分`Elixir`内置的类型系统使用的模块属性

- `@type`: 定义用在`@spec`的类型
- `@typep`: 定义用在`@spec`的私有类型
- `@opaque`: 定义用在`@spec`的透明类型
- `@spec`: 定义函数类型
- `@callback`: 定一个行为的回调的类型
- `@macrocallback`: 定义一个宏行为回调的类型
- `@optional_callback`: 定义一个可选回调的类型
- `@impl`: 声明他时一个函数或者宏的回调实现。

### 自定义属性

用户可以通过`@/1`自定义模块属性，赋给自定义模块属性的值必须是合法的Elixir值。

```elixir
defmodule MyModule do
    @custom_attr [some: "stuff"]
end
```

## 编译回调

有三个编译回调，调用顺序是：`@before_compile` -> `@after_compile` -> `@after_verify`

### `@before_compile`

一个钩子，会在模块编译前被调用。他通常用来改变当前模块如何被编译。接受一个模块或者`{module, function_or_macro_name}`元组，这个函数/宏必须接受一个参数：该模块环境。如果是一个宏，返回值会被注入到模块定义后，在编译开始前。

当只提供一个模块，则函数/宏被设定为`__before_compile__/1`。

回调会按照他们注册的顺序运行，在第一个回调运行之前，任何可被重写的定义都被具体话。在编译回调之前，一个定义可以在另一个定义中再次被覆盖，在所有回调运行后，它将最后一次具体化。

注意：回调函数/宏必须放置在一个单独的模块中（因为调用回调时，当前模块尚未存在）。

```elixir
defmodule A do
    defmacro __before_compile__(_env) do
        quote do
            def hello, do: "world"
        end
    end
end
 
defmodule B do
    @before_compile A
end

B.helo()
#=> "world"
```

### `@after_comiple`

一个钩子，在当前模块编译完后立即被执行。 接受一个模块或者`{module, function_name}`,这个函数必须带2个属性：模块环境和他的字节码。当提供一个模块，该方法被假设为`__after_compile__/2`

回调会按照他们注册的顺序执行。

`Module`函数
在调用`@after_compile`时，期望尚未编译的模块（如`definitions_in/1`）的模块函数仍然可用。

```elixir
defmodule MyModule do
    @after_compile __MODULE__

    def __after_compile__(env, _bytecode) do
        IO.inspect(env)
    end
end
```

### `@after_verify`

一个钩子，在当前模块的未定义函数和弃用检测之后立即被调用。一个模块始终在编译后进行验证，在Mix项目中，当模块的任何运行时依赖项发生变化时，也会对模块进行验证。因此，这对于执行当前模块的验证很有用，同时避免编译时依赖。鉴于回调是在不同场景下调用的，Elixir不保证何时在编译周期中，也不保证回调在哪个进程中运行。

可以接受一个模块或者`{module, function_name}`元组。该函数必须带有一个参数：模块名。当提供了一个模块，这个函数被假定为`__after_verify__/1`

回调会按照他们注册的顺序执行。

在调用`@after_verify`时，期望尚未编译模块的模块函数不再可用。

```elixir
defmodule MyModule do
    @after_verify __MODULE__

    def __after_verify__(module) do
        IO.inspect(module)
        :ok
    end
end
```

## 编译选项

`@compile`属性接受不同的选项用于`Elixir`和`Erlang`的编译器。下面是一些常用的例子

- `@compile: debug_info` 包含`:debug_info` ，与`Code.get_compiler_option/1`无关
- `@compile {:debug_info, false}` 关闭`:debug_info`，与`Code.get_compiler_option/1`无关。不建议关闭`:debug_info`，这会使得`elixir`编译器，其他用于静态分析代码的工具丧失能力，如果希望在部署时移除`:debug_info`，`mix release`已经默认帮我们做了这些
- `@compile {:inline, some_fun: 2, other_fun: 3}`内排给定的名称/arity对。内联在本地应用，来自另一个模块的调用不受此选项的影响
- `@compile {:autoload, false} `编译后禁用模块的自动加载。相反，模块将在发送后加载
- `@compile {:no_warn_undefined, Mod}`或者`@compile {:no_warn_undefined, {Mod, fun, arity}}`如果给定的模块或给定的`Mod.fun/arity`未定义，则不发出警告