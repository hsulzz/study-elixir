# 运行系统

**本章涵盖：**

- 使用 Elixir 工具运行系统 
- OTP 发布 
- 分析系统行为

你花了很多时间构建一个待办事项系统，现在是时候准备将其投入生产了。启动系统的方式有很多种，但基本思路始终相同。你需要编译你的代码以及其依赖项。然后，启动 BEAM 实例，确保所有编译的工件都在加载路径中。最后，在 BEAM 实例中，你需要启动你的 OTP 应用程序及其依赖项。一旦 OTP 应用程序启动，你就可以认为你的系统在运行了。

实现这一目标有多种方法，本章将重点介绍其中两种。首先，我们将探讨如何使用 Elixir 工具，特别是 mix，来启动系统。接下来，我们将讨论 OTP 发布。最后，我将结束本章和整本书，提供一些关于如何与运行中的系统进行交互的指导，以便你能够检测和分析在运行时不可避免地发生的故障和错误。

## 13.1 使用 Elixir 工具运行系统

无论您使用什么方法来启动系统，一些通用的原则始终适用。运行系统实际上包括以下几个步骤：

- 编译所有模块。对应的 .beam 文件必须存在于磁盘的某个地方（如第2.7节所述）。所有运行系统所需的 OTP 应用程序的应用资源（.app）文件也必须存在。

- 启动 BEAM 实例，并设置加载路径以包含第一步中的所有位置。

- 启动所有必需的 OTP 应用程序。

最简单的方法可能是依赖标准的 Elixir 工具。这样做非常简单，并且您已经熟悉 mix、iex 和 elixir 命令行工具的某些方面。到目前为止，您一直在使用 iex，它让您可以启动系统并与之交互。当您调用 `iex -S mix` 时，上述所有步骤都会被执行以启动系统。

在生产环境中，您可能希望作为后台进程启动系统，而不启动 iex shell。为此，您需要通过 mix 和 elixir 命令来启动系统。

### 13.1.1 使用mix和elixir命令

到目前为止，我们一直在使用 ⁠iex -S mix 命令来启动系统。也可以使用 ⁠mix run --no-halt 来启动系统。该命令启动 BEAM 实例，然后启动您的 OTP 应用程序及其依赖项。⁠--no-halt 选项指示 Mix 使 BEAM 实例无限期地运行。

```elixir
mix run --no-halt

Starting database worker.
Starting database worker.
Starting database worker.
Starting todo cache.
```

与 `iex -S mix` 相比，重要的区别在于 `mix run` 不会启动交互式 shell。一个稍微复杂一些的选项是使用 `elixir` 命令。

```elixir
$ elixir -S mix run --no-halt
 
Starting database worker.
Starting database worker.
Starting database worker.
Starting to-do cache.
```

这个方法需要多打一些字符，但它允许你在后台运行系统。

通过使用 -detached Erlang 标志，你可以以分离模式启动系统。操作系统进程将与终端分离，并且不会有控制台输出。启动分离系统时，将 BEAM 实例转变为节点也是很有用的，这样你可以在之后与它交互并在需要时终止它。

```elixir
$ elixir --erl "-detached" --sname todo_system@localhost -S mix run --no-halt
```
该命令会在后台启动BEAM实例。

您可以检查系统上运行的 BEAM 节点：

```shell
epmd -names
```

此时，您的系统正在运行，您可以使用它——例如，通过发出 HTTP 请求来操作待办事项列表。

您可以连接到正在运行的 BEAM 实例并与之交互。您可以建立一个远程 shell——类似于与正在运行的 BEAM 实例的终端 shell 会话。特别是，使用 --remsh 选项，您可以启动另一个节点，并将其用作 todo_system 节点的 shell：

```shell
iex --sname debugger@localhost  --remsh todo_system@localhost --hidden
```

在这个例子中，你启动调试器节点，但shell是在todo_system的上下文中运行的。你调用的任何功能都会在todo_system上被调用。这非常有用，因为你现在可以与正在运行的系统进行交互。BEAM提供了各种便捷的服务，使你能够查询系统和单个进程，稍后我们会详细讨论。

请注意，你以隐身的方式启动调试器节点。如第12章所述，这意味着调试器节点不会出现在todo_system的Node.list（或Node.list([:this, :visible]））的结果中，因此它不会被视为集群的一部分。

为了停止正在运行的系统，您可以使用 System.stop 函数（https://hexdocs.pm/elixir/System.xhtml#stop/1），它可以优雅地关闭系统。它会关闭所有正在运行的应用程序，然后终止 BEAM 实例。

```elixir
iex(todo_system@localhost)1> System.stop()
```

远程 shell 会话处于挂起状态，尝试运行其他命令将会导致错误。

```iex
iex(todo_system@localhost)2> 
*** ERROR: Shell process terminated! (^G to start new job) ***
```

在这个时候，你可以关闭终端并验证正在运行的 BEAM 节点：

```shell
epmd -names
```

如果你想通过编程方式停止一个节点，可以使用第12章中描述的分布式功能。这里有一个简单的示例：

```elixir
if Node.connect(:todo_system@localhost) == true do
  :rpc.call(:todo_system@localhost, System, :stop, [])
  IO.puts("Node terminated")
else
  IO.puts("Cant't connect to a remote node.")
end
```

在这里，你连接到远程节点，然后使用 `:rpc.call/4` 来调用 `System.stop`。你可以将代码存储在名为 `stop_node.exs` 的文件中（`.exs` 扩展名通常用于 Elixir 脚本）。然后，你可以从命令行运行这个脚本：

```shell
elixir --sname terminator@localhost stop_node.exs
```

运行脚本会启动一个独立的 BEAM 实例并在该实例中解释代码。在脚本代码执行完毕后，主机实例会被终止。由于脚本实例需要连接到一个远程节点（即你想终止的那个节点），因此你需要为它命名，以将 BEAM 实例转换为一个正常的节点。

### 13.1.2 执行脚本

我到目前为止还没有讨论脚本和工具，但它们值得简单提一下。有时，您可能想构建一个命令行工具，该工具进行一些处理，生成结果，然后停止。最简单的方法是编写一个脚本。

您可以创建一个普通的 Elixir 文件，给它一个 .exs 扩展名，以表明它是一个脚本，实现一个或多个模块，并调用一个函数。

```elixir
defmodule MyTool do
  def run do
    ...
  end

  ...
end

MyTool.run()
```

你可以通过命令 `elixir my_script.exs` 来调用这个脚本。你定义的所有模块将会在内存中编译，而任何不在模块中的表达式将会被解释。所有操作完成后，脚本将终止。当然，Elixir 脚本只能在安装了正确版本的 Erlang 和 Elixir 的系统上运行。

可以使用 `Mix.install` 来添加外部库（https://hexdocs.pm/mix/Mix.xhtml#install/2）。例如，以下脚本使用 Jason 库来解析作为命令行参数提供的 JSON 内容：

```elixir
Mix.install([{:jason, "~> 1.4"}])

input = hd(System.argv())
decoded = Jaosn.decode!(input)

IO.inspect(decoded)
```

传递给 Mix.install 的列表遵循与 mix.exs 中使用的依赖列表相同的格式。让我们试一下。将上面的代码保存到名为 json_decode.exs 的文件中。然后，执行脚本：

```shell
“$ elixir json_decode.exs '{"some_key": 42}'
 
Resolving Hex dependencies...    
Resolution completed in 0.011s 
New:                             
  jason 1.4.0                    
* Getting jason (Hex package)    
==> jason                        
Compiling 10 files (.ex)         
Generated jason app              
 
%{"some_key" => 42}              
```

当脚本第一次执行时，Mix 会安装依赖项，编译它，并将结果缓存到磁盘中。后续的执行将使用缓存的版本，因此脚本的运行速度会比第一次运行快得多。

对于更简单的工具，使用 .exs 脚本是可以的，但当代码变得更加复杂时，这种方式效率不高。在这种情况下，最好使用一个完整的 Mix 项目并构建一个完整的 OTP 应用程序。

但是因为你不是在构建一个持续运行的系统，所以你还需要在项目中包含一个执行模块——一个进行处理并产生输出的模块。

```elixir
defmodule MyTool.Runner do
  def run do
    ...
  end
end
```

然后，您可以使用 `mix run -e MyTool.Runner.run` 来启动该工具。这将启动 OTP 应用程序，调用 `MyTool.Runner.run/0` 函数，并在函数完成后立即终止。

您还可以将整个工具打包成一个 escript——一个包含所有 .beam 文件、Elixir .beam 文件和启动代码的单个二进制文件。因此，escript 文件是一个完全编译的、跨平台的脚本，只需要在运行机器上存在 Erlang。有关更多细节，请参阅 mix escript.build 文档（https://hexdocs.pm/mix/Mix.Tasks.Escript.Build.xhtml）。

一个相似但功能更有限的选项是 Erlang 存档，这是一个包含已编译二进制文件的 zip 文件。与 escript 相比，存档的主要优点是可以使用 `mix archive.install` 任务全局安装（https://hexdocs.pm/mix/Mix.Tasks.Archive.Install.xhtml）。这使得它们非常适合分发系统范围内的 Mix 任务。一个流行的例子是 `phx.new` 任务，用于生成一个使用 Phoenix 网络框架的新项目。您可以在 https://hexdocs.pm/mix/Mix.Tasks.Archive.Build.xhtml 阅读更多关于构建存档的信息。

### 13.1.3 编译生产系统

在第11章中提到过，有一个构造叫做 Mix 环境——这是一个编译时标识符，允许你有条件地定义代码。默认的 Mix 环境是 dev，表示你正在处理开发环境。相比之下，当你使用 mix test 运行测试时，代码是在测试环境中编译的。

你可以利用 Mix 环境有条件地包含代码，以方便开发或测试。例如，你可以依赖 Mix.env/0 函数来定义不同版本的函数。以下是一个简单的示例：

```elixir
defmodule Tido.Database do
  case Mix.env do
    :dev ->
      def get(id), do: ...
    :test ->
      def get(id), do: ...
    _ ->
      def get(id), do: ...

  end
end
```

请注意，您在模块级别上依赖 `Mix.env/0` 的结果进行分支，这是在任何函数之外的。这是一个编译时构造，这段代码在编译期间运行。`store/2` 的最终定义将取决于您用来编译代码的 Mix 环境。在开发环境中，您可能会运行额外的日志记录和基准测试，而在测试环境中，您可能会使用内存存储，例如 ETS。

重要的是要理解，`Mix.env/0` 仅在编译期间有意义。您不应在运行时依赖它。在任何情况下，您的代码可能包含这样的条件定义，因此您应该假设在开发环境中编译时，您的项目没有完全优化。

要在生产中启动系统，您可以将 `MIX_ENV` 环境变量设置为相应的值：

```shell
$ MIX_ENV=prod elixir -S mix run --no-halt
```

## 13.2 OTP发布

OTP发布是一个独立的、编译的、可运行的系统，它包含系统所需的最小OTP应用集。OTP发布可以选择性地包含最小的Erlang运行时二进制文件，这使得发布完全自给自足。发布不包含源代码、文档文件或测试等工件。

这种方法带来各种好处。首先，您可以在开发机器或构建服务器上构建系统，并仅仅发布二进制工件。主机机器不需要安装任何工具。如果将最小的Erlang运行时嵌入到发布中，您甚至不需要在生产服务器上安装Elixir和Erlang。运行系统所需的所有内容都将成为发布包的一部分。此外，发布简化了一些操作任务，例如连接到运行的系统并在系统上下文中执行自定义的Elixir代码。最后，发布为系统的系统在线升级（和降级）铺平了道路，这在Erlang中称为发布处理。

### 13.2.1 构建发布

要构建一个发布版本，您需要编译您的主 OTP 应用及其所有依赖项。然后，您需要将所有二进制文件与 Erlang 运行时一起包含在发布中。这可以通过 mix release 命令完成（https://hexdocs.pm/mix/Mix.Tasks.Release.xhtml）。

让我们来看一下实际操作。进入到待办事项文件夹，然后运行发布命令：

```shell
mix release

* assembling todo-0.1.0 on MIX_ENV=dev
* using config/runtime.exs to configure the release at runtime
 
Release created at _build/dev/rel/todo
 
...
```

这将在开发 Mix 环境中构建发布版本。由于发布版本通常是在生产环境中运行，因此通常希望在生产环境中构建它。你可以通过在命令前添加 MIX_ENV=prod 来实现。此外，你还可以在 mix.exs 中强制设置发布任务的默认环境。

```elixir
# Listing 13.1 Enforcing the prod environment for the release task(todo_release/mix.exs)

defmodule Todo.MixProject do
  ...

  def cli do
    [
      preferred_envs: [release: :prod]
    ]
  end

  ...
end
```

cli 函数可用于为不同的 Mix 任务配置默认的 Mix 环境。该函数必须返回一个关键字列表，其中包含支持的选项。`:preferred_envs` 选项是一个关键字列表，其中每个键是任务名称（作为原子提供），值是该任务所需的默认环境。

在这个更改生效后，你可以调用 mix release，这将编译你的项目在生产环境中并生成发布版本：

```shell
$ mix release
 
* assembling todo-0.1.0 on MIX_ENV=prod
...
```

`mix release`执行完后，发布文件将位于 _build/prod/rel/todo/ 子文件夹中。我们稍后会讨论发布的内容，但首先，让我们来看看如何使用它。

### 13.2.2 使用发布

要与发布版本交互的主要工具是位于 _build/prod/rel/todo/bin/todo 的 shell 脚本。你可以使用它执行各种任务，例如：

- 在前台启动系统和 iex shell。

- 将系统作为后台进程启动。

- 停止正在运行的系统。

- 将远程 shell 附加到运行中的系统。

验证发布版本是否正常工作的最简单方法是将系统与 iex shell 一起在前台启动：

```elixir
$ RELEASE_NODE="todo@localhost" _build/prod/rel/todo/bin/todo start_iex
 
Starting database worker.
Starting database worker.
Starting database worker.
Starting to-do cache.
 
iex(todo@localhost)1>
```

在这里，RELEASE_NODE 操作系统环境变量被设置为所需的节点名称。如果没有这个变量，Elixir 将根据主机名选择一个默认值。为了使示例能够在不同的机器上运行，选择了将 localhost 用作主机部分的硬编码值。请注意，这是一个短节点名称。如果您想使用长名称，您还需要将 RELEASE_DISTRIBUTION 操作系统环境变量设置为值名称。有关如何配置发布的更多详细信息，请参阅 mix release 文档。

发布不再依赖于您系统的 Erlang 和 Elixir。它是完全独立的；您可以将 _build/prod/rel/todo 子文件夹的内容复制到另一台未安装 Elixir 和 Erlang 的机器上，它仍然可以运行。当然，因为发布包含 Erlang 运行时二进制文件，所以目标机器必须由相同的操作系统和架构提供支持。

要将系统作为后台进程启动，您可以使用 daemon 命令：

```shell
$ RELEASE_NODE="todo@localhost" _build/prod/rel/todo/bin/todo daemon
``` 

这与之前提到的分离进程不同。相反，系统是通过 run_erl 工具启动的 (https://erlang.org/doc/man/run_erl.xhtml)。该工具将标准输出重定向到位于 _build/prod/rel/todo/tmp/log 文件夹中的日志文件，这样可以分析系统的控制台输出。

一旦系统在后台运行，您可以启动到节点的远程 shell：

```elixir
$ RELEASE_NODE="todo@localhost" _build/prod/rel/todo/bin/todo remote
 
iex(todo@localhost)1>
```

在这一点上，您在生产节点的上下文中运行了一个 iex shell 会话。按两次 Ctrl-C 退出 shell 会停止远程 shell，但 todo 节点仍将保持运行。如果系统作为后台进程运行，并且您想要停止它，可以使用 stop 命令：

```shell
$ RELEASE_NODE="todo@localhost" _build/prod/rel/todo/bin/todo stop
```

也可以直接附加到正在运行的进程的 shell。附加提供了一个重要的好处：它捕获了运行节点的标准输出。运行节点打印的内容（例如，通过 IO.puts）都可以在附加的进程中看到（而远程 shell 则不是这样）。

让我们看看实际效果。首先，我们将启动后台的发布，同时运行 iex。这可以通过 daemon_iex 命令来完成。

```shell    
$ RELEASE_NODE="todo@localhost" _build/prod/rel/todo/bin/todo daemon_iex
```

现在，我们可以使用 to_erl 工具附加到 shell 上:

```shell
$ _build/prod/rel/todo/erts-13.0/bin/to_erl _build/prod/rel/todo/tmp/pipe/


iex(todo@localhost)1>
 
[memory_usage: 70117728, process_count: 230] 
```

在第十章中，你添加了一个定期打印内存使用情况和进程计数到标准输出的任务。当你连接到这个 shell 时，可以看到这个任务的输出。相反，在运行远程 shell 时，你将看不到这个输出。

连接到 shell 时要小心。与远程 shell 不同，连接的 shell 在运行节点的上下文中运行。你只是通过操作系统管道连接到运行节点。因此，你一次只能有一个连接会话。此外，你可能会在按下 Ctrl-\ 时意外停止运行节点。你应该按 Ctrl-D 从运行节点分离，而不停止它。

todo脚本可以执行多种其他命令。要获取帮助，只需在没有任何参数的情况下调用_build/prod/rel/todo/bin/todo。这将把帮助信息输出到标准输出。最后，关于如何构建发布的更多细节，请查看官方的Mix文档，地址是 https://hexdocs.pm/mix/Mix.Tasks.Release.xhtml。

### 13.2.3 发布内容

让我们花些时间讨论您发布的结构。一个完全独立的发布包含以下内容：

- 运行您的系统所需的编译OTP应用程序

- 一个包含将传递给虚拟机的参数的文件

- 一个引导脚本，描述需要启动的OTP应用程序

- 一个包含OTP应用程序环境变量的配置文件

- 一个帮助脚本，用于启动、停止和与系统交互

- Erlang运行时二进制文件

在这种情况下，所有这些内容都位于 _build/prod/rel/todo 文件夹中的某个位置。让我们仔细查看发布的一些重要部分。

**编译好的二进制文件**

所有必要应用程序的编译版本位于 _build/prod/rel/todo/lib 文件夹中：

```shell
$ ls -1 _build/prod/rel/todo/lib
 
asn1-5.1
compiler-8.3
cowboy-2.10.0
cowboy_telemetry-0.4.0
cowlib-2.12.1
crypto-5.2
eex-1.15.0
elixir-1.15.0
iex-1.15.0
kernel-9.0
logger-1.15.0
mime-2.0.3
plug-1.14.2
plug_cowboy-2.6.1
plug_crypto-1.2.5
poolboy-1.5.2
public_key-1.14
ranch-1.8.0
runtime_tools-2.0
sasl-4.2.1
ssl-11.0
stdlib-5.0
telemetry-1.2.1
todo-0.1.0
```
这个列表包含了你所有的运行时依赖，包括直接依赖（在 mix.exs 中指定）和间接依赖（依赖的依赖）。此外，一些 OTP 应用程序，如 kernel、stdlib 和 elixir，会自动包含在发布版中。这些是任何基于 Elixir 的系统所需的核心 OTP 应用程序。最后，iex 应用程序也被包含在内，这使得可以运行远程的 iex shell。

在每个这些文件夹中，有一个 ebin 子文件夹，其中包含编译后的二进制文件和 .app 文件。每个 OTP 应用程序文件夹还可能包含 priv 文件夹，里面有额外的特定于应用程序的文件。

小贴士：如果需要在发布版中包含额外的文件，最好在你的项目根目录下创建一个 priv 文件夹。此文件夹如果存在，自动会出现在发布版中的应用程序文件夹下。当你需要访问 priv 文件夹中的文件时，可以调用 Application.app_dir(:an_app_name, "priv") 来找到该文件夹的绝对路径。

将所有必需的 OTP 应用程序捆绑在一起，使得发布版是独立的。由于系统包含所有必需的二进制文件（包括 Elixir 和 Erlang 标准库），在目标主机上不需要其他任何东西。

你可以通过查看加载路径来证明这一点：

```shell
“RELEASE_NODE="todo@localhost" _build/prod/rel/todo/bin/todo start_iex
 
iex(todo@localhost)1> :code.get_path()        
 
[~c"ch13/todo_release/_build/prod/rel/todo/lib/../releases/0.1.0/consolidated",
 ~c"ch13/todo_release/_build/prod/rel/todo/lib/kernel-9.0/ebin",
 ~c"ch13/todo_release/_build/prod/rel/todo/lib/stdlib-5.0/ebin",
 ~c"ch13/todo_release/_build/prod/rel/todo/lib/compiler-8.3/ebin",
 ~c"ch13/todo_release/_build/prod/rel/todo/lib/elixir-1.15.0/ebin",
 ~c"ch13/todo_release/_build/prod/rel/todo/lib/sasl-4.2.1/ebin",
 ~c"ch13/todo_release/_build/prod/rel/todo/lib/logger-1.15.0/ebin",
 ~c"ch13/todo_release/_build/prod/rel/todo/lib/crypto-5.2/ebin",
 ~c"ch13/todo_release/_build/prod/rel/todo/lib/cowlib-2.12.1/ebin",
 ~c"ch13/todo_release/_build/prod/rel/todo/lib/asn1-5.1/ebin",
 ~c"ch13/todo_release/_build/prod/rel/todo/lib/public_key-1.14/ebin",
 ~c"ch13/todo_release/_build/prod/rel/todo/lib/ssl-11.0/ebin",
 ~c"ch13/todo_release/_build/prod/rel/todo/lib/ranch-1.8.0/ebin",
 ~c"ch13/todo_release/_build/prod/rel/todo/lib/cowboy-2.10.0/ebin",
 ~c"ch13/todo_release/_build/prod/rel/todo/lib/telemetry-1.2.1/ebin",
 ~c"ch13/todo_release/_build/prod/rel/todo/lib/cowboy_telemetry-0.4.0/ebin",
 ~c"ch13/todo_release/_build/prod/rel/todo/lib[…]

 ```

请注意，所有的加载路径都指向发布文件夹。相比之下，当你启动一个普通的 `iex -S mix` shell 并运行 `:code.get_path/0` 时，你会看到一个更长的加载路径列表，其中一些指向构建文件夹，其他则指向系统的 Elixir 和 Erlang 安装路径。这应该让你相信你的发布是独立的。运行时只会在发布文件夹中查找模块。

此外，最小的 Erlang 二进制文件已包含在发布中。它们位于 `_build/prod/rel/todo/erts-X.Y`，其中 X.Y 对应于运行时版本号（这与 Erlang 版本号无关）。Erlang 运行时的包含使得发布完全独立。此外，它允许你在同一台机器上运行多个由不同 Elixir 或 Erlang 版本驱动的系统。

**配置**

配置文件位于 _build/prod/rel/todo/releases/0.1.0 文件夹中，其中 0.1.0 对应于您的待办应用程序的版本（在 mix.exs 中提供）。该文件夹中最相关的两个文件是 vm.args 和 env.sh。

vm.args 文件可用于向 Erlang 运行时提供标志，例如 +P 标志，它设置可运行进程的最大数量。env.sh 文件可用于设置环境变量，例如前面提到的 RELEASE_NODE 和 RELEASE_DISTRIBUTION。有关如何自定义这些文件的更多细节，请参见 https://hexdocs.pm/mix/Mix.Tasks.Release.xhtml#module-vm-args-and-env-sh-env-bat。

### 13.2.4 在Docker容器中打包


有多种方式可以在生产环境中运行系统。你可以将其部署到平台即服务（PaaS），例如 Heroku、Fly.io 或 Gigalixir，或者在 Kubernetes 集群中运行它。还有一种选择是通过服务管理器（如 systemd）将系统作为服务运行。

无论你选择哪种部署策略，都应该努力将系统作为 OTP 版本运行。在大多数情况下，这意味着在前台启动版本。因此，有效的启动命令是 start_iex 或 start。

前一个命令还会启动 iex 会话。这允许你连接到运行的 BEAM 节点的 iex shell，并与生产系统进行交互，同时捕获节点的标准输出。另一方面，这种方法有风险，因为你可能会意外地终止节点（通过按两次 Ctrl-C）。

相比之下，start 命令将在前台启动系统，但没有 iex 会话。因此，你将无法附加到主 iex shell。你仍然可以通过建立远程 iex shell 会话与正在运行的系统进行交互，但在这种情况下，节点的标准输出不会被捕获。

具体的部署步骤取决于所选择的策略。选项太多，无法一一覆盖。对一些流行选择的良好基础介绍可以在 Phoenix 网框架的部署指南中找到（https://hexdocs.pm/phoenix/deployment.xhtml）。

作为一个小示例，让我们看看如何在 Docker 容器中运行待办事项系统。Docker 是许多团队选择的流行选项，因为它有助于自动化部署，支持在本地运行类似生产的版本，并为各种部署选项开辟了道路，尤其是在云环境中。本部分假设你对 Docker 有一定的了解。如果情况并非如此，你可以查看官方的入门指南，网址是 https://docs.docker.com/get-started/。

Elixir 项目的 Docker 镜像通常分为两个阶段进行构建。在第一阶段，通常称为 build，你需要编译代码并组装 OTP 发行版。然后，在第二阶段，你将发行版复制到最终镜像，该镜像将部署到目标主机。最终镜像不包含构建工具，例如 Erlang 和 Elixir。因为 OTP 发行版本身包含所需的最小 Erlang 和 Elixir 二进制文件，因此这些工具并不需要。

要构建 Docker 镜像，我们需要在项目根目录中创建一个名为 Dockerfile 的文件。以下列表展示了第一个构建阶段，该阶段生成 OTP 发行版。

```dockerfile
ARG ELIXIR_VERSION="1.1.5.4"
ARG ERLANG="26.0.2"
ARG DEBIAN="bookworm-20230612-slim"
ARG OS="debian-${DEBIAN}"

FROM "hexpm/elixir:${ELIXIR_VERSION}-erlang-${ERLANG}-${OS}" as builder

WORKDIR /todo

ENV MIX_ENV="prod"

RUN mix local.hex --force && \  
    mix local.rebar --force

COPY mix.exs mix.lock ./
COPY config config
COPY lib lib

RUN mix deps.get --only prod

RUN mix release

```

这个例子中使用的基础 Docker 镜像由 Hex 包管理器团队维护 (https://hub.docker.com/r/hexpm/elixir)。

值得注意的是，为了简洁起见，这个 Docker 文件有些过于简单，因为它没有利用 Docker 层缓存。因此，任何源文件的更改都将需要重新编译整个项目，包括所有的依赖项。要了解更精细的构建镜像方式，可以查看 Phoenix Web 框架生成的 Dockerfile (https://hexdocs.pm/phoenix/releases.xhtml#containers)。

接下来，让我们开始构建最终镜像。

```dockerfile
# Listing 13.3 Building the final image (todo_release/Dockerfile)
ARG DEBIAN="bookworm-20230612-slim"
 
...
 
FROM debian:${DEBIAN}                    
 
WORKDIR "/todo"
 
RUN apt-get update -y && apt-get install -y openssl locales
 
COPY \                                   
  --from=builder \                       
  --chown=nobody:root \                  
  /todo/_build/prod/rel/todo ./          
 
RUN sed -i '/en_US.UTF-8/s/^# //g' /etc/locale.gen && locale-gen
ENV LANG="en_US.UTF-8"
ENV LANGUAGE="en_US:en"
ENV LC_ALL="en_US.UTF-8"
 
CMD ["/todo/bin/todo", "start_iex"]      
```

首先要注意的是，基础镜像是 Debian，而不是 Elixir 或 Erlang。使用与构建镜像相同的基础操作系统非常重要。否则，您可能会因为不兼容而遇到崩溃。

要构建最终镜像，您需要从构建阶段复制 OTP 发布版本，配置区域设置，并定义默认启动命令。在这个例子中，选择了 start_iex 命令，这使得能够附加到正在运行的 shell。

此时，您可以构建镜像：

```shell
docker build . -t elixir-in-action/todo
```

现在可以启动容器：

```shell
docker run        \
  --rm -it        \
  --name todo     \
  -p 5454:5454    \
  elixir-in-action/todo
```

现在可以在本地与系统交互：

```shell
curl -d "" \
  "http://localhost:5454/add_entry?list=bob&date=2023-12-19&title=Movies"

OK
```

像构建阶段一样，生产镜像过于简单。特别是，它不支持通过分布式Erlang进行集群，也不支持通过--remsh开关建立远程shell。虽然可以通过一些工作解决这个问题，但为了简洁起见，这里不再讨论。如果你想从多个容器建立Erlang集群，特别是它们在Kubernetes集群中运行的情况下，可以查看libcluster库（https://hexdocs.pm/libcluster/）。

这就结束了关于发布的话题。一旦你的系统启动并运行起来，了解如何分析其行为是非常有用的。

## 13.3 分析系统行为

即使系统已经构建并投入生产，你的工作也并未结束。事情偶尔会出现问题，你会遇到错误。代码也可能没有经过适当优化，可能会消耗过多资源。如果你能够正确实施容错系统，它可能会自动恢复并应对错误和增加的负载。不过，你仍然需要彻底查明任何问题并进行修复。

鉴于你的系统是高度并发和分布式的，发现和理解出现的问题可能并不明显。对此主题的适当处理很容易成为一本单独的书——而且已经有一本出色的免费书籍，名为《糟糕的事情：愤怒中的Erlang》（Stuff Goes Bad: Erlang in Anger），作者是 Fred Hébert（https://www.erlang-in-anger.com/）。 本章提供了一些分析复杂 BEAM 系统的标准技术的基本介绍，但如果你计划在生产环境中运行 Elixir 或 Erlang 代码，你应该在某个时刻更详细地研究这个主题，而《糟糕的事情》是一个很好的起点。


### 13.3.1 Debugging

虽然严格来说它与运行系统没有直接关系，但调试还是值得简要提及。你可能会惊讶地发现，标准的逐步调试并不是在 Erlang 中经常采用的方法（Erlang 配有基于 GUI 的调试器；参见 https://www.erlang.org/doc/apps/debugger/debugger_chapter.xhtml）。这是因为在高度并发的系统中，很多事情是同时发生的，因此无法进行经典的调试。想象一下，你在一个进程中设置了一个断点。当遇到该断点时，其他进程应该怎么做？它们应该继续运行，还是也应该暂停？当你步过一行代码时，所有其他进程是否都会向前迈出一步？超时应该如何处理？如果你在调试一个分布式系统，又会发生什么？正如你所看到的，由于基于 BEAM 的系统高度并发和分布式的特性，经典调试存在许多问题。

与其依赖调试器，不如采用更适合的策略。理解高度并发系统的关键在于日志记录和追踪。一旦出现问题，你会希望拥有尽可能多的信息，以便找出原因。

好消息是，有些日志记录功能是开箱即用的，通过 Elixir 的 logger 应用程序提供（https://hexdocs.pm/logger/Logger.xhtml）。特别地，任何符合 OTP 标准的进程崩溃时（例如，GenServer），都会打印错误信息和堆栈跟踪。堆栈跟踪还包含文件和行号信息，因此这应作为调查错误的良好起点。

有时，从堆栈跟踪中无法显而易见地找出失败原因，你需要更多数据。在开发时，用于此目的的简单辅助工具是 IO.inspect。请记住，IO.inspect 接收一个表达式，打印其结果并返回它。这意味着你可以在代码的任何部分用 IO.inspect 包裹，而不会影响程序的“行为。这是一个简单的技术，可以帮助你快速确定问题的原因，当一段新代码出现问题时，我经常使用它。将 IO.inspect 放在代码中查看值如何传播到出错的位置，通常能帮助我发现错误。一旦我修复了问题，就会删除 IO.inspect 的调用。

使用 dbg 宏（https://hexdocs.pm/elixir/Kernel.xhtml#dbg/2），你可以获得更丰富的体验。与 IO.inspect 类似，该宏生成返回其输入参数的代码。因此，只要不绑定任何变量，任何表达式都可以安全地包装在 dbg 中。dbg 宏打印更详细的信息，比如管道链的中间结果。

另一个有用的功能是 pry，它允许你在 iex shell 中暂时停止执行并检查系统的状态，比如作用域内的变量。有关详细说明，请参见 IEx.pry/0 文档（https://hexdocs.pm/iex/IEx.xhtml#pry/0）。官方 Elixir 网站上也提供了典型调试技术的概述，地址是 https://elixir-lang.org/getting-started/debugging.xhtml。

不言而喻，自动化测试可以提供重要的帮助。在隔离中测试各个部分，可以帮助你快速发现和修复错误。

还值得提到几种有用的基准测试和分析工具。最简单的工具形式为 :timer.tc/1 函数（https://erlang.org/doc/man/timer.xhtml#tc-1），它接收一个 lambda 函数，运行它，并返回其结果以及运行时间（以微秒为单位）。此外，Erlang/OTP 附带了几个分析工具：cprof、eprof 和 fprof。Elixir 包含用于运行这些工具的 mix 任务：

- mix profile.cprof (https://hexdocs.pm/mix/Mix.Tasks.Profile.Cprof.xhtml)

- mix profile.eprof (https://hexdocs.pm/mix/Mix.Tasks.Profile.Eprof.xhtml)

- mix profile.fprof (https://hexdocs.pm/mix/Mix.Tasks.Profile.Fprof.xhtml)

最后，还有各种基准测试库可用，如 Benchee（https://hexdocs.pm/benchee）。我不会详细解释这些，所以当你决定进行分析时，最好开始阅读官方文档以及 Erlang 文档，网址是 https://www.erlang.org/doc/efficiency_guide/profiling.xhtml。


### 13.3.2 Logging

一旦你进入生产环境，就不应该再依赖 `IO.inspect` 或 `dbg` 调用。相反，记录各种可能帮助你了解出错原因的信息会更好。为此，你可以依赖 Elixir 的 logger 应用程序。当你生成你的 Mix 项目时，这个依赖会被自动包含，并且鼓励你使用 logger 来记录各种事件。如前所述，logger 会自动捕获各种 BEAM 报告，比如发生在进程中的崩溃错误。

默认情况下，日志信息会发送到控制台。如果你以发布版本启动系统，标准输出将被转发到发布根文件夹下的日志文件夹，你可以在以后的时间里找到并分析这些错误。

当然，你可以编写自定义的 logger 处理程序，例如一个写入 syslog 或将日志报告发送到不同机器的处理程序。有关更多细节，请参阅 logger 文档（https://hexdocs.pm/logger/Logger.xhtml）。logger 应用程序主要是对 Erlang 的 `:logger` 模块的封装，因此研究 Erlang 的日志指南（https://www.erlang.org/doc/apps/kernel/logger_chapter.xhtml）也是值得的。

### 13.3.3 与系统交互

埃尔朗运行时的一个显著好处是，您可以连接到正在运行的节点，并以各种方式与之交互。您可以向进程发送消息，并停止或重启不同的进程（包括监控者）或 OTP 应用程序。甚至可以强制虚拟机重新加载模块的代码。

除此之外，各种内置函数允许您收集系统和单个进程的数据。例如，您可以启动一个远程 shell，并使用像 :erlang.system_info/1 和 :erlang.memory/0 这样的函数来获取有关运行时的信息。

您还可以使用 Process.list/0 获取所有进程的列表，然后使用 Process.info/1 查询每个进程的详细信息，该函数返回的信息包括内存使用情况和进程已执行的总指令数（在埃尔朗中称为 reductions）。这些服务为可以连接到运行系统的工具提供了可能，使其在图形用户界面中展示 BEAM 系统信息。

一个例子是观察者应用程序，您在第11章中已经见过。由于是基于图形用户界面的，观察者只有在主机操作系统中存在窗口系统时才能运行。在生产服务器上，通常情况下并没有这样的环境。但您可以在本地启动观察者，并让它从远程节点收集数据。

让我们看看实际操作。您将以后台服务的方式启动您的系统，然后在另一节点上运行观察者应用程序。观察者应用程序将连接到远程节点，收集数据并在图形界面中展示。

生产系统不需要运行观察者应用程序，但它需要包含为远程观察者应用程序收集数据的模块。这些模块是您需要在发布中包含的 runtime_tools 应用程序的一部分。您可以通过 mix.exs 中的 :extra_applications 选项轻松做到这一点。

```elixir
# Listing 13.4 Including runtime_tools in a release (todo_release/mix.exs)
defmodule Todo.MixProject do
  ...

  def application do
    [
      extra_applications: [:runtime_tools, :logger],
      ...
    ]
  end

  ...
end
```

:extra_applications 选项指定了您依赖的 Elixir 和 Erlang 的股票 OTP 应用程序。默认情况下，当您使用 mix 工具生成新项目时，Elixir 的 :logger OTP 应用程序会作为依赖项包含在内。

注意，:extra_applications 与 mix.exs 文件中的 deps 函数的作用不同。通过 deps，您列出必须获取和编译的第三方依赖项。相反，通过 :extra_applications，您列出的是已经在磁盘上编译的 Elixir 和 Erlang 股票应用程序，它们是 Erlang 和 Elixir 安装的一部分。这些依赖项的代码不需要获取，也不需要编译。但您仍然需要列出这些依赖项，以确保应用程序被包含在 OTP 释放中。

通过此更改，runtime_tools 被包含在您的 OTP 释放中，现在，您可以远程观察生产系统。让我们看看如何操作。首先，您需要在后台启动待办事项系统：

```elixir
RELEASE_NODE="todo@localhost" \
 RELEASE_COOKIE="todo" \
  _build/prod/rel/todo/bin/todo daemon
```

请注意，RELEASE_COOKIE 操作系统环境变量被设置为配置秘密节点 cookie。现在，作为命名节点启动交互式 shell，然后启动观察者应用程序。

```shell
$ iex --hidden --sname observer@localhost --cookie todo

iex(observer@localhost)1> :observer.start()
```


请注意，您明确地将节点的 cookie 设置为与运行系统中使用的 cookie 匹配。此外，与第 13.1.1 节中的早期 remsh 示例一样，您将节点作为隐藏节点启动。一旦观察者启动，您需要从菜单中选择 Nodes > todo@localhost。此时，观察者正在显示生产节点的数据。

值得一提的是，观察者和 runtime_tools 是用普通 Erlang 编写的，并依靠较低级别的函数来收集数据并以各种方式呈现。因此，您可以使用其他类型的前端，甚至自己编写一个。一个例子是 observer_cli (https://github.com/zhongwencool/observer_cli)，这是一个具有文本界面的类似观察者的前端，可以通过命令行界面使用。

### 13.3.4 Tracing

可以开启与进程和函数调用相关的跟踪，依赖于:sys（https://www.erlang.org/doc/man/sys.xhtml）和:dbg（https://www.erlang.org/doc/man/dbg.xhtml）模块的服务。:sys模块允许你跟踪符合OTP规范的进程（例如，GenServer）。跟踪会在标准输出上进行，因此你需要连接到系统（而不是建立远程shell）。然后，你可以借助:sys.trace/2为特定进程开启跟踪。

让我们看看实际操作。确保节点没有运行，然后在后台启动它，使用iex。

```elixir
$ TODO_SERVER_EXPIRY=600 \
  RELEASE_NODE="todo@localhost" \
  RELEASE_COOKIE="todo" \
  _build/prod/rel/todo/bin/todo daemon_iex
```

为了演示的目的，待办事项服务器的过期时间增加到10分钟。现在，您可以附加到正在运行的节点并跟踪该过程：

```shell
$ _build/prod/rel/todo/erts-13.0/bin/to_erl _build/prod/rel/todo/tmp/pipe/
 
iex(todo@localhost)1> :sys.trace(Todo.Cache.server_process("bob"), true)
```

这将开启控制台跟踪。有关进程相关事件的信息，比如接收到的请求，将被打印到标准输出。

现在，发出一个HTTP请求以获取Bob的列表：

```shell
$ curl "http://localhost:5454/entries?list=bob&date=2023-12-19"
```

在附加的终端中，你应该看到类似这样的内容：

```shell
*DBG* {todo_server,<<"bob">>} got call {entries,
  #{'__struct__' => 'Elixir.Date', calendar => 'Elixir.Calendar.ISO',
    day => 19,month => 12, year => 2023}} from <0.983.0>}
 
*DBG* {todo_server,<<"bob">>} sent [] to <0.322.0>,
  new state {<<"bob">>, #{'__struct__' => 'Elixir.Todo.List',
    next_id => 1, entries => #{}}}
```

输出可能看起来有点晦涩，但如果你仔细观察，你会看到两个跟踪条目：一个是接收到的呼叫请求，另一个是你发送的响应。你还可以看到服务器进程的完整状态。请记住，所有术语都是用Erlang语法打印的。

跟踪是一个强大的工具，因为它允许你分析正在运行系统的行为。但要小心，因为过多的跟踪可能会影响系统的性能。如果你正在跟踪的服务器进程负载很重或状态巨大，BEAM会花费大量时间进行跟踪I/O，这可能会减慢整个系统的速度。

无论如何，一旦你对进程有了一些了解，你应该停止跟踪它。

```shell
iex(todo@localhost)1> :sys.trace(Todo.Cache.server_process("bob"), false)
```

其他来自`:sys`的有用服务允许您获取OTP进程状态（`:sys.get_state/1`）甚至更改它（`:sys.replace_state/2`）。这些函数旨在仅用于调试或“黑客式”的手动修复——您不应该在代码中调用它们。

另一个有用的跟踪工具是`:erlang.trace/3`函数（https://www.erlang.org/doc/man/erlang.xhtml#trace-3），它允许您订阅系统中的事件，例如消息传递或函数调用。

此外，一个名为`:dbg`的模块（https://www.erlang.org/doc/man/dbg.xhtml）简化了跟踪。您可以直接在附加的控制台上运行`:dbg`，也可以启动另一个节点并让它跟踪主系统。在下一个示例中，您将采用这种方法。

假设待办节点仍在运行，请启动另一个节点：

```shell
iex --sname tracer@localhost --cookie todo --hidden
```

现在，在跟踪节点上开始跟踪主待办节点，然后指定您对来自 Todo.Server 模块的所有函数调用感兴趣。

```elixir
iex(tracer@localhost)1> :dbg.tracer()    # 启动跟踪进程            
iex(tracer@localhost)2> :dbg.n(:"todo@localhost") # 只订阅todo节点的events
iex(tracer@localhost)3> :dbg.p(:all, [:call])      # 订阅所有函数调用
iex(tracer@localhost)4> :dbg.tp(Todo.Server, [])    # 跟踪Todo.Server模块的所有函数
```

设置了跟踪后，您可以发出 HTTP 请求以检索 Bob 的条目。在跟踪器节点的终端中，您应该会看到类似以下内容的输出：

```shell
(<12505.1106.0>) call 'Elixir.Todo.Server':whereis(<<"bob">>)
(<12505.1106.0>) call 'Elixir.Todo.Server':child_spec(<<"bob">>)
(<12505.1012.0>) call 'Elixir.Todo.Server':start_link(<<"bob">>)
(<12505.1107.0>) call 'Elixir.Todo.Server':init(<<"bob">>)
(<12505.1107.0>) call 'Elixir.Todo.Server':handle_continue(init, ...)
(<12505.1106.0>) call 'Elixir.Todo.Server':entries(<12505.1107.0>, ...)
(<12505.1107.0>) call 'Elixir.Todo.Server':handle_call({entries, ...})
```

每个输出行显示调用进程、被调用的函数和输入参数。 在生产环境中进行追踪时要小心，因为大量的追踪可能会淹没系统。 一旦您完成追踪，调用 `:dbg.stop_clear/0` 来停止所有追踪。

这是一个简短的演示；:dbg 有更多选项。如果你决定进行一些追踪，你应该查看 :dbg 文档。此外，你还应该看看一个名为 Recon 的库（https://github.com/ferd/recon），它提供了许多用于分析运行中 BEAM 节点的有用功能。

我们现在已经完成了对 Elixir、Erlang 和 OTP 的探讨。这本书涵盖了 Elixir 语言的主要方面、基本的函数式编程习惯、Erlang 的并发模型以及最常用的 OTP 行为（GenServer、Supervisor 和 Application）。根据我的经验，这些是构建 Elixir 和 Erlang 系统时最常用的基本模块。

当然，许多主题没有被涉及，因此你的旅程并不会就此结束。你可能想要寻找其他知识资源，例如其他书籍、博客和播客。寻找进一步材料的一个好起点是官方 Elixir 网站上的“学习”页面（https://elixir-lang.org/learning.xhtml）。

**总结**

- 要启动系统，必须先编译所有代码。然后，必须以正确设置的加载路径启动 BEAM 实例。最后，您需要启动所有 OTP 应用程序。

- 最简单的方法是依赖 Elixir 工具，比如 iex 和 Mix。

- OTP 发行版是一个独立系统，仅包含运行时工件——编译后的 OTP 应用程序和（可选的）Erlang 运行时系统。

- 可以通过 mix release 任务轻松构建 OTP 发行版。

- 一旦发行版运行，您可以通过远程 shell 连接到它或附加到它的控制台。然后，您可以以各种方式与系统交互并找到有关虚拟机和各个进程的详细信息。