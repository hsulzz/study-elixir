# 容灾基础

**本章涵盖：**

- 运行时错误
- 并发系统的错误
- 监督者

容错是 BEAM 中的一个一流概念。能够开发出即使在运行时遇到错误时仍能正常工作的可靠系统，正是让我们得到了 Erlang 的原因。

容错的目标是承认故障的存在，最小化其影响，并最终在没有人工干预的情况下恢复。在一个足够复杂的系统中，许多事情都可能出错。偶尔会出现bug，您依赖的组件可能会失败，您可能会遇到硬件故障。系统可能会过载，无法应对增加的请求率。最后，如果系统是分布式的，您可能会遇到额外的问题，例如远程机器变得不可用，可能是由于崩溃或网络链接断开。

很难预测所有可能出错的事情，因此面对任何事情都可能失败的严酷现实是更好的选择。无论系统的哪个部分发生故障，都不应该导致整个系统崩溃；您希望能够至少提供某种服务。例如，如果数据库服务器变得不可访问，您仍然可以从缓存中提供数据。您甚至可以将传入的存储请求排队，稍后再尝试解决这些请求，当数据库连接恢复时。

您还必须检测故障并尝试从中恢复。在之前的例子中，系统可能会尝试重新连接到数据库，直到成功为止，然后恢复提供全面服务。

这些是一个具有弹性和自愈能力系统的特性。无论发生什么问题（请记住，任何事情都有可能出错），系统应该尽可能地保持提供服务，并尽快完全恢复。

这种思维方式显著改变了对错误处理的看法。你的优先事项不再是强迫减少错误的数量，而是最小化错误的影响并自动恢复。在一个必须持续运行的系统中，遇到多个孤立的错误总比遇到一个会导致整个系统崩溃的错误要好。

令人有些惊讶的是，错误处理的核心工具是并发。在BEAM世界中，两个并发进程是完全分开的；它们没有共享内存，一个进程中的崩溃默认情况下不会影响另一个进程的执行流程。进程隔离使你能够将错误的负面影响限制在单个进程或一小组相关进程中，从而使大部分系统正常运行。

当然，当一个进程崩溃时，你通常希望能检测到这种状态并采取相应措施。在本章中，你将学习在并发系统中检测和处理错误的基本技术。然后，在第9章中，你将扩展这些知识，并实现细粒度的错误隔离。让我们先从运行时错误的理论开始。

## 8.1 运行时错误

在前面的章节中，我大致提到，在各种情况下会引发错误。一个最常见的例子是模式匹配失败。如果匹配失败，则会引发错误。另一个例子是同步的 GenServer.call。如果响应消息在给定的时间间隔内（默认5秒）没有到达，则会发生运行时错误。还有许多其他例子，如无效的算术操作（例如，除以零）、调用不存在的函数以及显式错误信号。

当发生运行时错误时，执行控制会向上转移到调用栈中的错误处理代码。如果你没有指定这样的代码，发生错误的进程将被终止。默认情况下，所有其他进程不受影响地继续运行。

### 8.1.1 错误类型

BEAM区分三种类型的运行时错误：`errors`,`exits`,`throws`，下面是一些例子：

```elixir
iex(1)> 1/0                                         
** (ArithmeticError) bad argument in arithmetic expression
 
iex(1)> Module.nonexistent_function()               
** (UndefinedFunctionError) function Module.nonexistent_function/0 is
   undefined or private
 
iex(1)> List.first({1,2,3})                         
** (FunctionClauseError) no function clause matching in List.first/2
```

您也可以使用`raise/1`来跑出错误，传递错误信息字符串：

```elixir
iex(1)> raise("something went wrong")
** (RuntimeError) something went wrong
```

如果你的函数显式地抛出错误，你应该在函数名后面添加 ! 字符。这是 Elixir 标准库中使用的一个约定。例如，File.open! 如果文件无法打开，则会抛出错误。

```elixir
iex(1)> File.open!("nonexistent_file")
** (File.Error) could not open non_existing_file: no such file or directory
```

相反，File.open（注意没有感叹号！）只是返回文件无法打开的信息：

```elixir
iex(1)> File.open("nonexistent_file")
{:error, :enoent}
```

请注意，这段代码没有运行时错误。File.open 返回一个结果，调用者可以以某种方式处理它。另一种运行时错误是退出，用于故意终止一个进程。要退出当前进程，可以调用 exit/1，并提供退出原因：

```elixir
iex(2)> spawn(fn ->
          exit("I'm done")   
          IO.puts("This doesn't happen")
        end)
```

退出原因是一个任意的术语，用来描述你为什么终止该进程。正如你稍后会看到的，其他一些进程能够检测到进程崩溃并获取这个退出原因。最后一种运行时错误类型是抛出。要抛出一个错误，你可以调用 throw/1:

```elixir
iex(3)> throw(:thrown_value)
** (throw) :thrown_value
```

throws的目的在于实现非本地返回。如你在第三和第四章中看到的，Elixir程序组织成多个嵌套的函数调用。特别地，循环是通过递归来实现的。其结果是，没有像break、continue和return这样的构造，这些构造在你可能见过的其他语言中是常见的。当你在一个深层循环中时，停止循环并返回一个值并不是一件简单的事情；throws可以帮助你实现这一点。你可以抛出一个值并在调用栈中捕获它。但是，使用throws进行控制流是一种hacky的做法，有点类似于goto，因此你应该尽量避免使用这种技术。

### 8.1.2 处理错误

当然，可以拦截任何类型的运行时错误（错误、退出或抛出）并对此做出处理。主要的工具是try表达式。以下是如何运行一些代码并捕获错误的示例：

```elixir
try do
  ...
catch error_type, error_value ->
  ...
end
```

这与您可能在其他语言中看到的工作方式非常相似。在 do 块中的代码被执行，如果发生错误，执行将转移到 catch 块。

请注意，catch 中指定了两件事。error_type 将包含一个原子值 :error、:exit 或 :throw，指示发生的错误类型。error_value 将包含特定于错误的信息，例如被抛出的值或被引发的错误。让我们通过编写一个辅助的 lambda 来稍作实践，以便更轻松地实验错误：

```elixir
iex(1)> try_helper = fn fun ->
          try do
            fun.()
            IO.puts("No error.")
 
          catch type, value ->
            IO.puts("""
              Error
                #{inspect(type)}
                #{inspect(value)}
              """)
          end
        end
```

这个辅助 lambda 将一个函数作为参数，尝试调用这个函数，并报告错误类型及相应的值。由于输出跨越多个行，因此使用了 heredoc 语法（”””），该语法在第二章中简要提到过。

我们来尝试一下：

```elixir
iex(2)> try_helper.(fn -> raise("Something went wrong") end)
Error
  :error                                            
  %RuntimeError{message: "Something went wrong"}    
```

注意字符串消息是如何被封装在 RuntimeError 结构中的。这是一个特定于 Elixir 的装饰，由 raise/1 宏内部完成。如果你想引发一个简单的、未装饰的错误，可以使用 Erlang 的 :erlang.error/1，并提供一个任意的术语。结果的错误值将是你提出的术语。如果你试图抛出一个值，你将得到一个不同的错误类型：

```elixir
iex(3)> try_helper.(fn -> throw("Thrown value") end)
Error
  :throw
  "Thrown value"
```

调用 exit/1 会产生不同类型的错误：

```elixir
iex(4)> try_helper.(fn -> exit("I'm done") end)
Error
  :exit
  "I'm done"
```

请记住，在 Elixir 中，一切都是有返回值的表达式。在 try 中，返回值是最后执行的表达式的结果——要么来自 do 块，要么（如果引发了错误）来自 catch 块：

```elixir
iex(5)> result =
          try do
            throw("Thrown value")
          catch type, value -> {type, value}
          end
 
iex(6)> result
{:throw, "Thrown value"}
```

还值得注意的是，catch 块中指定的类型和值是模式。如果你想处理特定类型的错误，可以通过提供相应的模式来实现。例如，假设你想从深度嵌套的循环中立即返回一个值。你可以调用以下代码：

```elixir
throw({:resutl, some_result})
```

然后，在调用栈的某个地方，你会处理这个抛出的值：

```elixir
try do
  ...
catch
  :throw, {:result, x} -> x
end
```

在这个例子中，你仅匹配特定的运行时错误：格式为 {:result, x} 的 throw。如果抛出了其他任何内容，你将无法捕获它，错误将进一步传播到调用栈上方。如果错误未被处理，进程将终止。由于 catch 是一个模式匹配，可以像在 case 和 receive 表达式中看到的那样指定多个条款：

```elixir
try do
  ...
 
catch
  type_pattern_1, error_value_1 ->
    ...
 
  type_pattern_2, error_value_2 ->
    ...
 
  ...
end
```

匹配到抛出错误的第一个模式下的代码块会被调用，并返回最后一个表达式的结果。如果你想捕获任何错误，可以使用类型、值的模式，或者如果你不关心值，可以使用 _，_。这些模式将处理所有可能发生的错误。

可以指定在 try 块之后始终执行的代码，无论是否发生错误。

```elixir
iex(7)> try do
          raise("Something went wrong")
        catch
          _,_ -> IO.puts("Error caught")
        after
          IO.puts("Cleanup code")    
        end
 
Error caught
Cleanup code
```

因为它总是被执行，after 块对于清理资源非常有用，比如关闭一个打开的文件。值得注意的是，after 子句不会影响整个 try 表达式的结果。try 的结果是最后一个表达式的结果，可能来自 do 块，也可能来自捕获到的异常对应的 catch 块。

---
**try and tail calls**

你可能还记得在第三章中提到的尾调用优化。如果一个函数的最后一件事是调用另一个函数（或它自身），那么会发生简单的跳转而不需要压栈。如果函数调用位于一个 try 表达式中，这种优化是不可能的。这是相当明显的，因为函数的最后一件事是一个 try 块，而它在 do 或 catch 块完成之前不会结束。因此，try 中调用的任何内容都不是函数的最后一件事，因此不适合进行尾调用优化。

---

这里有关于运行时错误的更多内容。Elixir在这个基本机制之上提供了一些抽象。你可以通过使用 defexception 宏定义自定义错误（请参见 https://hexdocs.pm/elixir/Kernel.xhtml#defexception/1），并以稍微优雅的方式处理它们。try 特殊形式还有一些我们未曾讨论的其他功能。你一定要研究一下官方的 try 文档（https://hexdocs.pm/elixir/Kernel.SpecialForms.xhtml#try/1），以及相应的“入门”部分（https://elixir-lang.org/getting-started/try-catch-and-rescue.xhtml）。

我在这里介绍的是运行时错误的核心概念。所有Elixir支持的其他扩展最终归结于这些概念，并具有相同的属性：

- 一个运行时错误具有一个类型，可以是 :error、:exit 或 :throw。

- 运行时错误还具有一个值，可以是任何任意术语。

- 如果未处理运行时错误，相应的进程将会终止。

与C++、C#、Java和JavaScript等语言相比，捕获运行时错误的需求要小得多。更常见的习惯是让进程崩溃，然后采取措施解决这个问题（通常是重启进程）。这种方法可能看起来有些hacky，但背后有其道理。在复杂系统中，大多数错误在测试阶段就会被发现。剩下的错误主要属于所谓的海森堡错误（Heisenbug）类别——在特殊情况下不规则地出现的不可预知的错误，并且难以重现。此类错误的原因通常在于状态的损坏。因此，合理的补救方法是让进程崩溃并启动另一个进程。

这可能会有所帮助，因为你正在摆脱进程状态（可能已损坏），并从一个干净的状态开始。在许多情况下，这样做可以解决即刻的问题。当然，这个错误应该被记录下来，以便你可以稍后进行分析并找出根本原因。但在此期间，你可以从意外故障中恢复并继续提供服务。如果这个讨论看起来有些模糊，也不用担心。这种错误处理的方法，也被称为让它崩溃，将在本章及下一章中详细解释。在接下来的部分中，我们将研究并发系统中的错误处理基础知识。

## 8.2 并发系统中的错误

并发在构建容错的 BEAM 系统中扮演着核心角色。这是因为各个进程之间完全隔离且独立。一个进程的崩溃不会影响其他进程（除非你明确希望如此）。

下面是一个快速演示：

```elixir
iex(1)> spawn(fn ->                       
          spawn(fn ->                     
            Process.sleep(1000)
            IO.puts("Process 2 finished")
          end)
 
          raise("Something went wrong") 
        end)
```

运行这个会产生以下输出：

```elixir
17:36:20.546 [error] Process #PID<0.116.0> raised an exception   
...
Process 2 finished     
```

正如您所见，尽管进程1崩溃了，进程2的执行仍在进行。关于进程1崩溃的信息已经打印到屏幕上，但系统的其余部分——包括进程2和iex shell提示——都正常运行。

此外，由于进程之间不共享内存，一个进程的崩溃不会留下可能会损坏另一个进程的内存垃圾。因此，通过在不同进程中运行独立操作，您自动确保了隔离和保护。

您在本书的示例待办事项系统中已经受益于进程隔离。回想一下当前的架构，如图8.1所示。

![图8.1](assets/8.1.png)


所有图中的框都是BEAM进程。单个待办事项服务器的崩溃不会影响其他待办事项列表的操作。Todo.Database的崩溃不会阻止在待办事项服务器进程中进行的缓存读取。

当然，这种隔离本身并不足够。如图8.1所示，进程之间通常会相互通信。如果一个进程没有运行，它的客户端就无法使用它的服务。例如，如果数据库进程崩溃，待办事项服务器就无法查询它。更糟糕的是，对待办事项列表的修改将无法持久化。显然，这种行为是不可取的，你必须有一种方法来检测进程崩溃，并以某种方式恢复它。

### 8.2.1 关联进程

A basic primitive for detecting a process crash is the concept of links. If two processes are linked, and one of them terminates, the other process receives an exit signal—a notification that a process has crashed. 


一个退出信号包含崩溃进程的 PID 和退出原因——一个任意的 Elixir 术语，描述了进程终止的原因。在正常终止的情况下（即启动的函数已完成），退出原因是原子 :normal。默认情况下，当一个进程收到来自另一个进程的退出信号且该信号不是 :normal 时，链接的进程也会终止。换句话说，当一个进程异常终止时，链接的进程也会被关闭。

一个链接恰好连接两个进程，并且始终是双向的。要创建一个链接，可以使用 Process.link/1，将当前进程与另一个进程连接起来。更常见的是，当你启动一个进程时，会创建一个链接。你可以使用 spawn_link/1 来实现，这会生成一个进程并将其链接到当前进程。

让我们验证一下。在下面的示例中，你将再次生成两个进程，这次将它们链接在一起。然后你可以关闭一个进程：

```elixir
iex(1)> spawn(fn ->
          spawn_link(fn ->       
            Process.sleep(1000)
            IO.puts("Process 2 finished")
          end)
 
          raise("Something went wrong")
        end)
```

毫无意外，改例子的输入如下：

```elixir
17:36:20.546 [error] Process #PID<0.116.0> raised an exception
```

请注意，您看不到进程 2 的输出。这是因为进程 1 异常终止，导致向进程 2 发出了退出信号。一个进程可以链接到任意数量的其他进程，您可以在系统中创建任意多个链接，如图 8.2 所示。

![图8.2](assets/8.2.png)

这说明了过程链接的传递性质。在这个结构中，单个过程的崩溃会向所有与之链接的过程发出退出信号。如果默认行为没有被覆盖，这些过程也会崩溃。最终，整个链接过程的树形结构将被摧毁。

**TRAPPING EXITS**

你可能会对链接的后果感到困惑。之前，我解释了进程隔离如何使得隔离运行时错误的影响成为可能。链接打破了这种隔离，并在进程边界上传播错误。你可以把链接看作是用于提供进程终止通知的通信渠道。

通常，你不希望被链接的进程崩溃。相反，你希望能够检测到进程崩溃并采取一些措施。这可以通过捕获退出信号来实现。当一个进程捕获退出时，当被链接的进程崩溃时，它不会被终止。相反，一个退出信号会以标准消息的形式放入当前进程的消息队列中。捕获退出的进程可以接收这个消息并对崩溃做出反应。

要设置退出捕获，你可以调用 `Process.flag(:trap_exit, true)`，这会使当前进程捕获退出信号。让我们看看这如何工作：

```elixir
“iex(1)> spawn(fn ->
          Process.flag(:trap_exit, true)                        
 
          spawn_link(fn -> raise("Something went wrong") end)   
 
          receive do                                            
            msg -> IO.inspect(msg)                              
          end                                                   
        end)
```

这里，您使父进程捕获退出，然后生成一个将崩溃的链接进程。接着您收到一条消息并将其打印到屏幕上。Shell会话产生以下输出：

```elixir
{:EXIT, #PID<0.118.0>,
 {%RuntimeError{message: "Something went wrong"},
  [{:elixir_eval, :__FILE__, 1 [file: ~c”iex”, line: 4]}]}}
```

退出信号消息的一般格式是 `⁠{ :EXIT, from_pid, exit_reason }`，其中 ⁠from_pid 是崩溃进程的进程ID，而 ⁠exit_reason 是描述进程终止原因的任意术语。如果进程由于抛出或错误而终止，则退出原因是形式为 ⁠{ reason, where } 的元组，其中 ⁠where 包含堆栈跟踪信息。否则，如果进程由于退出而终止，原因是提供给 ⁠exit/1 的术语。

### 8.2.2 监视器

像之前提到的那样，链接总是双向的。大多数情况下，这正是你所需要的，但在某些情况下，单向传播进程崩溃的效果更好。有时，你需要以某种方式连接两个进程 A 和 B，使得 A 进程在 B 终止时会得到通知，但反之则不然。在这种情况下，你可以使用监视器，它类似于单向链接。

要监视一个进程，你可以使用 Process.monitor：

```elixir
monitor_ref = Process.monitor(target_pid)
```

这使得当前进程能够监视目标进程。结果是一个唯一的引用，用于标识监视器。单个进程可以创建多个监视器。

如果被监视的进程死亡，您的进程将收到一个格式为 {:DOWN, monitor_ref, :process, from_pid, exit_reason} 的消息。如果您愿意，也可以通过调用 Process.demonitor(monitor_ref) 来停止监视器。

下面是一个简单的例子：

```elixir
iex(1)> target_pid = spawn(fn ->                                
          Process.sleep(1000)                                   
        end)                                                    
 
iex(2)> Process.monitor(target_pid) 
 
iex(3)> receive do                                              
          msg -> IO.inspect(msg)                                
        end                                                     
 
{:DOWN, #Reference<0.1398266903.3291480065.256365>, :process,   
  #PID<0.111.0>, :noproc}                                       
```

 监视器和链接之间有两个主要区别。首先，监视器是单向的——只有创建监视器的进程可以接收通知。此外，与链接不同，观察者进程在被监视的进程终止时不会崩溃。相反，会发送一条消息，你可以选择处理或忽略它。

 ---

 **Exits are propagated through GenServer calls**

当你通过 GenServer.call 发出同步请求时，如果服务器进程崩溃，客户端进程将收到一个退出信号。这是跨进程错误传播的一个简单但非常重要的例子。在内部，GenServer 设置了一个临时监视器来监控服务器进程。当等待服务器的响应时，如果收到 :DOWN 消息，GenServer 可以检测到进程崩溃，并在客户端进程中引发相应的退出信号。

---

Link、exit-trap和monitor使得在并发系统中检测错误成为可能。你可以引入一个进程，负责接收链接和监视通知，以及在系统中其他进程崩溃时采取相应的措施。这种进程被称为监督者，是并发系统中的错误恢复的主要工具。

## 8.3 监督者

监督者是一个通用进程，用于管理系统中其他进程的生命周期。监督者进程可以启动其他进程，这些进程被视为其子进程。通过连接、监控和退出陷阱，监督者可以检测到任何子进程的可能终止，并在需要时重新启动它。

不是监督者的进程称为工作进程。这些进程提供系统的实际服务。您当前的待办事项系统仅由工作进程组成，例如待办事项缓存和待办事项服务器进程。

如果任何工作进程崩溃，可能是由于一个错误，那么系统的某些部分将永远消失。这就是监督者的作用。通过在一个监督者下运行工作进程，你可以确保失败的进程被重新启动，从而恢复系统的服务。

为此，你需要在系统中至少有一个监督进程。在 Elixir 中，您可以使用 Supervisor 模块来实现这一点（https://hexdocs.pm/elixir/Supervisor.xhtml）。通过调用 Supervisor.start_link/2，可以启动监督进程，其工作方式如下：

1. 监督进程捕获退出信号，然后启动子进程。

2. 如果在任何时候子进程终止，监督进程会收到相应的退出消息并执行纠正措施，例如重新启动崩溃的进程。

3. 如果监督进程终止，其子进程也会被终止。

启动监督者有两种不同的方法。在基本方法中，你调用函数 Supervisor.start_link，传递一个描述每个子进程的列表，并附带一些额外的监督选项。或者，你可以传递一个模块，该模块定义一个回调函数，该函数返回这些信息。我们将从基本方法开始，稍后再解释第二种方法。

![图8.3](assets/8.3.png)

让我们向待办事项系统引入一个管理者。图8.3概述了系统中的这些进程：

- Todo.Server—允许多个客户端在同一个待办列表上工作

- Todo.Cache—维护一组待办服务器，并负责它们的创建和发现

- Todo.DatabaseWorker—对数据库执行读写操作

- Todo.Database—管理数据库工作者的池并将数据库请求转发给它们

待办事项缓存进程是系统的入口点。当您启动缓存时，所有所需的进程都会启动，因此可以将缓存视为系统的根。现在，我们将引入一个新的管理进程，来监督待办事项缓存进程。

### 8.3.1 准备现存代码

在您开始与监督者工作之前，您需要对缓存进行几处更改。首先，您需要注册缓存进程。这将使您能够与该进程交互，而无需知道它的PID。

在启动待办事项缓存进程时，您还需要创建一个链接。如果您希望在监督者下运行该进程，这是必需的。为什么监督者使用链接而不是监视器？因为链接是双向的，因此监督者的终止意味着它的所有子进程将被自动终止。这反过来又允许您在不留下悬挂进程的情况下正确结束系统的任何部分。在本章和下一章中，当您处理更细粒度的监督时，您会了解这一点是如何工作的。

创建指向调用进程的链接就像把 GenServer.start 替换为 GenServer.start_link 那样简单。在此过程中，您还可以将相应的 Todo.Cache 接口函数重命名为 start_link。

最后，您将使 start_link 函数接受一个参数并忽略它。这似乎令人困惑，但它使启动一个受监督的进程变得稍微容易一些。原因将在稍后讨论子规范时解释。更改显示在以下列表中。

```elixir
# Listing 8.1 Changes in the do-do cache (supervised_todo_cache/lib/todo/cache.ex)
demodule Todo.Cache do
  use GenServer

  def start_link(_) do
    GenServer.start_link(__MODULE__, name: __MODULE__)
  end
  
  def server_process(todo_list_name) do
    GenServer.call(__MODULE__, {:server_process, todo_list_name})   
  end

  def init(_) do
    IO.puts("Starting to-do cache.")
  end
end
```

注意，你在 init/1 回调中也调用了 IO.puts/1 进行调试。这条调试表达式包含在所有其他 GenServer 回调模块中（如 Todo.Database、Todo.DatabaseWorker 和 Todo.Server）。