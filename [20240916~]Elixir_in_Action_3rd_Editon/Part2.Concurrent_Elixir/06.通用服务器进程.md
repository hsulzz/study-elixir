# Generic server processes

**本章涵盖**

- 创建一个通用服务器进程
- 使用`GenServer`

在第五章中，你了解了基本的并发技术：你学会了如何创建进程并与它们进行通信。我还解释了有状态服务器进程的概念——这些是长时间运行的进程，可以对消息作出反应并维护状态。

服务器进程在构建高度并发的 Elixir 和 Erlang 系统时起着重要作用，因此我们将花一些时间详细探讨它们。在本章中，你将学习如何减少与服务器进程相关的一些样板代码，比如无限递归、状态管理和消息传递。

Erlang 提供了一个帮助模块来实现服务器进程——这是开放电信平台（OTP）框架的一部分。尽管名称令人误解，这个框架与电信无关；相反，它为创建组件、构建发布、开发服务器进程、处理和恢复运行时错误、日志记录、事件处理和代码升级等任务提供模式和抽象。

你将在本书的多个部分学习 OTP 的各个部分，但在这一章，我们将重点关注它最重要的部分之一：GenServer，这是一个简化服务器进程实现的模块。不过在查看 `GenServer` 之前，你将实现一个基于第五章中看到的消息传递原语的简化版本。

## 6.1 构建一个通用服务器进程

你在第五章看到了一些服务器进程的例子。尽管这些进程服务于不同的目的，但它们的实现之间有一些共同点。特别是，所有实现服务器进程的代码需要完成以下任务：

- 生成一个独立的经常
- 经常中执行一个无限循环
- 管理进程状态
- 对消息作出反应
- 给调用者发送回复

无论您运行什么类型的服务器进程，您总是需要执行这些任务，因此将这些代码移动到一个位置是值得的。具体的实现可以重用这些代码，并专注于它们特定的需求。让我们看看您如何实现这样的通用代码。

### 6.1.1 使用模块进行插入

通用代码将执行服务器进程中常见的各种任务，将具体的决策留给具体的实现。例如，通用代码将生成一个进程，但具体实现必须确定初始状态。同样，通用代码将运行循环；接收消息；并选择性地发送响应，但具体实现必须决定如何处理每条消息以及响应是什么。

换句话说，通用代码驱动整个过程，而具体实现则必须填补缺失的部分。因此，您需要一个插件机制，让通用代码在需要做出具体决策时能够调用具体实现。

实现此功能的最简单方法是使用模块。请记住，模块名是一个原子（atom）。您可以将该原子存储在一个变量中，然后稍后使用该变量调用模块中的函数。

```elixir
iex(1)> some_module = IO  

iex(2)> some_module.puts("Hello")  
Hello
```

你可以使用这个功能从通用代码提供回调钩子。特别是，你可以采取以下方法：

1. 使通用代码接受一个插件模块作为参数。该模块称为回调模块。

2. 将模块原子作为过程状态的一部分进行维护。

3. 在需要时调用回调模块的函数。

显然，为了使这一切正常工作，回调模块必须实现并导出一组明确定义的函数，我将在实现通用代码时逐步介绍这些函数。

### 6.1.2 实现通用代码

让我们来构建一个通用服务器进程，首先你需要启动进程并初始化其状态：

```elixir
# Listing 6.1 Starting the server process (server_process.ex)
defmodule ServerProcess do
  def start(callback_module) do
    spawn(fn ->
    initial_state = callback_module.init()
    loop(callback_module, initial_state)
    end)
  end
  ...
end
```

`ServerProcess.start/1 `以一个模块原子作为参数，然后生成进程。在生成的进程中，回调函数 `init/0` 被调用以创建初始状态。显然，为了使这个有效，回调模块必须导出 `init/0` 函数。

最后，您进入了一个循环，该循环将驱动服务器进程并维持这种状态。`ServerProcess.start/1` 的返回值是一个进程 ID (pid)，可以用来向请求进程发送消息。

接下来，您需要实现驱动进程的循环代码，等待消息并处理它们。在这个例子中，您将实现一种同步发送和响应的通信模式。服务器进程必须接收一条消息，处理它，将响应消息发送回调用者，并更改进程状态。

通用代码负责接收和发送消息，而具体实现必须处理消息并返回响应和新的状态。这个思想在下面的代码清单中得以展现。

```elixir
# Listing 6.2 Handling messages in the server process (server_process.ex)
defmodule ServerProcess do
  ...
  defp loop(callback_module, current_state) do
    receive do
      {request, caller} ->
        {response, new_state} =
          callback_module.handle_call(
            request,
            current_state
          )
          
          send(caller, {:response, response})

          loop(callback_module, new_state)
        end
    end
    ...
end
```

在这里，你需要期待一个以 `{request, caller}` 元组形式的消息。请求是一个数据，用来标识请求，并对特定实现有意义。回调函数 `handle_call/2` 需要接收请求有效载荷和当前状态，并且必须返回一个 `{response, new_state}` 元组。通用代码随后可以将响应发送回调用者，并继续使用新状态循环。唯一需要做的事情是提供一个函数向服务器进程发出请求。

```elixir
# Listing 6.3 Helper for issuing requests (server_process.ex)
defmodule ServerProcess do
  ...
  def call(server_pid, requst) do
    send(server_pid, {request, self()})

    receive do
      {:response, response} ->
        response
    end
  end
end
```

在这一点上，您已经为通用服务器进程建立了抽象。让我们看看它如何被使用。

### 6.1.3 使用通用抽象

为了测试服务器进程，您将实现一个简单的键值存储。这将是一个可以用来存储任意条目之间映射的进程。请记住，回调模块必须实现两个函数：`init/0`，用于创建初始状态，以及`handle_call/2`，用于处理特定请求。

```elixir
# Listing 6.4 Key-value store implementation (server_process.ex)
defmodule KyeValueStore do
  def init do
    %{}
  end

  def handle_call({:put, key, value},state) do
    {:ok, Map.put(state, key, value)}
  end

  def handle_call({:get, key}, state) do
    {Map.get(state, key), state}
  end
end
```

这就是创建一个特定服务器进程所需的全部内容。由于无限循环和消息传递的样板代码被推送到了通用代码中，特定实现变得更加简洁，并专注于其主要任务。

特别注意你如何在 `handle_call/2` 中使用多重子句来处理不同类型的请求。这是具体实现决定如何处理每个请求的地方。ServerProcess 模块是通用代码，它盲目地将请求从客户端进程转发到回调模块。

让我们测试一下这个进程:

```elixir
iex(2)> ServerProcess.call(pid, {:put, :some_key, :some_value})
:ok

iex(3)> ServerProcess.call(pid, {:get, :some_key})
:some_value
```

注意你是如何用 `ServerProcess.start(KeyValueStore)` 启动这个过程的。在这里，你将特定的 KeyValueStore 插入到 ServerProcess 的通用代码中。后续对 `ServerProcess.call/2` 的所有调用将会向那个进程发送消息，该进程将反过来调用 `KeyValueStore.handle_call/2` 来执行处理。

让客户完全不知道使用了 ServerProcess 抽象是有益的。这可以通过引入辅助函数来实现。

```elixir
# Listing 6.5 Wrapping ServerProcess function calls (server_process.ex)
defmodule KeyValueStore do
  def start do
    ServerProcess.start(KeyValueStore)
  end

  def put(pid, key, value) do
    ServerProcess.call(pid, {:put, key, value})
  end

  def get(pid, key) do
    ServerProcess.call(pid, {:get, key})
  end
  ...
end
```

客户端现在可以使用 `start/0`、`put/3` 和 `get/2` 来操作键值存储。这些函数被非正式地称为接口函数。客户使用 `KeyValueStore` 的接口函数来启动和与进程交互。相比之下，`init/0` 和 `handle_call/2` 是由通用代码内部使用的回调函数。请注意，接口函数在客户端进程中运行，而回调函数始终在服务器进程中调用。

# 6.1.4 支持异步请求

当前的 ServerProcess 实现仅支持同步请求。让我们对这一点进行扩展，加入对异步“fire-and-forget”请求的支持，在这种请求中，客户端发送一条消息而不等待响应。

在当前的代码中，我们使用“调用”一词来表示同步请求。对于异步请求，我们将使用“发送”这个术语。这是 OTP 中使用的命名约定，因此采用它是好的选择。

因为您要引入第二种请求类型，所以需要更改在客户端进程和服务器之间传递的消息格式。这将使您能够在服务器进程中确定请求类型，并以不同的方式处理不同类型的请求。

这可以通过在从客户端进程传递到服务器的元组中包含请求类型信息来实现。

```elixir
# Listing 6.6 Including the request type in the message (server_process_cast.ex)
defmodule ServerProcess do
  ...
  def call(server_pid, request) do
    send(server_pid, {:call, request, self()})
    ...
  end

  defp loop(callback_module, current_state) do
    receive do
      {:call, request, caller} ->
      ...
    end
  end
  ...
end
```

现在，您可以引入对cast请求的支持。在这种情况下，当消息到达时，具体的实现会处理它并返回新的状态。没有响应被发送回调用者，因此回调函数必须只返回新的状态。

```elixir
# Lisitng 6.7 Supporting casts in the server process (server_process_cast.ex)
defmodule ServerProcess do
  def call(server_pid, request) do
    send(server_pid,{:call, request, self()})
  end

  def cast(server_pid, request) do
    send(server_pid, {:cast, request})
  end

  defp loop(callback_module, current_state) do
    receive do
      {:call, resquest, caller} ->
        {response,new_state} = callback_module.handle_call(
          request,
          current_state
        )
        send(caller, {:response, response})
        loop(callback_module,new_state)

      {:cast, reuqest} ->
        new_state = callback_module.handle_cast(
          request,
          current_state
        )
        loop(callback_module,new_state)
    end
  end
end
```

要处理 cast 请求，您需要回调函数 handle_cast/2。这个函数必须处理消息并返回新的状态。在服务器循环中，您接着调用这个函数并使用新状态进行循环。支持 cast 请求只需做到这些。最后，您将更改键值存储的实现以使用 casts。请记住，cast 是一种“发送后不再等待”的请求类型，因此并不适合所有请求。在这个例子中，get 请求必须是 call，因为服务器进程需要用与给定键关联的值进行响应。相比之下，put 请求可以实现为 cast，因为客户端不需要等待响应。

```elixir
# Listing 6.8 Implementing put as a cast (server_process_cast.ex)
defmodule KeyValueStore do
  ...
  def put(pid, key, value) do
    ServerProcess.cast(pid, {:put, key, value})
  end

  def handle_cast({:put, key, value}, state) do
    Map.put(state, key, value)
  end
end
``` 

现在可以尝试一下：

```elixir
iex(1)> pid = KeyValueStore.start()
 
iex(2)> KeyValueStore.put(pid, :some_key, :some_value)
 
iex(3)> KeyValueStore.get(pid, :some_key)
:some_value
```

通过对通用实现进行简单修改，您为服务过程添加了另一个功能。具体实现现在可以决定每个具体请求是作为调用还是转换来实现。

## 6.2 使用GenServer

