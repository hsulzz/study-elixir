# Generic server processes

**本章涵盖**

- 创建一个通用服务器进程
- 使用`GenServer`

在第五章中，你了解了基本的并发技术：你学会了如何创建进程并与它们进行通信。我还解释了有状态服务器进程的概念——这些是长时间运行的进程，可以对消息作出反应并维护状态。

服务器进程在构建高度并发的 Elixir 和 Erlang 系统时起着重要作用，因此我们将花一些时间详细探讨它们。在本章中，你将学习如何减少与服务器进程相关的一些样板代码，比如无限递归、状态管理和消息传递。

Erlang 提供了一个帮助模块来实现服务器进程——这是开放电信平台（OTP）框架的一部分。尽管名称令人误解，这个框架与电信无关；相反，它为创建组件、构建发布、开发服务器进程、处理和恢复运行时错误、日志记录、事件处理和代码升级等任务提供模式和抽象。

你将在本书的多个部分学习 OTP 的各个部分，但在这一章，我们将重点关注它最重要的部分之一：GenServer，这是一个简化服务器进程实现的模块。不过在查看 `GenServer` 之前，你将实现一个基于第五章中看到的消息传递原语的简化版本。

## 6.1 构建一个通用服务器进程

你在第五章看到了一些服务器进程的例子。尽管这些进程服务于不同的目的，但它们的实现之间有一些共同点。特别是，所有实现服务器进程的代码需要完成以下任务：

- 生成一个独立的经常
- 经常中执行一个无限循环
- 管理进程状态
- 对消息作出反应
- 给调用者发送回复

无论您运行什么类型的服务器进程，您总是需要执行这些任务，因此将这些代码移动到一个位置是值得的。具体的实现可以重用这些代码，并专注于它们特定的需求。让我们看看您如何实现这样的通用代码。

### 6.1.1 使用模块进行插入

通用代码将执行服务器进程中常见的各种任务，将具体的决策留给具体的实现。例如，通用代码将生成一个进程，但具体实现必须确定初始状态。同样，通用代码将运行循环；接收消息；并选择性地发送响应，但具体实现必须决定如何处理每条消息以及响应是什么。

换句话说，通用代码驱动整个过程，而具体实现则必须填补缺失的部分。因此，您需要一个插件机制，让通用代码在需要做出具体决策时能够调用具体实现。

实现此功能的最简单方法是使用模块。请记住，模块名是一个原子（atom）。您可以将该原子存储在一个变量中，然后稍后使用该变量调用模块中的函数。

```elixir
iex(1)> some_module = IO  

iex(2)> some_module.puts("Hello")  
Hello
```

你可以使用这个功能从通用代码提供回调钩子。特别是，你可以采取以下方法：

1. 使通用代码接受一个插件模块作为参数。该模块称为回调模块。

2. 将模块原子作为过程状态的一部分进行维护。

3. 在需要时调用回调模块的函数。

显然，为了使这一切正常工作，回调模块必须实现并导出一组明确定义的函数，我将在实现通用代码时逐步介绍这些函数。

### 6.1.2 实现通用代码

让我们来构建一个通用服务器进程，首先你需要启动进程并初始化其状态：

```elixir
# Listing 6.1 Starting the server process (server_process.ex)
defmodule ServerProcess do
  def start(callback_module) do
    spawn(fn ->
    initial_state = callback_module.init()
    loop(callback_module, initial_state)
    end)
  end
  ...
end
```

`ServerProcess.start/1 `以一个模块原子作为参数，然后生成进程。在生成的进程中，回调函数 `init/0` 被调用以创建初始状态。显然，为了使这个有效，回调模块必须导出 `init/0` 函数。

最后，您进入了一个循环，该循环将驱动服务器进程并维持这种状态。`ServerProcess.start/1` 的返回值是一个进程 ID (pid)，可以用来向请求进程发送消息。

接下来，您需要实现驱动进程的循环代码，等待消息并处理它们。在这个例子中，您将实现一种同步发送和响应的通信模式。服务器进程必须接收一条消息，处理它，将响应消息发送回调用者，并更改进程状态。

通用代码负责接收和发送消息，而具体实现必须处理消息并返回响应和新的状态。这个思想在下面的代码清单中得以展现。

```elixir
# Listing 6.2 Handling messages in the server process (server_process.ex)
defmodule ServerProcess do
  ...
  defp loop(callback_module, current_state) do
    receive do
      {request, caller} ->
        {response, new_state} =
          callback_module.handle_call(
            request,
            current_state
          )
          
          send(caller, {:response, response})

          loop(callback_module, new_state)
        end
    end
    ...
end
```

在这里，你需要期待一个以 `{request, caller}` 元组形式的消息。请求是一个数据，用来标识请求，并对特定实现有意义。回调函数 `handle_call/2` 需要接收请求有效载荷和当前状态，并且必须返回一个 `{response, new_state}` 元组。通用代码随后可以将响应发送回调用者，并继续使用新状态循环。唯一需要做的事情是提供一个函数向服务器进程发出请求。

```elixir
# Listing 6.3 Helper for issuing requests (server_process.ex)
defmodule ServerProcess do
  ...
  def call(server_pid, requst) do
    send(server_pid, {request, self()})

    receive do
      {:response, response} ->
        response
    end
  end
end
```

在这一点上，您已经为通用服务器进程建立了抽象。让我们看看它如何被使用。

### 6.1.3 使用通用抽象

为了测试服务器进程，您将实现一个简单的键值存储。这将是一个可以用来存储任意条目之间映射的进程。请记住，回调模块必须实现两个函数：`init/0`，用于创建初始状态，以及`handle_call/2`，用于处理特定请求。

```elixir
# Listing 6.4 Key-value store implementation (server_process.ex)
defmodule KyeValueStore do
  def init do
    %{}
  end

  def handle_call({:put, key, value},state) do
    {:ok, Map.put(state, key, value)}
  end

  def handle_call({:get, key}, state) do
    {Map.get(state, key), state}
  end
end
```

这就是创建一个特定服务器进程所需的全部内容。由于无限循环和消息传递的样板代码被推送到了通用代码中，特定实现变得更加简洁，并专注于其主要任务。

特别注意你如何在 `handle_call/2` 中使用多重子句来处理不同类型的请求。这是具体实现决定如何处理每个请求的地方。ServerProcess 模块是通用代码，它盲目地将请求从客户端进程转发到回调模块。

让我们测试一下这个进程:

```elixir
iex(2)> ServerProcess.call(pid, {:put, :some_key, :some_value})
:ok

iex(3)> ServerProcess.call(pid, {:get, :some_key})
:some_value
```

注意你是如何用 `ServerProcess.start(KeyValueStore)` 启动这个过程的。在这里，你将特定的 KeyValueStore 插入到 ServerProcess 的通用代码中。后续对 `ServerProcess.call/2` 的所有调用将会向那个进程发送消息，该进程将反过来调用 `KeyValueStore.handle_call/2` 来执行处理。

让客户完全不知道使用了 ServerProcess 抽象是有益的。这可以通过引入辅助函数来实现。

```elixir
# Listing 6.5 Wrapping ServerProcess function calls (server_process.ex)
defmodule KeyValueStore do
  def start do
    ServerProcess.start(KeyValueStore)
  end

  def put(pid, key, value) do
    ServerProcess.call(pid, {:put, key, value})
  end

  def get(pid, key) do
    ServerProcess.call(pid, {:get, key})
  end
  ...
end
```

客户端现在可以使用 `start/0`、`put/3` 和 `get/2` 来操作键值存储。这些函数被非正式地称为接口函数。客户使用 `KeyValueStore` 的接口函数来启动和与进程交互。相比之下，`init/0` 和 `handle_call/2` 是由通用代码内部使用的回调函数。请注意，接口函数在客户端进程中运行，而回调函数始终在服务器进程中调用。

# 6.1.4 支持异步请求

