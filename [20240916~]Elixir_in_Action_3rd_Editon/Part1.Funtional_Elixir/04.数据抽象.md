# Data abstractions

**本章涵盖**

- 使用模块进行抽象 
- 处理层次数据 
- 通过协议实现多态

本章讨论构建更高级的数据结构。在任何复杂系统中，都需要抽象，例如`Money`、`Date`、`Employee`和`OrderItem`。这些都是教科书中常见的高级抽象，通常不直接由语言支持，而是基于内置类型构建的。在 Elixir 中，这些抽象通过纯无状态模块实现。

在本章中，您将学习如何创建和使用自己的抽象。在典型的面向对象（OO）语言中，基本的抽象构建块是类和对象。例如，可能有一个 String 类实现各种字符串操作。每个字符串都是该类的一个实例，可以通过调用方法进行操作，下面的 Ruby 代码片段进行说明：

```ruby
"a string".upcase
```

这个方法在 Elixir 中通常不被使用。作为一种函数式语言，Elixir 鼓励将数据与代码解耦。你使用模块而非类，模块是函数的集合。你不是在对象上调用方法，而是显式地调用模块函数，并通过参数提供输入数据。以下代码片段展示了 Elixir 中将字符串转为大写的方式：

```elixir
String.upcase("a string")
```

与面向对象语言的另一个重要区别是，数据是不可变的。要修改数据，您必须调用某个函数并将其结果赋值给一个变量；原始数据保持不变。以下示例演示了这一技术：

```elixir
iex(1)> list = []
[]

iex(2)> list = List.insert_at(list, -1, :a)
[:a]

iex(3)> list = List.insert_at(list, -1, :b)
[:a, :b]

iex(4)> list =  List.insert_at(list, -1, :c)
[:a, :b, :c]
```

在这些例子中，你持续保持上一个操作的结果并将其传递给下一个操作。值得注意的是，在这两个 Elixir 代码片段中，模块被用作数据类型的抽象。当你需要处理字符串时，你会使用 `String` 模块。当你需要处理列表时，你会使用 `List` 模块。

字符串和列表是专门针对特定数据类型的模块的例子。它们是用纯 Elixir 实现的，其函数依赖于输入数据的预定义格式。字符串函数期望第一个参数是一个二进制字符串，而列表函数期望第一个参数是一个列表。  

此外，修改函数（即转变数据的函数）返回相同类型的数据。函数 `String.upcase/1` 返回一个二进制字符串，而 `List.insert_at/3` 返回一个列表。  

最后，模块还包含查询函数，这些函数从数据中返回一些信息，例如 `String.length/1` 和 `List.first/1`。这些函数仍然期望以抽象实例作为第一个参数，但它们返回另一种类型的信息。  

Elixir 中抽象的基本原则可以总结如下：  

- 一个模块负责抽象某种行为。  
- 模块的函数通常期望以抽象实例作为第一个参数。
- 修饰符函数返回经过修改的抽象版本。
- 查询函数返回其他类型的数据。
  
根据这些原则，创建你自己的更高级抽象是相当简单的，正如你将在下一部分中看到的。

## 4.1 使用模型抽象

列表和字符串是低级类型，但高级抽象基于之前所述的原则。实际上，您在第二章中已经看到了高级抽象的示例。例如，`MapSet` 模块实现了一个集合。`MapSet` 是用纯 Elixir 实现的，可以作为设计 Elixir 抽象的良好模板。

我们来看一个`Mapset`的例子：

```elixir
iex(1)> days = 
...(1)> MapSet.new() |>
...(1)> MapSet.put(:monday) |>
...(1)> MapSet.put(:tuesday) 

iex(2)> MapSet.member?(days, :monday)
true
```

这种方法或多或少遵循了之前陈述的原则。通过使用管道运算符将操作串联在一起，代码得到了稍微简化。这是可能的，因为 MapSet 模块中的所有函数都将一个集合作为第一个参数。这些函数非常适合使用管道运算符（|>）进行链式调用。

请注意新的 `new/0` 函数，它用于创建该抽象的一个新实例。这个函数并没有什么特别之处，可以给它任何名称。它唯一的目的是创建一个你可以使用的新数据结构。
由于 MapSet 是一个抽象，你作为这个模块的客户端，不必关心它的内部工作原理或数据结构。你只需调用 MapSet 函数，保存得到的结果，并将其传递回同一模块的函数。

注意：你可能会认为像 MapSet 这样的抽象有点像用户定义的类型。虽然有许多相似之处，但基于模块的抽象并不是像第二章中解释的那样的真正数据类型。相反，它们是通过组合内置数据类型来实现的。例如，一个 MapSet 实例也是一个映射，你可以通过调用 `is_map(MapSet.new())` 来验证。

给定这个模板，让我们试着构建一个简单的抽象。

### 4.1.1 Basic abstraction

本节中的示例是一个简单的待办事项列表。问题确实不算壮观，但它足够复杂，可以让你有东西可以练习，同时又不会过于复杂。这将使你能够专注于技术，而不会花太多时间去理解问题本身。

待办事项列表的基本版本将支持以下功能：
- 创建新的待办事项列表 
- 向列表添加新条目
- 查询列表
 
以下是所需用法的示例：

```shell
$ iex simple_todo.ex
```

```elixir 
iex(1)> todo_list =
          TodoList.new() |>
          TodoList.add_entry(~D[2023-12-19], "Dentist") |>
          TodoList.add_entry(~D[2023-12-20], "Shopping") |>
          TodoList.add_entry(~D[2023-12-19], "Movies")
 
iex(2)> TodoList.entries(todo_list, ~D[2023-12-19])
["Movies", "Dentist"]
 
iex(3)> TodoList.entries(todo_list, ~D[2023-12-18])
[]
```

这很简单明了。您通过调用 `TodoList.new/0` 创建一个实例，然后添加一些条目。最后，您执行一些查询。表达式 `~D[2023-12-19]`，如第 2.4.11 节所解释，创建了一个日期（2023 年 12 月 19 日），由 `Date` 模块提供支持。

随着章节的推进，您将添加更多功能并稍微修改接口。您将在本书中持续添加功能，最终将拥有一个完全可用的分布式网络服务器，能够管理大量的待办事项列表。现在，让我们从这个简单的接口开始。

首先，您必须决定内部数据的表示。在前面的代码片段中，您可以看到主要的用例是查找单个日期的所有条目。因此，使用映射似乎是合理的初步方法。您将使用日期作为键，值为给定日期的条目列表。考虑到这一点，`new/0` 函数的实现非常简单。”

```elixir
# 清单4.1 Initializing a to-do list(simple_todo.ex)
defmodule TodoList do
  def new(), do: %{}
  ...
end
```

接下来，您必须实现 `add_entry/3` 函数。这个函数期望一个待办事项列表（您知道它是一个映射），并必须在给定的键（日期）下将条目添加到列表中。当然，可能该日期没有任何条目，因此您需要处理这种情况。实际上，这可以通过一次调用 `Map.update/4` 函数来完成。

```elixir
# 清单4.2 Adding an entry(simple_todo.ex)
defmodule TodoList do
  ...
  def add_entry(todo_list, date, title) do
    Map.update(
        todo_list,
        date,
        [title],
        fn titles -> [title | titles] end
    )
    end 
    ...
end
```

`Map.update/4` 函数接收一个映射，一个键，一个初始值和一个更新函数。如果给定的键不存在值，则使用初始值；否则，将调用更新函数。该函数接收现有的值并返回该键的新值。在这种情况下，您将新条目推送到列表的顶部。您可能还记得在第二章中，列表在将新元素推送到顶部时效率最高。因此，您选择快速插入操作，但牺牲了顺序——最近添加的条目放在列表中较旧条目之前。最后，您需要实现 `entries/2` 函数，返回给定日期的所有条目，或者如果该日期没有任务则返回空列表。这是相当简单直接的，如下所示。

```elixir
#  清单4.3 Querying the to-do list(simple_todo.ex)
defmodule TodoList do
  ...
  def entries(todo_list, date) do
    Map.get(todo_list, date, [])
  end
end
```

你从 `todo_list` 中获取给定日期的值，`todo_list` 必须是一个映射。`Map.get/3` 的第三个参数是一个默认值，如果给定的键在映射中不存在，则返回这个默认值。

### 4.1.2 编写抽象

没有什么可以阻止你在一个抽象的基础上创建另一个抽象。在我们对待办事项列表的初步实现中，有机会将一些代码移到一个单独的抽象中。观察你如何在映射上操作，允许多个值存储在一个键下，并检索该键的所有值。这段代码可以移到一个单独的抽象中。我们称这个为 MultiDict，它将在下一个列表中实现。

```elixir
# 清单4.4 Implementing the MultiDict abstaction(todo_multi_dict.ex)

defmodule TodoList do
  def new(), do: MultiDict.new()
 
  def add_entry(todo_list, date, title) do
    MultiDict.add(todo_list, date, title)
  end
 
  def entries(todo_list, date) do
    MultiDict.get(todo_list, date)
  end
end
```

这是经典的关注点分离（Separation of Concerns），在这里，你将一个独特的责任提取到一个单独的抽象中，然后在其上创建另一个抽象。一个独特的 MultiDict 抽象现在可以在代码的其他地方使用（如果需要的话）。此外，你可以为 TodoList 扩展一些特定于待办事项的附加功能，这些功能因此不属于 MultiDict。此重构的目的是为了说明代码组织与面向对象（OO）方法并没有根本性的不同。你使用不同的工具来创建抽象（模块和函数，而不是类和方法），但总体思路是相同的。

### 4.1.3 使用映射结构化数据

 TodoList 现在支持基本功能。你可以将条目插入结构并获取特定日期的所有条目，但接口有些笨重。当添加新条目时，你必须将每个字段作为单独的参数进行指定:

 ```elixir
TodoList.add_entry(todo_list, ~D[2023-12-19], "Dentist")
 ```

 如果你想为条目添加另一个属性——例如时间——你必须更改函数的签名，这将导致所有客户端出现问题。此外，你还必须更改实现中传播该数据的每个地方。解决此问题的一个明显方案是以某种方式将所有条目字段组合成一个单一的抽象。

 正如在第 2.4.6 节中所解释的，在 Elixir 中，最常见的做法是使用映射，将字段名存储为原子类型的键。以下代码片段演示了如何创建和使用一个条目实例：

 ```elixir
iex(3)> entry = %{data: ~D[2023-12-19], title: "Dentist"}

iex(4)> entry.data
~D[2023-12-19]
iex(5)> entry.title
"Dentist"
 ```

 你可以很容易地调整你的代码，以使用映射来表示条目。事实证明，这个更改非常简单。你只需修改 `TodoList.add_entry` 函数的代码，使其接受两个参数：一个待办事项列表实例和一个描述条目的映射。下面的列表展示了新版本。

 ```elixir
# 清单4.6 Representing entries with maps ( todo_entry_map.ex)
defmodule TodoList do
  ...
  def add_entry(todo_list, entry) do
    MultiDict.add(todo_list, entry.date, entry)
  end
end
 ```

那很简单！你假设一个条目是一个映射，并使用它的日期字段作为键，把它添加到MultiDict中。让我们看看这个如何运作。现在，客户必须提供一个映射来添加新条目:

```elixir
todo_list = 
  TodoList.new() 
  |>TodoList.add_entry(%{date: ~D[2023-12-19], title: "Dentist"})
```

当前的 TodoList 实现依赖于一个映射。这意味着在运行时，无法区分映射和 TodoList 实例。在某些情况下，你可能希望定义并强制实施更精确的结构定义。对于这种情况，Elixir 提供了一种称为结构体（structs）的特性。

### 4.1.4 使用结构体抽象

假设你需要在你的程序中处理分数。分数是一个整体的部分，表示为 a/b 的形式，其中 a 和 b 是称为分子和分母的整数。单独传递这两个值既繁琐又容易出错。因此，引入一个小的抽象来帮助处理分数是有意义的。下面的代码片段演示了如何使用这样的抽象：

```shell
iex fraction.ex
```

```elixir
iex(1)> Fraction.new(1, 2) |>
        Fraction.add(Fraction.new(1,4)) |>
        Fraction.value()
```

在这里，你需要将二分之一（1/2）与四分之一（1/4）相加，并返回结果的数值。分数是通过使用 `Fraction.new/2` 创建的，然后传递给知道如何处理它的各种其他函数。

你可以如何实现这一点呢？有许多方法，例如依赖于普通元组或使用映射。此外，Elixir 提供了一种叫做结构体（structs）的功能，它允许你提前定义抽象结构并将其绑定到一个模块。每个模块只能定义一个结构体，然后可以用来创建新实例并对其进行模式匹配。分数有一个明确的结构，因此你可以使用结构体来指定和强制数据的形状。让我们看看如何实现。要定义一个结构体，

请使用 `defstruct` 宏（https://hexdocs.pm/elixir/Kernel.xhtml#defstruct/1）。

```elixir
# Listing 4.7 Defining a structure (fraction.ex)
defmodule Fraction do
  defstruct a: nil, b: nil
  ...
end
```

提供给 `defstruct` 的关键词列表定义了结构体的字段及其初始值。现在，您可以使用这种特殊语法来实例化一个结构体:

```elixir
iex(2)>one_half = %Fraction{a: 1, b: 2}
```

请注意，结构体的名称与其定义的模块相同。结构体与模块之间有着紧密的关系。一个结构体只能存在于一个模块中，而一个模块可以定义多个结构体。内部上，结构体是一种特殊类型的map。因此，单个字段的访问方式与map相同:

```elixir
iex(3)>one_half.a
1

iex(4)>one_half.b
2
```

结构体的一个好处是你可以对它们进行模式匹配:

```elixir
iex(5)>%Fraction{a: a, b: b} = one_half

iex(6)> a
1
```

这使得我们可以断言某个变量确实是一个结构体:

```elixir
iex(7)>%Fraction{} = one_half
%Fraction{a: 1, b: 2}

iex(8)> %Fraction{} = %{a: 1, b: 2}
**(MatchError)....**
```

在这里，您使用 `⁠%Fraction{}` 模式，它可以匹配任何 `⁠Fraction` 结构体，无论其内容如何。结构体的模式匹配与map的模式匹配非常相似。这意味着在模式匹配时，您只需要指定您感兴趣的字段，忽略其他所有字段。更新结构体的方式与更新map的方式类似：

```elixir
iex(9)>one_quarter = %Fraction{one_half | b: 4}
%Fraction{a: 1, b: 4}
```

这段代码基于原始的结构体实例（⁠one_half）创建了一个新的结构体实例，将字段 `⁠b` 的值更改为 `4`。

结构体的形状在编译时定义。因此，某些错误可以被 Elixir 编译器捕获。例如，假设我们在字段名称中输入了一个错字：

```elixir
iex(10)>%Fraction{a: 1, d: 2}
**(KeyError) key :d not found**
```

结构体没有指定字段 `:d`，因此报告了错误。相比之下，如果您使用常规的映射，这段代码会成功。然而，程序可能在远离此处的地方因不明显的原因失败，这会使错误更难调试。

值得注意的是，这个错误是在编译时报告的。如果您在源文件中犯同样的错误，代码甚至不会编译。掌握了这些知识后，让我们为`Fraction`抽象添加一些功能。首先，您需要提供创建函数。

```elixir
# Listing 4.8 Instantiating a fraction (fraction.ex)
defmodule Fraction do
  ...
  def new(a, b) do
    %Fraction{a: a, b: b}
  end
  ...
end
```

这是一个简单的包装器，围绕着 `%Fraction{}` 语法。它使客户端代码更清晰，并减少了与使用结构体这一事实的耦合。

接下来，实现一个 `Fraction.value/1` 函数，该函数返回分数的浮点表示。

```elixir
# Listing 4.9 Calculating the fraction value (fraction.ex)
defmodule Fraction do
  ...
  def value(%Fraction{a: a, b: b}) do
   a / b
  end
  ...
end
```

`value/1` 函数匹配一个分数，将其字段分解成单独的变量，并利用这些变量计算最终结果。模式匹配的好处在于输入类型是强制的。如果你传递任何不是分数实例的东西，你会得到一个匹配错误。除了将字段分解为变量外，你还可以使用点标记法：

```elixir
def value(fraction) do
  fraction.a / fraction.b
end
```

这个版本可以说更清晰，但另一方面，它接受任何映射，而不仅仅是` Fraction` 结构体，这可能会导致微妙的错误。例如，假设有一个具有相同字段的 `⁠Rectangle` 结构体。你可能会不小心将这样的结构体传递给这个函数，而不是失败，函数会返回一些无意义的结果。

最后一件事情是实现 `⁠add` 函数。

```elixir
# Listing 4.10 Adding two fractions (fraction.ex)
defmodule Fraction do
  ...
  def add(%Fraction{a: a1, b: b1}, %Fraction{a: a2, b: b2})
do
  new(
    a1 * b2 + a2 * b1,
    b2 * b1
  )
  end
  ...
end
```

可以测试Fraction：

```elixir
iex(1)> Fraction.new(1, 2)
        |> Fraction.add(Fraction.new(1, 4))
        |> Fraction.value()
```

这段代码按预期工作。通过使用结构体表示分数，你可以定义你的类型，列出所有字段及其默认值。此外，你可以将结构体实例与其它数据类型区分开来。这使你能够在函数参数中放置 %Fraction{} 匹配，从而确保只接受分数实例。

**Structs vs. Maps**

你应该始终意识到，结构体（struct）仅仅是映射（map），因此它们在性能和内存使用方面具有相同的特性。但是，结构体实例会受到特殊处理。有些可以在映射上执行的操作在结构体上无法进行。例如，你不能在结构体上调用枚举（Enum）函数：

```elixir
iex(1)> one_half = Fraction.new(1, 2)
 
iex(2)> Enum.to_list(one_half)
** (Protocol.UndefinedError) protocol Enumerable not implemented for
  %Fraction{a: 1, b: 2}
```

请记住，结构体是一种功能抽象，因此应根据其定义的模块的实现进行操作。在`Fraction`抽象的情况下，您必须定义Fraction是否可枚举，如果可以，具体以何种方式。如果不这样做，Fraction就不是可枚举的，因此您无法在其上调用 Enum 函数。

相比之下，普通的映射是可枚举的，因此您可以将其转换为列表:

```elixir
Enum.to_list(%{a: 1, b: 2})
```

另一方面，因为结构体实际是map，可以直接调用`Map`函数：

```elixir
Map.to_list(one_half)
[__struct__: Fraction, a: 1, b: 2]
```

注意 `__struct__: Fraction` 。这个键值对会自动包含在每个结构体中。它帮助 Elixir 区分结构体和普通映射，并在多态泛型代码中执行正确的运行时分发。您稍后会了解更多，当我们描述协议时。

`struct` 字段对模式匹配有一个重要的影响。结构体模式不能匹配普通映射：

```elixir
%Fraction{a: a, b: b} = %{a: 1, b: 2}
** (MatchError) no match of right hand side value: %{a: 1, b: 2}
```

但是map可以模式匹配struct：

```elixir
%{a: a, b: b} = %Fraction{a: 1, b: 2}
%Fraction{a: 1, b: 2}
```

这是由于模式匹配与映射的工作方式造成的。请记住，模式中的所有字段必须存在于匹配的术语中。当将一个映射与结构模式匹配时，情况并非如此，因为 `%Fraction{}` 包含字段结构，而在要匹配的映射中并不存在。反之则成立，因为您将结构匹配到 `%{a: a, b: b}` 模式中。由于这些字段都存在于 `Fraction` 结构中，因此匹配成功。

**RECORDS**

除了映射和结构体，还有另一种结构数据的方法：Records。这个功能允许你使用元组，同时还能通过名称访问单独的元素。记录可以通过 `Record `模块中的 `defrecord` 和 `defrecordp` 宏来定义（https://hexdocs.pm/elixir/Record.xhtml）。由于它们本质上是元组，记录应该比映射更快（尽管在整体上，差异通常不是很明显）。另一方面，使用起来更为冗长，并且无法动态通过名称访问字段。

Record主要是出于历史原因存在。在使用map之前，record是结构化数据的主要工具之一。实际上，许多来自Erlang生态系统的库使用record作为它们的接口。如果你需要使用一个在该库中定义的记录来接口一个Erlang库，你必须将这个record导入Elixir并将其定义为一个record。这可以通过使用`Record.extract/2`函数和`defrecord`宏来完成。这个用法并不常见，所以在这里不会展示record。不过，将这些信息记在心中，并在需要时进行研究可能会很有用。

### 4.1.5 Data transparency

到目前为止，您所设计的模块都是抽象的，因为客户端不清楚其实现细节。例如，作为客户端，您调用 `Fraction.new/2` 来创建该抽象的实例，然后将该实例传回同一模块中的其他函数。

但整个数据结构始终是可见的。作为客户端，您可以获取单个分数值，即使这不是库开发者所期望的。

重要的是要意识到，在Elixir中，数据始终是透明的。客户端可以从您的结构体（以及任何其他数据类型）中读取任何信息，而且没有简单的方法可以阻止这一点。从这个意义上说，封装的工作方式与典型的面向对象语言不同。在Elixir中，模块负责抽象数据并提供操作以操纵和查询这些数据，但数据从未被隐藏。

我们在shell中验证下：

```elixir
iex(1)>todo_list = TodoList.new() |>
          TodoList.add_entry(%{date: ~D[2023-12-19], title: "Dentist"})
 
%{~D[2023-12-19] => [%{date: ~D[2023-12-19], title: "Dentist"}]}
```

查看返回值，您可以看到待办事项列表的整体结构。从输出中，您可以立即知道待办事项列表是由映射实现的，并且您还可以找到有关如何保存每个条目的详细信息。

让我们看看另一个例子。`MapSet` 实例也是一种抽象，由 `MapSet` 模块和相应的结构体提供支持。乍一看，这一点并不明显:

```elixir
iex(1)> mapset = MapSet.new([:monday, :tuesday])
MapSet.new([:monday, :tuesday])
```

注意表达式的结果以特别的方式打印，`使用了 MapSet.new(...)` 的输出。这是因为 Elixir 的检查机制：每当结果在终端打印时，都会调用函数 Kernel.inspect/1 将结构转换成一个经过检查的字符串。对于你构建的每个抽象，你可以覆盖默认行为并提供你自己的检查格式。这正是 MapSet 所做的，你将在本章稍后了解如何对一个类型这样做，当我们讨论协议时

偶尔，您可能希望查看纯数据结构，而不带有这种修饰的输出。当您进行调试、分析或逆向工程代码时，这可能非常有用。为此，您可以向 `inspect` 函数提供一个特殊的选项:

```elixir
iex(2)> IO.puts(inspect(mapset, structs: false))
%{__struct__: MapSet, map: %{monday: [], tuesday: []}, version: 2}
```

输出现在显示了日期的完整结构，你可以“透视” MapSet 抽象。这表明数据隐私在 Elixir 中无法完全实施。请记住，在第二章中提到的唯一复杂类型是元组、列表和映射。任何其他抽象，如 MapSet 或你自己的 TodoList，最终都会建立在这些类型之上。

数据透明的好处是数据可以被轻松检查，这对调试目的很有用。但作为一个抽象的客户端，你不应该依赖于它的内部表示，尽管对你是可见的。你不应该对内部结构进行模式匹配，也不应该尝试提取或修改其个别部分，因为像 MapSet 这样的适当抽象并不保证数据的外观。唯一的保证是，如果你向模块发送一个已经从该模块收到了的恰当结构的实例，模块的函数就会正常工作。

有时，某个模块会公开文档一些其内部结构的部分。很好的例子是日期和时间模块，如 Date、Time 和 DateTime。查看文档时，你会看到明确提到相应数据作为结构表示，使用字段如年份、月份、小时等。在这种情况下，数据的结构是公开文档的，你可以放心依赖它。

关于数据检查，你还应该知道一个最后的事情，即 IO.inspect/1 函数。这个函数将结构的检查结果打印到屏幕上，并返回结构本身。这在调试一段代码时特别有用。看看以下例子：

```elixir
iex(1)> Fraction.new(1, 4) |>
          Fraction.add(Fraction.new(1, 4)) |>
          Fraction.add(Fraction.new(1, 2)) |>
          Fraction.value()
1.0
```

这段代码依赖管道操作符来执行一系列的分数操作。假设你想在每一步之后检查整个结构。你可以很容易地在每行之后插入对 `IO.inspect/1 `的调用:

```elixir
“iex(2)> Fraction.new(1, 4) |>
          IO.inspect() |>
          Fraction.add(Fraction.new(1, 4)) |>
          IO.inspect() |>
          Fraction.add(Fraction.new(1, 2)) |>
          IO.inspect() |>
          Fraction.value()
 
%Fraction{a: 1, b: 4}     
%Fraction{a: 8, b: 16}    
%Fraction{a: 32, b: 32}   
```

这是因为 `IO.inspect/1` 打印数据结构，然后返回相同的数据结构，保持不变。你还可以查看 `dbg` 宏（https://hexdocs.pm/elixir/Kernel.xhtml#dbg/2），它有点相似，但提供了更多的调试功能。

我们现在已经完成了关于函数抽象的基本理论，但你将通过扩展待办事项列表进行更多的实践。


## 4.2 处理层次数据

在这一部分中，您将扩展 TodoList 抽象，以提供基本的 CRUD 支持。您已经通过 `add_entry/2` 和 `entries/2` 函数解决了 C 和 R 部分。现在，您需要增加更新和删除条目的支持。为此，您必须能够唯一识别待办事项列表中的每个条目，因此您将首先为每个条目添加唯一的 ID 值。

### 4.2.1 生成IDs

当向列表中添加新条目时，您将自动生成其 ID 值，使用递增的整数作为 ID。为了实现这一点，您需要做几件事：
- 将待办事项列表表示为一个结构体。这是因为待办事项列表现在需要保存两条信息：条目集合和下一个条目的 ID 值。
- 使用条目的 ID 作为键。到目前为止，当在集合中存储条目时，您使用的是条目的日期作为键。您将更改这一点，改为使用条目的 ID。这将使您能够快速插入、更新和删除单个条目。每个键现在将恰好有一个值，因此您不再需要 `MultiDict` 抽象。
让我们开始实现这一点。以下列表中的代码包含模块和结构体定义。

```elixir
# Listing 4.11 TodoList struct (todo_crud.ex)
defmodule TodoList do
  defstruct next_id: 1, entries: %{}

  def new(), do: %TodoList{}
  ...
end
```

待办事项列表现在将作为一个结构体表示，包含两个字段。字段 `next_id` 包含将分配给新条目的 ID 值，字段 `entries` 是条目的集合。如前所述，您现在使用的是一个映射，键是条目 ID 值。

在结构体定义时，next_id 和 entries 字段的默认值会立即指定。因此，您在创建新实例时不必提供这些值。new/0 函数创建并返回一个结构体的实例


接下来，是时候重新实现 `add_entry/2` 函数了。它需要完成更多的工作：
- 设置要添加的条目的 ID；
- 将新条目添加到集合中；
- 递增 next_id 字段。
 
以下是代码:

```elixir
# Listing 4.12 Autogenerating ID values for new entries(todo_crud.ex)
defmodule TodoList do
  ...
  def add_entry(todo_list, entry) do
    entry = Map.put(entry, :id, todo_list.next_id)
    
    new_entries = Map.put(
      todo_list.entries,
      todo_list.next_id,
      entry
    )
    
    %TodoList{todo_list |
       entries: new_entries,
       next_id: todo_list.next_id + 1
     }
  end
     ...
end
```

这里发生了很多事情，所以我们一步一步来。

在函数体内，您首先用 next_id 字段中存储的值更新条目的 id 值。请注意，您使用` Map.put/3` 来更新条目映射。输入映射可能不包含 id 字段，因此您不能使用标准的 `%{entry | id: next_id}` 技术，因为这只在 id 字段已经存在于映射中时有效。在条目更新后，您将其添加到 entries 集合中，将结果保存在 new_entries 变量中。

最后，您必须更新 TodoList 结构体实例，将其 entries 字段设置为 new_entries 集合，并增加 next_id 字段。实质上，您对结构体进行了复杂更改，修改了多个字段以及输入条目（因为您设置了其 id 字段）。

对于外部调用者来说，整个操作将是原子的。要么一切都发生，要么在发生错误的情况下，什么都不会发生。这是不可变性的结果。添加条目的效果只有在 add_entry/2 函数完成并将其结果赋值给变量时才会对其他人可见。如果出现问题并引发错误，则任何变换的效果都不会可见。

值得重申的是，如第二章所述，新的待办事项列表（由 add_entry/2 函数返回的那个）将尽可能多地与输入待办事项列表共享内存。

在 add_entry/2 函数完成后，您需要调整 entries/2 函数。这将更复杂，因为您更改了内部结构。之前，您保持了日期到条目的映射。现在，条目使用 id 作为键进行存储，因此您必须遍历所有条目并返回在给定日期的条目。

```elixir
# Listing 4.13 Filtering entries for a given data (todo_crud.ex)
defmodule TodoList do
  ...
  def entries(todo_list, date) do
    todo_list.entries
    |> Map.values()
    |> Enum.filter(fn entry  -> entry.date == date end)
  end
  ...
end
```

这个函数首先使用 `Map.values/1` 从 entries 映射中获取条目。然后，使用 `Enum.filter/2` 仅选取落在给定日期的条目。

你可以检查你的新版本待办事项列表是否工作正常：

```elixir
$ iex todo_crud.ex
 
iex(1)> todo_list = TodoList.new() |>
          TodoList.add_entry(%{date: ~D[2023-12-19], title: "Dentist"}) |>
          TodoList.add_entry(%{date: ~D[2023-12-20], title: "Shopping"}) |>
          TodoList.add_entry(%{date: ~D[2023-12-19], title: "Movies"})
 
iex(2)> TodoList.entries(todo_list, ~D[2023-12-19])
[
  %{date: ~D[2023-12-19], id: 1, title: "Dentist"},
  %{date: ~D[2023-12-19], id: 3, title: "Movies"}
]
```

这个工作如预期一样，您甚至可以看到每个条目的 ID 值。还请注意，TodoList 模块的接口与以前的版本相同。您进行了许多内部修改，改变了数据表示，几乎重写了整个模块。然而，由于您保持了函数的相同接口，模块的客户端不需要进行修改。这并不是什么革命性的事情——这是通过合理选择的接口来封装行为的经典好处。然而，这展示了当处理无状态模块和不可变数据时，您如何构建和推理更高层次的类型。

### 4.2.2 更新实体

现在您的条目已经有了 ID 值，您可以添加额外的修改操作。让我们实现 update_entry 操作，它可以用来修改待办事项列表中的单个条目。此函数将接受一个条目 ID 和一个更新的 lambda，该 lambda 将被调用以更新条目。这将类似于 Map.update。该 lambda 将接收原始条目并返回其修改版本。为了简单起见，如果给定 ID 的条目不存在，该函数不会引发错误。

下面的代码片段演示了用法。在这里，您可以修改ID值为1的条目的日期：

```elixir
iex(1)> TodoList.update_entry(
          todo_list,
          1,                                    
          &Map.put(&1, :date, ~D[2023-12-20])    
        )
```

实现详见以下列表:

```elixir
# Listing 4.14 Updating an entry (todo_crud.ex)
defmodule TodoList do
  ...

  def update_entry(todo_list, entry_id, updater_fun) do
    case Map.fetch(todo_list.entries, entry_id) do
      :error ->                              
        todo_list
 
      {:ok, old_entry} ->                    
        new_entry = updater_fun.(old_entry)
        new_entries = Map.put(todo_list.entries, new_entry.id, new_entry)
        %TodoList{todo_list | entries: new_entries}
    end
  end
 
  ...
end
```

让我们来分析这里发生了什么。首先，你使用 `Map.fetch/2` 查找具有给定 ID 的条目。如果条目不存在，函数将返回 `:error`；否则，它将返回 `{:ok, value}`。

在第一种情况下，如果条目不存在，你返回列表的原始版本。否则，你必须调用更新器 lambda 来获取修改后的条目。然后，你将修改后的条目存储到条目集合中。最后，将修改后的条目集合存储到 TodoList 实例中并返回该实例。

### 4.2.3 不可变层次更新

你可能没有注意到，但在前面的例子中，你对一个不可变的层次进行了深度更新。让我们分析一下当你调用 `⁠TodoList.update_entry(todo_list, id, updater_lambda)` 时发生了什么：

1. 你将目标条目放入一个单独的变量中。
2. 你调用更新器，它返回修改后的条目。
3. 你调用 ⁠Map.put 将修改后的条目放入条目集合中。
4. 你返回新版本的待办事项列表，其中包含新的条目集合。

```elixir
iex(1)> todo_list = %{
  1 => %{date: ~D[2023-12-19], title: "Dentist"},
  2 => %{date: ~D[2023-12-20], title: "Shopping"},
  3 => %{date: ~D[2023-12-19], title: "Movies"}
}
```

现在，假设你改变主意，想去剧院而不是看电影。你可以优雅地使用 `Kernel.put_in/2` 宏来修改原始结构：

```elixir
iex(2)> put_in(todo_list[3].title, "Theater")       
 
%{
  1 => %{date: ~D[2023-12-19], title: "Dentist"},
  2 => %{date: ~D[2023-12-20], title: "Shopping"},
  3 => %{date: ~D[2023-12-19], title: "Theater"}    
}
```

发生了什么？在内部，`put_in/2` 做的事情类似于你所做的。它递归地遍历到目标元素，进行转换，然后更新所有的父元素。请注意，这仍然是一个不可变的操作，这意味着原始结构保持不变，结果必须赋值给一个变量。为了能够进行递归遍历，`put_in/2` 需要接收源数据和目标元素的路径。在前面的例子中，源数据是 todo_list，路径被指定为 [3].title。

宏` put_in/2` 然后沿着该路径向下遍历，在返回时重建新的层级结构。

值得注意的是，Elixir 提供了类似的替代方法用于数据检索和更新，这些方法包括 `get_in/2`、`update_in/2` 和 `get_and_update_in/2` 宏。这些是宏意味着你提供的路径在编译时评估，不能动态构建。

如果你需要在运行时构建路径，有等效的函数可以单独接收数据和路径作为参数。例如，Elixir 还包括了 `put_in/3` 宏，可以如下使用：

```elixir
iex(3)> path = [3, :title]
 
iex(4)> put_in(todo_list, path, "Theater")
```

例如 `put_in` 的函数和宏依赖于 Access 模块，该模块允许您处理键值结构，例如映射。您还可以创建自己的抽象以与 Access 一起使用。您需要实现 Access 合同所要求的几个函数，然后 put_in 及相关宏和函数就会知道如何与您的抽象进行工作。有关更多详细信息，请参阅官方的 Access 文档（https://hexdocs.pm/elixir/Access.xhtml）。

**Exercise : Defining an entry**

你的待办事项模块几乎完成了。你已经实现了创建（add_entry/2）、检索（entries/2）和更新（update_entry/3）操作。最后要实现的是删除（delete_entry/2）操作。这很简单，留给你作为练习。如果你遇到困难，解决方案在源文件 todo_crud.ex 中提供。

### 4.2.4 Iterative updates

到目前为止，您一直在手动逐个进行更新。现在，是时候实现迭代更新了。想象一下，您有一个描述条目的原始列表：

```shell
$ iex todo_builder.ex
```

```elixir
iex(1)> entries = [
          %{date: ~D[2023-12-19], title: "Dentist"},
          %{date: ~D[2023-12-20], title: "Shopping"},
          %{date: ~D[2023-12-19], title: "Movies"}
        ]
```

现在，您想创建一个包含所有这些条目的待办事项列表的实例：

```elixir
iex(2)> todo_list = TodoList.new(entries)
```

显然，`new/1` 函数执行了待办事项列表的迭代构建。你如何实现这样的一个函数呢？其实，这很简单。


```elixir
defmodule TodoList do
  ...
  def new(entries \\ []) do
    Enum.reduce(
        entries,
        %TodoList{},
        fn entry, todo_list_acc ->
          add_entry(todo_list_acc, entry)
        end
    )
  end
  ...
end
```

为了迭代地构建待办事项列表，你依赖于 `Enum.reduce/3`。回想第三章，reduce 用于将可枚举的东西转换为其他任何东西。在这个例子中，你将一组原始的 Entry 实例转换为一个 TodoList 结构体的实例。因此，你调用 `Enum.reduce/3`，将输入列表作为第一个参数，将新的结构体实例作为第二个参数（初始累加器值），并传入在每一步中调用的 Lambda 函数。这个 Lambda 函数会对输入列表中的每个条目进行调用。它的任务是将条目添加到当前累加器（TodoList 结构体）中，并返回新的累加器值。为此，Lambda 函数委托给已经存在的 add_entry/2 函数，并且反转参数顺序。参数需要反转，因为 Enum.reduce/3 调用 Lambda 函数时，传入的参数是迭代元素（条目）和累加器（TodoList 结构体）。而 add_entry 则接受结构体和条目作为参数。

请注意，您可以借助捕获操作符使 lambda 定义更加紧凑:

```elixir
def new(entries \\ []) do
  Enum.reduce(
    entries,
    %TodoList{},
    &add_entry(&2,&1)
  )
end
```

您使用这个版本还是之前的版本完全取决于个人喜好。


### 4.2.5 练习： 导入一个文件

现在，是时候让您练习一下了。在这个练习中，您将从一个以逗号分隔的文件中创建一个 TodoList 实例。

假设您在当前文件夹中有一个 `todos.csv` 文件。文件中的每一行描述一个单独的待办事项条目:

```csv
2023-12-19,Dentist
2023-12-20,Shopping
2023-12-19,Movies
```

您的任务是创建一个额外的模块，`TodoList.CsvImporter`，能够用于根据文件内容创建TodoList实例:

```elixir
todo_list = TodoList.CsvImporter.import("to-dos.csv")
```

为了简化任务，假设文件总是可用且格式正确。同时假设逗号字符不会出现在条目标题中。

这通常并不难，但可能需要一些破解和实验。以下是一些可以指引你正确方向的提示。

首先，创建一个具有以下布局的单个文件：

```elixir
defmodule TodoList do
  ...
end

defmodule TodoList.CsvImporter do
  ...
end
```

始终以小步骤进行工作。先实现部分计算，然后使用 `IO.inspect/1` 将结果打印到屏幕上。我无法强调这一点有多重要。这个任务需要一些数据管道处理。逐步工作将使你能够逐渐推进，并验证自己是否在正确的轨道上。

你应该采取的一般步骤如下：

1. 打开一个文件，遍历它，并删除每一行的 `\n`。提示：使用 `File.stream!/1`、`Stream.map/2` 和 `String.trim_trailing/2`。你在第三章中做过这个，当时我们讨论了流，在过滤超过80个字符的行的例子中。
2. 使用 `Stream.map`，将从上一步获得的每一行转换为待办事项条目。
   1.  将该行转换为 `[date_string, title]` 列表，使用 `String.split/2`。
   2.  将日期字符串转换成日期，使用`Date.from_iso8601!`
   3.  创建一个待办事项的entry `%{date: date, title: title}`

步骤2的输出是一个包含待办事项的可枚举对象。将该可枚举对象传递给你最近实现的 `TodoList.new/1` 函数。

在每个步骤中，您将接收一个可枚举对象作为输入，转换每个元素，并将生成的可枚举对象传递给下一步。在最后一步，将生成的可枚举对象传递给已实现的 `TodoList.new/1`，以创建待办事项列表

如果你分步骤进行工作，就不容易迷路。例如，你可以从打开一个文件并将每一行打印到屏幕上开始。然后，尝试去掉每行末尾的换行符并将它们打印到屏幕上，依此类推。

在每一步转换数据时，你可以使用 Enum 函数或 Stream 模块中的函数。最好是先使用 Enum 模块中的急切函数，并让整个过程正常工作。然后，尝试尽可能多地用 Stream 对应的函数替换 Enum 函数。请回想一下第三章，Stream 函数是惰性的和可组合的，这可以减少操作所需的中间内存。如果你迷失方向，可以在 todo_import.ex 文件中找到解决方案。

与此同时，我们的高级抽象探索快要结束了。最后一个主题是我们将简单讨论 Elixir 中的多态性。

## 4.3 使用协议的多台

多态是关于在运行时根据输入数据的性质决定执行哪个代码的过程。在 Elixir 中，基本的（但不是唯一的）实现方法是使用一种叫做协议的语言特性。

在讨论协议之前，让我们先看看它们的实际应用。你已经见过多态代码。例如，整个 Enum 模块是适用于任何可枚举对象的通用代码，以下代码片段说明了这一点：

```elixir
Enum.each([1, 2, 3], &IO.inspect/1)
Enum.each(1..3, &IO.inspect/1)
Enum.each(%{a: 1, b: 2}, &IO.inspect/1)
```

注意你如何使用相同的 `Enum.each/2` 函数，传递不同的数据结构：列表、范围和映射。`Enum.each/2` 是怎么知道如何遍历每个结构的？其实它并不知道。`Enum.each/2` 中的代码是通用的，并依赖于一个契约。这个契约称为协议（protocol），必须为你希望与 Enum 函数一起使用的每种数据类型实现该协议。接下来，让我们学习如何定义和使用协议。

### 4.3.1 协议基础

在协议中，您声明函数而不实现它们。可以将其视为面向对象接口的粗略等价物。通用逻辑依赖于协议并调用其函数。然后，您可以为不同的数据类型提供协议的具体实现。我们来看一个例子。Elixir 标准库提供的协议 `String.Chars` 用于将数据转换为二进制字符串。这是协议在 Elixir 源代码中的定义：

```elixir
defprotocol String.Chars do    
  def to_string(term)          
end
```

这类似于模块定义，显著的区别在于函数被声明但并没有实现。注意函数的第一个参数（术语）。在运行时，这个参数的类型决定了被调用的实现。

让我们看看这个实际应用。Elixir已经为原子、数字和一些其他数据类型实现了协议，所以你可以进行以下调用：

```elixir
iex(1)> String.Chars.to_string(1)
"1"
 
iex(2)> String.Chars.to_string(:an_atom)
"an_atom"
```

如果协议没有为给定的数据类型实现，将会引发一个错误:

```elixir
String.Chars.to_string(TodoList.new())
** (Protocol.UndefinedError) protocol String.Chars not implemented
```

通常情况下，您不需要直接调用协议函数。更常见的情况是，有通用代码依赖于该协议。在 `String.Chars` 的情况下，这是自动导入的函数 `Kernel.to_string/1`:

```elixir
iex(4)> to_string(1)
"1"
 
iex(5)> to_string(:an_atom)
"an_atom"
 
iex(6)> to_string(TodoList.new())
** (Protocol.UndefinedError) protocol String.Chars not implemented
```

正如您所见，`to_string/1` 的行为与 `String.Chars.to_string/1` 完全相同。这是因为 `Kernel.to_string/1` 委托给 `String.Chars` 的实现。

此外，您可以将任何实现了 `String.Chars` 的内容传递给 `IO.puts/1`:

```elixir
iex(7)> IO.puts(1)
1
 
iex(8)> IO.puts(:an_atom)
an_atom

iex(9)> IO.puts(TodoList.new())
** (Protocol.UndefinedError) protocol String.Chars not implemented
```

如你所见，TodoList 的实例无法打印，因为该类型未实现 `String.Chars`。

### 4.3.2 实现协议

如何为特定类型实现协议？让我们再次参考Elixir源代码。以下代码片段为整数实现了`String.Chars`协议：

```elixir
defimpl String.Chars, for: Integer do
  def to_string(term) do
    Integer.to_string(term)
  end
end
```

您通过调用 `defimpl` 宏开始实现。然后，您指定要实现哪个协议和相应的数据类型。最后，`do/end` 块包含每个协议函数的实现。在这个例子中，实施委托给现有的标准库函数 `Integer.to_string/1`。关于 for: Type 部分需要一些解释。类型是一个原子，可以是以下别名中的任何一个：Tuple、Atom、List、Map、BitString、Integer、Float、Function、PID、Port 或 Reference。这些值对应于内置的 Elixir 类型。

另外，别名 `Any` 是允许的，这使得可以指定一个后备实现。如果某个类型没有定义协议，将会产生错误，除非在协议定义中指定了对 Any 的回退，且存在 Any 任何的实现。有关详细信息，请参考协议文档（https://hexdocs.pm/elixir/Protocol.xhtml）。

最后，也是最重要的，类型可以是任何其他任意别名（但不能是普通的简单原子）：

```elixir
defimpl String.Chars, for: SomeAlias do
  ...
end
```

如果协议函数的第一个参数是对应模块中定义的结构体，则将调用此实现。例如，您可以如下为 TodoList 实现 `String.Chars`：

```elixir
defimpl String.Chars, for: TodoList do
  def to_string(_) do
    "#TodoList"
  end
end
```

现在，您可以将待办事项列表实例传递给 IO.puts/1：

```elixir
iex(2)> IO.puts(TodoList.new())
#TodoList
```

重要的是要注意，协议的实现不需要属于任何模块。这具有重要的意义：你可以为一个类型实现协议，即使你不能修改该类型的源代码。你可以在自己代码的任何地方放置协议实现，而运行时将能够利用它。

### 4.3.3 内置协议

Elixir 附带了一些预定义的协议。最好查阅在线文档以获取完整参考 (https://hexdocs.pm/elixir)，但我们可以提及一些最重要的协议。

你已经看过 `String.Chars`，它指定了将数据转换为二进制字符串的协议。还有` List.Chars` 协议，它将输入数据转换为字符字符串（一个字符列表）。如果你想控制你的结构在调试输出中的打印方式（通过 inspect 函数），你可以实现 `Inspect` 协议。

可以说，最重要的协议是 `Enumerable`。通过实现它，你可以让你的数据结构可枚举。这意味着你可以免费使用 `Enum` 和 `Stream` 模块中的所有函数！这可能是协议有用性的最佳示范。`Enum` 和 `Stream` 都是通用模块，提供许多有用的函数，这些函数可以在你实现 Enumerable 协议后直接在你的自定义数据结构上工作。

与枚举紧密相关的是 `Collectable` 协议。回想一下第 3 章，`Collectable` 结构是可以重复添加元素的结构。`Collectable` 可以与列表推导式一起使用以收集结果，或者与 `Enum.into/2` 一起使用以将一个结构（可枚举的）的元素转移到另一个结构（可收集的）。当然，你也可以定义自己的协议并将其实现于任何可用的数据结构（你自己的或他人的）。有关更多信息，请参阅 Kernel.defprotocol/2 文档。

**Collectable TODO list**

让我们看一个更复杂的例子。你将使你的待办事项列表可收集，以便可以将其用作列表推导的目标。这是一个稍微复杂一些的例子，所以如果你第一次没有理解每个细节，不用担心。

要使抽象数据结构可收集，你必须实现相应的协议：

```elixir
defimpl Collectable, for: TodoList do
  def into(original) do
    {original, &into_callback/2}
  end
  
  defp into_callback(todo_list, {:cont, entry}) do     
    TodoList.add_entry(todo_list, entry)                
  end                                                  
                                                        
  defp into_callback(todo_list, :done), do: todo_list   
  defp into_callback(_todo_list, :halt), do: :ok        
end
```

导出函数 `⁠into/1` 是由通用代码（例如，列表推导式）调用的。在这里，您提供实现，返回 appender lambda。然后，通用代码会反复调用这个 appender lambda，以将每个元素添加到您的数据结构中。

附加函数接收一个待办事项列表和一个指令提示。如果您收到` {:cont, entry}`，则必须添加一个新条目。如果您收到 `:done`，您返回列表，此时该列表包含所有已附加的元素。最后，`:halt` 表示操作已被取消，返回值将被忽略。

让我们看看这个实际运行的效果。将之前的代码复制并粘贴到 shell 中，然后尝试以下内容：

```elixir
iex(1)> entries = [
          %{date: ~D[2023-12-19], title: "Dentist"},
          %{date: ~D[2023-12-20], title: "Shopping"},
          %{date: ~D[2023-12-19], title: "Movies"}
        ]
 
iex(2)> Enum.into(entries, TodoList.new())    
%TodoList{...}
```

通过实现 `Collectable` 协议，您实际上将 `TodoList` 抽象适配到任何依赖于该协议的通用代码，例如 `Enum.into/2` 或 `for` 

**总结**  

- 模块用于创建抽象。模块的函数用于创建、操作和查询数据。客户端可以检查整个结构，但不应依赖其形状。  
- 映射（Maps）可以用来将不同的字段组合在一个结构中。  
- 结构体（Structs）是特殊类型的映射，它允许您定义与模块相关的数据抽象。  
- 多态可以通过协议（Protocols）实现。协议定义了一个接口，供通用逻辑使用。然后，您可以为数据类型提供特定的协议实现。