# 控制流

**本章涵盖:**

- 理解模式匹配 
- 处理多子句函数 
- 使用条件表达式 
- 处理循环

现在你已经熟悉了Elixir的基本构建块，是时候看看一些语言的典型低级习惯用法了。在本章中，我们将讨论条件语句和循环。正如你所看到的，这些在许多命令式语言中工作方式有所不同。

经典的条件构造，例如`if`和`case`，通常被多子句函数所替代，并且没有像`while`那样的循环语句。但是，你仍然可以在Elixir中解决任意复杂性的问题，并且得到的代码并不比典型的面向对象解决方案复杂。

所有这些听起来可能有点激进，这就是为什么条件语句和循环在本章中会详细讨论。但是在我们开始讨论分支和循环之前，您需要了解一个重要的基本机制：模式匹配

## 3.1 模式匹配

如第二章所提到的，`=` 操作符并不是赋值。在表达式 `a = 1` 中，我们将变量 `a` 绑定到值 `1`。`=` 操作符被称为`匹配操作符`，这种类似赋值的表达式是模式匹配的一个例子。

模式匹配是 Elixir 中一个重要的概念。这是一个使复杂变量（例如元组和列表）的操作变得更加简单的特性。更不明显的是，它使您能够编写优雅的、类似声明式的条件语句和循环。您将在本章结束时了解这意味着什么。

在本节中，我们将研究模式匹配的基本机械原理。让我们首先来看看匹配操作符。

### 3.1.1 匹配操作符

到目前为止，我么见了很多匹配操作符的基本用法:

```elixir
iex(1)> person = {"Bob", 25}
```

我们把这当作类似于一个任务，但实际上，这里发生的事情更复杂。在运行时，`=` 操作符的左侧与右侧进行匹配。左侧称为模式，而右侧是一个计算为 Elixir 术语的表达式。在这个例子中，你将变量 `person` 匹配到右侧的术语 `{"Bob", 25}`。变量总是与右侧的术语匹配，并且它会绑定到该术语的值。这看起来可能有点理论化，所以我们来看一个稍微复杂一些的匹配操作符的使用，它涉及元组。

### 3.1.2 匹配元组

以下示例演示了元组的基本模式匹配:

```elixir
iex(3)> {name, age} ={"Bob",25}
{"Bob", 25}
```

这个表达式假设右侧的项是一个包含两个元素的元组。当表达式被求值时，变量 `name` 和 `age` 被绑定到元组的相应元素。你现在可以验证这些变量是否被正确绑定：

```elixir
iex(4)> name
"Bob"

iex(5)> age
25
```

这个功能在调用一个返回元组的函数时很有用，当你想把那个元组的各个元素绑定到不同的变量时。以下示例调用了Erlang函数`:calendar.local_time/0`以获取当前的日期和时间：

```elixir
iex(6)> {date, time}= :calendar.local_time()
{{2024, 9, 18}, {12, 46, 54}}
```

`date`和`time`也是元组，可以进一步解构：

```elixir
iex(2)> {y,m,d} = date
{2024, 9, 18}

iex(3)> y
2024
```

如果右侧与模式不对应，会发生什么？匹配失败，并且会引发错误:

```elixir
iex(4)> {name, age} = "can't match"
** (MatchError) no match of right hand side value: "can't match"
    (stdlib 6.0.1) erl_eval.erl:652: :erl_eval.expr/6
    iex:4: (file)
```

注意，我们尚未讨论错误处理机制——这些将在第8章中讨论。现在只需说引发错误的工作方式有点类似于主流语言中的经典异常机制。当错误被引发时，控制权会立即转移到调用链上某处的代码，这些代码会捕获该错误（假设这样的代码存在）。

最后值得注意的是，正如任何其他表达式一样，匹配表达式也会返回一个值。匹配表达式的结果始终是你正在匹配的右侧项。

```elixir
iex(4)> {name, age} = {"Bob", 22} # 匹配表达式
{"Bob", 22}                       # 匹配表达式的结果
```

### 3.1.3 匹配常量

匹配不仅限于将元组元素解构到单个变量中。令人惊讶的是，甚至常量也可以出现在匹配表达式的左侧：

```elixir
iex(1)> 1 = 1 
1
```

请记住，匹配运算符 `=` 尝试将右侧的项与左侧的模式进行匹配。在这个例子中，您试图将模式 `1` 与项 `1` 进行匹配。显然，这个匹配是成功的，整个表达式的结果是右侧的项。这个例子没有太多实际意义，但它说明您可以将常量放在 `=` 的左侧，这证明 `=` 不是赋值运算符。”

常量在复合匹配中更为有用。例如，元组有时用于将记录的各种字段分组。以下代码片段创建了一个包含个人姓名和年龄的元组。

```elixir
iex(3)> person = {:person, "Bob", 25}
```

第一个元素是一个常量原子 `:person`，你用它来表示这个元组代表一个人。之后，你可以依靠这个知识来获取这个人的各个属性。

```elixir
iex(5)>{:person, name, age} = person
```

在这里，您期望右侧的项是一个三元素元组，其第一个元素的值为`:person`。匹配后，元组的其余元素绑定到变量 `name` 和 `age`，您可以轻松验证这点。

```elixir
iex(4)> name
"Bob"
 
iex(5)> age
25
```

这是在 Elixir 中一个常见的习语。许多来自 Elixir 和 Erlang 的函数会返回 `{:ok, result}` 或 `{:error, reason}`。例如，想象一下你的系统依赖于一个配置文件，并期望它始终可用。你可以通过` File.read/1` 函数读取文件内容：

```elixir
iex(8)> {:ok, contents} = File.read("my_app.config")
```

在这一行代码中，发生了三件不同的事情：

- 尝试打开并读取文件 `my_app.config`。
- 如果尝试成功，文件的内容将被提取到变量 `contents` 中。
- 如果尝试失败，会引发一个错误。这是因为 `File.read` 的结果是一个形如 `{:error, reason}` 的元组，因此与 `{:ok, contents}` 的匹配失败。

通过在模式中使用常量，你可以严格匹配，确保右侧的某些部分具有特定的值。

### 3.1.4 模式中的变量

当一个变量名出现在左侧模式中时，它总是与相应的右侧项匹配。此外，该变量被绑定到它匹配的项。偶尔，我们并不关心右侧项的某个值，但我们仍然需要进行匹配。例如，假设你想获取当前的时间。你可以使用函数 `:calendar.local_time/0`，它返回一个元组：`{date, time}`。但你并不关心日期，因此不想将其存储到一个单独的变量中。在这种情况下，你可以使用匿名变量`（_）`：

```elixir
iex(1)> {_, time} = :calendar.local_time()

iex(2)> time
{13, 13, 13}
```

在匹配时，匿名变量的工作方式与命名变量完全相同：它可以匹配任何右侧的术语。但术语的值并没有被绑定到任何变量上。您还可以在下划线字符后添加一个描述性名称。

```elixir
iex(3)> {_date, time} = :calendar.local_time()
```

`_date` 被视为一个匿名变量，因为它的名字以下划线开头。从技术上讲，您可以在程序的其他部分使用该变量，但编译器会发出警告。

模式可以任意嵌套。进一步说，假设您只想获取当前的小时：

```elixir
iex(5)> {_, {hour, _, _}} = :calendar.local_time()

iex(6)> hour
13
```

一个变量可以在同一个模式中被引用多次。在下面的表达式中，您期望得到一个RGB三元组，其中每个组件的数值相同：

```elixir
iex(7)> {amount, amount, amount} = {127, 127, 127} # 匹配具有三个相同元素的元组
{127, 127, 127}

iex(8)> {amount, amount, amount} = {127, 127, 1}    # 失败，因为元组元素不相同
** (MatchError) no match of right hand side value: {127, 127, 1}
```

偶尔，你需要匹配变量的内容。为此，提供了pin运算符 `(^)`。最好通过一个例子来解释这一点。

```elixir
iex(1)> expected_name = "Bob"              # 与任何都匹配并绑定到`expected_name`               
"Bob"

iex(2)> {^expected_name, _} = {"Bob", 25}  # 与 expected_name 变量的内容匹配
{"Bob", 25}

iex(3)> {^expected_name, _} = {"Alice", 25}
** (MatchError) no match of right hand side value: {"Alice", 25}
```

在模式中使用 `^expected_name` 表示你期望变量 `expected_name` 的值出现在右侧项的适当位置。在这个例子中，这就相当于使用硬编码模式 `({"Bob", _} = ...)`。因此，第一个匹配成功，但第二个匹配失败。

注意，pin 操作符并不会绑定变量。你期望变量已经绑定到一个值，并尝试匹配那个值。

### 3.1.5 匹配列表

列表匹配的工作方式类似于元组。以下示例分解了一个三元素列表:

```elixir
iex(1)> [first, second, third] = [1, 2, 3]
[1, 2, 3]
```

当然，之前提到的模式技巧也同样适用

```elixir
[1, second, third] = [1, 2, 3]     # 第一个元素必须是1
[first, first, first] = [1, 1, 1]  # 每个元素都必须相同  
[first, second, _ ] = [1, 2, 3]    # 不关心第三个元素，但必须表示
[^first, second, _ ] = [1, 2, 3]   # 第一个元素必须与第一个变量相同
```

匹配列表通常依赖于其递归特性。回想第二章，每个非空列表都是一种递归结构，可以表示为 `[head | tail]` 的形式。你可以使用模式匹配将这两个元素分别放入不同的变量中:

```elixir
iex(2)> [head | tail] = [1, 2, 3]
[1, 2, 3]

iex(3)> head
1

iex(4)> tail
[2, 3]
```

如果你只需要 [头, 尾] 对中的一个元素，可以使用匿名变量。以下是计算列表中最小元素的一种低效方法：

```elixir
iex(5)> [min | _] = Enum.sort([3,2,1])
[1, 2, 3]
```

首先，你对列表进行排序，然后使用模式`[min | _]`，只取（排序后的）列表的头元素。请注意，这也可以使用第2章提到的hd函数来完成。实际上，在这种情况下，hd会更优雅。当你在第3.2节中看到模式`[head | _]`时，会发现它在模式匹配函数参数时更有用。

### 3.1.6 匹配maps

可以使用以下语法匹配maps

```elixir
iex(6)> %{name: name, age: age} = %{name: "Bob", age: 24}
%{name: "Bob", age: 24}

iex(7)> name
"Bob"

iex(8)> age
24
iex
```

在匹配映射时，左侧模式不需要包含右侧术语中的所有键:

```elixir
iex(9)> %{name: name} = %{name: "Bob", age: 24}
%{name: "Bob", age: 24}

iex(10)> name
"Bob"
```

你可能会想知道这样一个部分匹配规则的目的。地图常用于表示结构化数据。在这种情况下，你通常只对map的某些字段感兴趣。例如，在前面的代码片段中，你只想提取name字段，忽略其他所有内容。部分匹配规则正是允许你做到这一点。

当然，匹配一个不存在的key会失败：

```elixir
iex(11)> %{name: name, work: work} = %{name: "Bob", age: 24}
** (MatchError) no match of right hand side value: %{name: "Bob", age: 24}
```

### 3.1.7 匹配比特串和字节序列

在本书中，我们不会过多讨论比特串和字节序列，但提到一些基本的匹配语法是值得的。请记住，比特串是一串位，而字节序列是一种特殊的位字符串，总是按字节大小对齐。

要匹配二进制，您使用的语法类似于创建一个的语法。

```elixir
iex(11)> binary = <<1, 2, 3>>
<<1, 2, 3>>

iex(13)> <<b1, b2, b3>> = binary
<<1, 2, 3>>

iex(14)> b1
1
```

这个例子匹配一个三字节的二进制数据，并将每个字节提取到不同的变量中。下面的例子通过将第一个字节放入一个变量中，其余的二进制数据放入另一个变量中来拆分二进制数据：

```elixir
iex(15)> <<b1, rest :: binary>> = binary
<<1, 2, 3>>

iex(16)> rest
<<2, 3>>
```

`rest::binary`表示你可以预期任意大小数据。你甚至可以提取单独的位或位组。以下示例将一个字节分成两个四位值：

```elixir
iex(17)> <<a :: 4, b :: 4>> = <<155>>
<<155>>
iex(18)> a
9

iex(19)> b
11
```

模式 `a::4` 表示你期望一个四位的值。在这个例子中，你将前四位放入变量 `a`，另外四位放入变量 `b`。因为数字 `155` 在二进制中表示为 `10011011`，所以你得到的值是 `9`（在二进制中为 `1001`）和 `11`（在二进制中为 `1011`）。

匹配比特串和二进制在你试图解析来自文件、外部设备或网络的压缩二进制内容时是非常有用的。在这种情况下，你可以使用二进制匹配优雅地提取单独的比特和字节。

如前所述，这本书中的例子不需要这个功能。不过，你应该记住二进制和模式匹配，以备将来需要时使用。

**MATCHING BINARY STRINGS**

请记住，字符串是字节序列的，因此您可以使用字节序列匹配从字符串中提取单个比特和字节。

```elixir
iex(20)> <<b1, b2, b3>> = "ABC"
"ABC"

iex(21)> b1
65
```

变量 b1、b2 和 b3 保存了您匹配的字符串中的相应字节。这并不是很有用，特别是当您处理 Unicode 字符串时。提取单个字符更好地使用字符串模块中的函数。

更有用的模式是匹配字符串的开头:

```elixir
iex(22)> command = "ping www.example.com"
"ping www.example.com"

iex(23)> "ping " <> url = command
"ping www.example.com"

iex(24)> url
"www.example.com"
```

在这个例子中，你构建一个包含 `ping` 命令的字符串。当你写` "ping " <> url = command` 时，你表示期望命令变量是一个以 `"ping "` 开头的二进制字符串。如果匹配成功，字符串的其余部分将绑定到变量 `url`。

### 3.1.8 符合匹配

你已经见过这个，但让我们明确一下。模式可以任意嵌套，如以下这个人为的例子所示：

```elixir
iex(1)> [_, {name, _}, _] = [{"Bob",25}, {"Alice",30}, {"John",35}]
[{"Bob", 25}, {"Alice", 30}, {"John", 35}]

iex(2)> name
"Alice"
```

在这个例子中，匹配的术语是一个包含三个元素的列表。每个元素是一个元组，表示一个人，由两个字段组成：这个人的姓名和年龄。该匹配提取列表中第二个人的姓名。另一个有趣的功能是匹配链。在您看到它如何工作之前，先让我们更详细地讨论匹配表达式。

匹配表达式具有如下通用形式：

```elixir
pattern = expression
```

如你在例子中看到的，你可以将任何表达式放在右侧:

```elixir
iex(2)> a = 1 + 3 
4
```

让我们分析一下这里发生了什么：
1. 右侧的表达式被求值
2. 结果值与左侧的模式进行匹配。
3. 模式中的变量被绑定。
4. 匹配表达式的结果是右侧项的结果。

这带来的一个重要后果是，匹配表达式可以被链式连接:

```elixir
iex(3)> a = (b = 1+ 3)
4
```

在这个（不太有用的）例子中，发生了以下事情：

1. 表达式 1 + 3 被求值。
2. 结果（4）与模式 b 进行匹配。
3. 内层匹配的结果（再次是 4）与模式 a 进行匹配。

因此，a 和 b 的值都是 4。括号是可选的，许多开发者在这种情况下会省略它们：

 ```elixir
iex(4)> a = b = 1+ 3
4
```

这产生了相同的结果，因为`=`运算符是右结合的。

现在，让我们看看一个更有用的例子。回顾一下函数:`calendar.local_time/0`：

假设你想获取函数的总结果（日期时间）以及当前的小时。以下是一种在单个复合匹配中实现此目的的方法：

```elixir
iex(5)> date_time = {_, {hour, _, _}} = :calendar.local_time()
{{2024, 9, 18}, {14, 44, 40}}

iex(6)> date_time
{{2024, 9, 18}, {14, 44, 40}}

iex(7)> hour
14
```

这是有效的，因为模式匹配的结果始终是正在匹配的项的结果（无论是匹配操作符右侧的内容）。你可以依次与该项的结果进行匹配，并提取你关注的不同部分。

### 3.1.9 通常行为

我们快要完成基本的模式匹配机制了。我们已经学习了很多例子，现在让我们试着形式化一下行为。

模式匹配表达式由两部分组成：模式（左侧）和项（右侧）。在匹配表达式中，会尝试将项与模式进行匹配。如果匹配成功，模式中的所有变量都会绑定到项中对应的值上。整个表达式的结果就是你匹配的整个项。如果匹配失败，就会引发错误。

因此，在模式匹配表达式中，你需要执行两个不同的任务：

1. 你确认对右侧项的期望。如果这些期望没有得到满足，就会引发错误。
2. 你将项的某些部分绑定到模式中的变量上。

最后，值得一提的是，我们并没有涵盖所有可能的模式。有关详细信息，你可以参考官方文档 (https://mng.bz/dd6o)。

匹配运算符 = 只是模式匹配可以使用的一个例子。模式匹配驱动许多其他类型的表达式，尤其在函数中使用时表现得特别强大。

## 3.2 函数匹配

模式匹配机制用于函数参数的规范中。回忆一下基本的函数定义：

```elixir
def my_fun(arg1, arg2) do
  ...
end
```

参数说明符 `arg1` 和 `arg2` 是模式，您可以使用标准匹配技术。让我们看看实际应用。正如第2章所提到的，元组通常用于将相关字段组合在一起。例如，如果您进行几何操作，可以用一个元组 `{a, b}` 表示一个矩形，其中包含矩形的边。以下代码展示了一个计算矩形面积的函数。

```elixir
# “Listing 3.1 Pattern matching function arguments (rect.ex)”
defmodule Rectangle do
  def area({a, b}) do
    a * b
  end 
end
```

请注意你是如何匹配参数的。函数 `Rectangle.area/1` 期望它的参数是一个包含两个元素的元组。然后，它将相应的元组元素绑定到变量中并返回结果。

您可以从 shell 检查这是否有效。启动 shell，然后加载模块：

```shell
$ iex rect.ex
```

然后尝试：

```elixir
iex(9)> Rectangle.area({2,3})
6
```

这里发生了什么？当您调用一个函数时，您提供的参数与函数定义中指定的模式进行匹配。该函数期望一个包含两个元素的元组，并将元组的元素绑定到变量 a 和 b。

调用函数时，被匹配的项是提供给函数调用的参数。您匹配的模式是参数说明符——在这种情况下是 {a, b}。

当然，如果您提供的不是一个包含两个元素的元组，就会引发错误：

```elixir
iex(10)> Rectangle.area(2)
** (FunctionClauseError) no function clause matching in Rectangle.area/1    
```

模式匹配函数参数是一个非常有用的工具。它支撑着 Elixir 的一个重要特性：多条款函数。

### 3.2.1 多条款函数

Elixir 允许通过指定多个条款来重载函数。条款是通过 `def` 表达式指定的函数定义。如果您提供多个具有相同参数个数的相同函数定义，则称该函数具有多个条款。

让我们看看这个如何运作。延续上一个例子，假设您需要开发一个可以处理各种形状的几何模块。您将用元组表示形状，并使用每个元组的第一个元素来指示它表示哪些形状

```elixir
rectangle = {:rectangle, 4, 5}
square = {:square, 5}
circle = {:circle, 4}
```

根据这些形状表示，您可以编写以下函数来计算形状的面积。

```elixir
defmodule Geometry do
  def area({:rectangle, a, b}) do
    a * b 
  end

  def area({:square, a}) do
    a * a
  end

  def area({:circle, r}) do
    r * r * 3.14
  end
end
```

正如你所看到的，你提供了同一个函数的三个子句。根据你传递的参数，相应的子句会被调用。我们从 shell 试一下这个:

```elixir
iex(13)> Geometry.area({:rectangle, 4, 5})
20
iex(14)> Geometry.area({:square, 5})
25
iex(15)> Geometry.area({:circle, 4})
50.24
```

当你调用函数时，运行时会按照源代码中指定的顺序逐个检查其每个条件，并尝试匹配提供的参数。第一个成功匹配所有参数的条件会被执行。

当然，如果没有任何条件匹配，将会引发错误。

```elixir
iex(16)> Geometry.area({:triangle,1,2,3})
** (FunctionClauseError) no function clause matching in Geometry.area/1    
```

从调用者的角度来看，多子句函数是一个单一的函数。您不能直接引用特定的子句。相反，您总是处理整个函数。回想第二章，您可以使用捕获操作符 `& `来创建函数值。

```elixir
&Module.fun/arity
```

捕获 `Geometry.area/1` 就是捕获它的所有子句:

```elixir
iex(16)> fun = &Geometry.area/1
&Geometry.area/1

iex(17)> fun.({:circle, 4})
50.24

iex(18)> fun.({:square, 5})
25
```

这证明了即使一个函数由多个子句组成，它仍然被视为一个整体。

有时，你可能希望一个函数返回一个表示失败的值，而不是抛出错误。你可以引入一个始终匹配的默认子句。让我们为面积函数这样做。下一个列表添加了一个处理任何无效输入的最终子句。

```elixir
# Listing 3.3 Multiclause function (geometry_invalid_input.ex)
defmodule Geometry do
  def area({:rectangle, a, b}) do
    a * b 
  end

  def area({:square, a}) do
    a * a
  end

  def area({:circle, r}) do
    r * r * 3.14
  end

  def area(unknown) do   # 处理不合法输入的子句
    {:error, {:unknown_shape, unknown}}
  end
end
```

如果前三个条件都不匹配，则调用最后一个条件。这是因为变量模式总是与相应的项匹配。在这种情况下，您返回一个包含两个元素的元组 `{:error, reason}`，以指示发生了错误。

```elixir
iex(2)> Geometry.area({:square, 5})
25

iex(4)> Geometry.area({:triangle, 1, 2, 3})
{:error, {:unknown_shape, {:triangle, 1, 2, 3}}}
```

提示：为了使这一切正常工作，重要的是将子句放置在适当的顺序中。运行时会根据源代码中的顺序尝试选择子句。**如果 area(unknown) 子句首先被定义，您将始终得到错误结果**。


请注意，`area(unknown)` 子句仅适用于 `area/1`。如果传递多个参数，这个子句将不会被调用。请回顾第二章，函数在名称和元数上是不同的。因为具有相同名称但不同元数的函数是两个不同的函数，所以无法指定一个无论传递多少参数都会执行的 area 子句。

最后一点：你应该始终将相同函数的子句集中在一起，而不是将它们分散在模块的各个地方。如果一个多子句函数分布在文件的各个地方，将会越来越难以分析该函数的完整行为。即使编译器也会对此投诉，并发出编译警告。

### 3.2.2 守卫

你想写一个函数，接受一个数字并根据该数字的值返回一个原子：`:negative`, `:zero` 或 `:positive`。这在你到目前为止所见的简单模式匹配中是不可能的。Elixir 为此提供了一个解决方案，使用守卫（guards）。

守卫是基本模式匹配机制的扩展。它们允许你声明额外的更广泛的期望，必须满足才能使整个模式匹配。守卫可以通过在参数列表之后提供 `when` 子句来指定。通过示例最好来说明这一点。以下代码测试给定的数字是正数、负数还是零。

```elixir
# Listing 3.4 Using guards (test_num.ex)
defmodule TestNum do
  def test(x) when x < 0 do
    :negative
  end

  def test(x) when x == 0 do
    :zero
  end

  def test(x) when x > 0 do
    :positive
  end
end
```

守卫是一个逻辑表达式，它为模式添加了额外的条件。在这个例子中，我们有三个相同模式（x）的子句，这些子句通常总能匹配。额外的守卫精炼了模式，确保只有在满足给定条件时才会调用该子句，如在下面的 shell 会话中演示的那样。

```elixir
iex(2)> TestNum.test(-1)
:negative

iex(3)> TestNum.test(0)
:zero

iex(4)> TestNum.test(1)
:positive
```

令人惊讶的是，使用非数字调用这个函数会产生奇怪的结果：

```elixir
iex(6)> TestNum.test(:not_a_number)
:positive
```

到底发生了什么？解释在于，Elixir 的术语可以使用 < 和 > 运算符进行比较，即使它们不是同一类型。在这种情况下，类型的顺序决定了结果：

```elixir
number < atom < reference < fun < port < pid <
  tuple < map < list < bitstring (binary)
```


数字总是比任何其他类型小，这就是为什么当您提供非数字时，`TestNum.test/1` 总是返回 :positive。要解决这个问题，您需要通过检查参数是否为数字来扩展守卫条件:

```elixir
defmodule TestNum do
  def test(x) when is_number(x) and x < 0 do
    :negative
  end
 
  def test(x) when x == 0 do
    :zero
  end
 
  def test(x) when is_number(x) and x > 0 do
    :positive
  end
end
```

这段代码使用函数 `Kernel.is_number/1` 来测试参数是否为数字。现在，如果你传递一个非数字的值给 `TestNum.test/1`，程序将引发错误:

```elixir
iex(8)> TestNum.test :not_a_number
** (FunctionClauseError) no function clause matching in TestNum.test/1    
```

可以在守卫中调用的运算符和函数的集合非常有限。特别是，您不能调用您自己的函数，且大多数其他函数将无效。以下是在守卫中允许的运算符和函数的一些示例：

- 比较运算符 (`==`, `!=`, `===`, `!==`, `>`, `<`, `<=`, 和 `>=`)
- 布尔运算符 (`and`, `or`) 和否定运算符 (`not`, `!`)
- 算术运算符 (`+`, `-`, `*`, 和 `/`)
- `Kernel` 模块中的类型检查函数 (例如，`is_number/1`, `is_atom/1` 等等)。

您可以在 https://mng.bz/rjVJ 找到完整的、最新的列表。

在某些情况下，守卫中使用的函数可能会导致错误被引发。例如，`length/1` 仅在用于列表时才有意义。想象一下，您有以下函数，该函数计算非空列表中的最小元素：”

```elixir
defmodule ListHelper do
  def smallest(list) when length(list) > 0 do
    Enum.min(list)
  end
 
  def smallest(_), do: {:error, :invalid_argument}
end
```

你可能认为调用 `ListHelper.smallest/1` 时，如果传入的不是列表会抛出错误，但实际上不会发生这种情况。如果在守卫内抛出了错误，它不会被传播，守卫表达式将返回 `false`。相应的子句不会匹配，但可能会有其他子句匹配。在前面的例子中，如果你调用 `ListHelper.smallest(123)`，你会得到以下结果：{:error, :invalid_argument}。这表明**守卫表达式中的错误是被内部处理的**。


### 3.2.3 多子句Lambdas

匿名函数（lambda）也可以由多个子句组成。首先，回顾一下定义和使用lambda的基本方法。

```elixir
iex(1)> double = fn x -> x * 2 end # 定义lambda

iex(2)> double.(3)                 # 调用lambda
6
```

一般的 lambda 语法具有以下形式：

```elixir
fn 
  pattern_1, pattern_2 ->
    ...           # 当 pattern_1 匹配第一个参数且 pattern_2 匹配第二个参数时执行
  pattern_3, pattern_4 ->
    ...           # 当 pattern_3 匹配第一个参数且 pattern_4 匹配第二个参数时执行
  ...
end
```

让我们通过重新实现 `test/1` 函数来实际看看，它用于检测一个数字是正数、负数还是零。

```elixir
iex(3)> test_num =
...(3)>           fn
...(3)>             x when is_number(x) and x < 0 -> :negative
...(3)>             x when x == 0 -> :zero
...(3)>             x when is_number(x) and x > 0 -> :positive
...(3)>           end
```

请注意，lambda 语句没有特定的结束终止符。该语句在开始一个新语句时（以`pattern ->` 的形式）或 lambda 定义以 `end` 结束时结束。

注意：由于 lambda 的所有子句都在同一个 `fn` 表达式下列出，因此出于约定，省略了每个子句的括号。相比之下，命名函数的每个子句都在一个单独的 `def`（或 `defp`）表达式中指定。因此，建议在命名函数参数周围使用括号。

现在你可以测试这个 lambda 了:

```elixir
iex(4)> test_num.(1)
:positive

iex(5)> test_num.(0)
:zero

iex(6)> test_num.(-1)
:negative
```

多元闭包在使用更高阶函数时非常有用，正如你在本章后面会看到的。不过，目前我们已经结束了关于多元函数的基本理论。它们在条件运行时分支中扮演着重要的角色，这是我们下一个主题。

## 3.3 条件语句

Elixir 提供了一些标准的方法来进行条件分支，例如 `if` 和 `case`。多重子句函数也可以用于这个目的。在本节中，我们将介绍所有的分支技术，从多重子句函数开始。

### 3.3.1 使用多重子句函数进行分支

你已经看到如何使用多重子句来实现条件逻辑，但让我们再看一次:

```elixir
defmodule TestNum do
  def test(x) when x < 0, do: :negative
  def test(0), do: :zero
  def test(x), do: :positive
```

这三个条件子句构成了三个条件分支。在一个典型的命令式语言中，比如`JavaScript`，你可以写出如下代码：

```javascript
funtion test(x){
if (x < 0) return "negative";
if (x == 0)  return "zero";
return "positive";
}
```

可以说，这两个版本的可读性相当。但通过多子句，你可以充分利用模式匹配的所有好处，例如根据数据的形状进行分支。在以下示例中，使用多子句来检测给定列表是否为空：

```elixir
defmodule TestList do
  def empty?([]), do: true
  def empty?([_|_]), do: false
end
```

第一个子句匹配空列表，而第二个子句依赖于非空列表的`head|tail`表示法。

通过依赖模式匹配，你可以实现多态函数，这些函数根据输入类型执行不同的操作。以下示例实现了一个将变量加倍的函数。这个函数的行为取决于它是用数字还是二进制（字符串）调用的。

```elixir
iex(9)> defmodule Polymorphic do
...(9)>           def double(x) when is_number(x), do: 2 * x
...(9)>           def double(x) when is_binary(x), do: x <> x
...(9)>         end

iex(10)> Polymorphic.double(3)
6

iex(11)> Polymorphic.double("Jar")
"JarJar"
```

多重子句的力量在递归中变得明显。生成的代码看起来是声明式的，且没有多余的 `if` 和 `return`。以下是基于多重子句的阶乘递归实现：

```elixir
iex(1)> defmodule Fact do
...(1)>   def fact(0), do: 1
...(1)>   def fact(n), do: n * fact(n - 1)
...(1)> end

iex(2)> Fact.fact 1
1

iex(3)> Fact.fact 3
6
```

多重子句驱动的递归也被用作循环的主要构建块。这将在下一节中详细解释，但这里有一个简单的例子。以下函数对列表中的所有元素进行求和：

```elixir
iex(7)> defmodule ListHelper do
          def sum([]), do: 0
          def sum([head | tail]), do: head + sum(tail)
        end
 
iex(8)> ListHelper.sum([])
0
 
iex(9)> ListHelper.sum([1, 2, 3])
6
```

这个解决方案通过依赖于列表的递归定义来实现求和。空列表的和始终为0，而非空列表的和等于其头部的值加上其尾部的和。

所有可以用经典分支表达式实现的操作，都可以通过多重子句来实现。然而，底层的模式匹配机制通常更具表现力，允许你根据函数参数的值、类型和形状进行分支。不过，在某些情况下，使用经典的命令式分支风格的代码看起来更好。让我们看看在Elixir中还有哪些其他的分支表达式。

### 3.3.2 经典分支表达式

多条件解决方案并不总是合适。使用它们需要创建一个单独的函数并传递必要的参数。有时，使用传统的分支表达式会更简单。在这种情况下，可以使用`if`、`unless`、`cond`和`case`这些表达式。它们的工作方式大致符合你的预期，尽管有一些细微的差别。让我们逐个看一下。


**IF AND UNLESS**

`if` 表达式的语法是大家熟悉的:

```elixir
if condition do
  ...
else
  ...
end
```

这会导致执行一个分支或另一个分支，取决于条件的真实性。如果条件不是 `false` 或 `nil`，你会进入主分支；否则，将调用 `else` 部分。你也可以像 `def` 表达式一样将其简化为一行代码：

```elixir
if condition, do: something, else: another_thing
```

请记住，Elixir 中的一切都是有返回值的表达式。`if` 表达式返回执行代码块的结果（也就是代码块的最后一个表达式）。

```elixir
iex(1)> if 5 > 3, do: :one
:one

iex(2)> if 5 < 3, do: :one
nil

iex(3)> if 5 < 3, do: :one, else: :two
:two
```

让我们看一个更具体的例子。以下代码实现了一个`max`函数，它返回两个元素中较大的一个（根据 `>`运算符的语义）：

```elixir
def max(a, b) do
  if a >= b, do: a, else: b
end
```

`unless` 表达式也可用，它相当于 `if not ...`。考虑以下 `if` 表达式：

```elixir
if result != :error, do: send_notification(...)
```

这也可以表达为：

```elixir
unless result == :error, do: send_notification(...)
```

**COND**

`cond `表达式可以视为` if-else-if `模式的等价物。它接受一个表达式列表，并执行第一个求值为真值的表达式块：

```elixir
cond do
  expression_1 ->
    ...
  expression_2 ->
    ...
  ...
end
```

`⁠cond` 的结果是相应执行块的结果。如果没有满足任何条件，`⁠cond` 会引发错误。当分支选择超过两个时，`⁠cond` 表达式是一个不错的选择。

```elixir
def call_status(call) do
  cond do
    call.ended_at != nil -> :ended
    call.started_at != nil -> :started
    true -> :pending  # 相当于一个默认子句
  end
end
```

在这个示例中，您正在计算通话的状态。如果 `ended_at` 字段被填充，表示通话已经结束。否则，如果 `started_at` 字段被填充，表示通话已经开始。如果这两个字段都没有被填充，通话就是待处理状态。请注意最后的条件：(true -> :pending)。由于这个条件（true）始终满足，因此这实际上成为了一个后备条件，当之前的条件在 `cond` 表达式中都不满足时会被调用。

**case**

该语句的基本语法如下：

```elixir
case expression do
  pattern_1 ->
    ...
 
  pattern_2 ->
    ...
 
  ...
end
```

这里的“pattern”一词表示它涉及模式匹配。在 `case` 表达式中，提供的表达式会被计算，然后结果会与给定的条件进行匹配。第一个匹配的条件会被执行，对应代码块的结果（最后一个表达式）就是整个 `case` 表达式的结果。如果没有条件匹配，则会抛出错误。基于 `case` 的` max` 函数版本将如下所示：

```elixir
def max(a, b) do
  case a => b do
    true -> a
    false -> b
  end
end
```

`case` 表达式最适合在你不想定义一个单独的多条件函数时使用。除此之外，`case` 和多条件函数之间没有差别。实际上，**通用的 `case` 语法可以直接转换为多条件的方法**：

```elixir
defp fun(pattern_1), do: ...
defp fun(pattern_2), do: ...
...
```

这必须通过函数语法调用：`fun(expression)`。您可以通过使用匿名变量来匹配任何内容，从而指定默认子句:

```elixir
case expression do
  pattern_1 -> ...
  pattern_2 -> ...
  ...

  -> ... # 会匹配所有的默认子句
end
```

正如你所看到的，在 Elixir 中有不同的方法来实现条件逻辑。多重子句提供了更声明式的分支方式，但它们需要你定义一个单独的函数并传递所有必要的参数。经典表达式，比如 if 和 case，更显得命令式，但通常比多重子句方法更简单。选择合适的解决方案取决于具体情况以及个人偏好。

### 3.3.3 with表达式

我们要讨论的最后一个分支表达式是`with`表达式，它在需要链式处理多个表达式并返回第一个失败表达式的错误时非常有用。我们来看一个简单的例子。假设您需要处理用户提交的注册数据。输入是一个映射，键是字符串（"login"、"email"和"password"）。下面是一个输入映射的示例：

```elixir
%{
  "login" => "alice",
  "email" => "some_email",
  "password" => "password",
  "other_field" => "some_value",
  "yet_another_field" => "...",
  ...
}
```

你的任务是将这个映射标准化为只包含`login`、`email`和`password`字段的映射。通常，如果字段集定义良好且事先已知，你可以将键表示为原子。因此，对于给定的输入，你可以返回以下结构：

```elixir
%{login: "alice", email: "some_email", password: "password"}
```

然而，某些必填字段可能在输入映射中不存在。在这种情况下，您需要报告错误，因此您的函数可以有两种不同的结果。它可以返回标准化的用户映射，或返回错误。在这种情况下，惯用的做法是让函数返回` {:ok, some_result}` 或 `{:error, error_reason}`。

在这个练习中，成功的结果是标准化的用户映射，而错误原因是描述性文本。请先编写提取每个字段的辅助函数:

```elixir
defp extract_login(%{"login"=> login}), do: {:ok, login}
defp extract_login(_), do: {:error, "login missing"}

defp extract_email(%{"email" => email}), do: {:ok, email}
defp extract_email(_), do: {:error, "email missing"}

defp extract_password(%{"password" => password}), do: {:ok, password}
defp extract_password(_), do: {:error, "password missing"}
```

在这里，您依赖模式匹配来检测字段的存在。

现在，您需要编写顶层的 `extract_user/1` 函数，来组合这三个函数。下面是使用 `case` 的一种实现方式：

```elixir
def extract_user(user) do
  case extract_login(user) do
    {:error, reason} ->
      {:error, reason}
 
    {:ok, login} ->
      case extract_email(user) do
        {:error, reason} ->
          {:error, reason}
 
        {:ok, email} ->
          case extract_password(user) do
            {:error, reason} ->
              {:error, reason}
 
            {:ok, password} ->
              %{login: login, email: email, password: password}
          end
      end
  end
end
```

这是相当复杂的，考虑到代码组合了三个函数。每次你获取某些东西时，你需要根据结果进行分支，结果会导致三个嵌套的情况。在现实生活中，你通常必须执行更多的验证，因此代码可能很快变得相当麻烦。这正是⁠`with`可以帮助你的地方。`⁠with`特殊形式允许你使用模式匹配来链接多个表达式，验证每个结果是否符合预期模式，并返回第一个意外的结果。

简单来说，⁠`with`的基本结构如下：

```elixir
with pattern_1 <- expression_1,
     pattern_2 <- expression_2,
     ...
 
do
  ...
end
```

你从顶部开始，评估第一个表达式，并将结果与相应的模式进行匹配。如果匹配成功，则继续下一个表达式。如果所有表达式都成功匹配，则进入`⁠do`块，并且`⁠with`表达式的结果是`⁠do`块中最后一个表达式的结果。

然而，如果任何匹配失败，⁠`with`将不会继续评估后续的表达式，而是会立即返回无法匹配的结果。让我们看一个例子：

```elixir
iex(4)> with {:ok, login} <- {:ok, "alice"},
...(4)>      {:ok, email} <- {:ok, "some_email"} do
...(4)>      %{login: login, email: email}
...(4)>         end
%{login: "alice", email: "some_email"}
```

在这里，您通过两个模式匹配来提取登录和电子邮件。然后，评估 `do` 块。`with` 表达式的结果是 `do` 块中表达式的最后结果。表面上，这与以下内容没有区别：

```elixir
iex(5)> with {:ok, login} <- {:error, "login missing"},
...(5)>      {:ok, email} <- {:ok, "email"} do
...(5)>      %{login: login, email: email}
...(5)>  end
{:error, "login missing"}
```

在你的情况下，这正是所需的。掌握这新知识后，重构顶层的 `extract_user` 函数。

```elixir
def extract_user(user) do
  with {:ok, login} <- extract_login(user),
       {:ok, email} <- extract_email(user),
       {:ok, password} <- extract_password(user) do
    %{login: login, email: email}
  end
end
```

如您所见，这段代码更短也更清晰。您提取所需的数据，仅在成功时继续。如果出现错误，则返回第一个“错误”。否则，您将返回标准化后的结构。完整的实现可以在 `user_extraction.ex` 中找到。试一试吧：

```elixir
iex user_extraction.ex
 
iex(1)> UserExtraction.extract_user(%{})
{:error, "login missing"}
 
iex(2)> UserExtraction.extract_user(%{"login" => "some_login"})
{:error, "email missing"}
 
iex(3)> UserExtraction.extract_user(%{
          "login" => "some_login",
          "email" => "some_email"
        })
{:error, "password missing"}
 
iex(4)> UserExtraction.extract_user(%{
          "login" => "some_login",
          "email" => "some_email",
          "password" => "some_password"
        })
{:ok, %{email: "some_email", login: "some_login",
  password: "some_password"}}
```

`with` 特殊形式有一些这里没有介绍的额外特性。我建议你在 https://mng.bz/VRxy 上更详细地研究它。这就是我们对 Elixir 中分支表达式的介绍。现在，是时候看看如何进行循环和迭代了。

## 3.4 循环和迭代

在Elixir中，循环的工作方式与主流编程语言大不相同。Elixir没有提供像`while`和`do...while`这样的结构。然而，任何一个严肃的程序都需要进行某种动态循环。那么，在Elixir中该如何处理呢？Elixir中主要的循环工具是递归，因此接下来我们将详细了解如何使用它。

注意：尽管递归是任何循环的基本构建块，但大多数生产环境中的Elixir代码使用递归的次数很少。这是因为有许多更高级的抽象隐藏了递归细节。你将在本书中了解到许多这些抽象，但了解Elixir中递归是如何工作的也很重要，因为大多数复杂的代码都是基于这一机制。

注意：本节中的大多数示例处理的是简单问题，例如计算列表中所有元素的总和——这是Elixir允许你以有效且优雅的单行代码完成的任务。然而，这些示例的重点是理解基于递归处理简单问题的不同方面。

### 3.4.1 递归迭代

我们来假设你想实现一个打印前 n 个自然数（正整数）的函数。因为不能使用循环，你必须依靠递归。基本的方法在下面的代码中进行了说明。

```elixir
# 清单3.7 打印前n个自然数（natural_nums.ex)
defmodule  NaturalNums do
  def print(1), do: IO.puts(1)

  def print(n) do
    print(n-1)
    IO.puts(n)
  end
end
```

这段代码依赖递归、模式匹配和多子句函数。如果 n 等于 1，你就打印这个数字。否则，你先打印前 n - 1 个数字，然后再打印第 n 个数字。

在shell中尝试下：

```elixir
iex(3)> NaturalNums.print(3)
1
2
3
```


你可能注意到，如果提供负整数或浮点数，函数将无法正确工作。这可以通过添加额外的保护措施来解决，作为练习留给你。

```elixir
defmodule  NaturalNums do
  def print(1), do: IO.puts(1)

  def print(n) when is_integer(n) do
    print(n-1)
    IO.puts(n)
  end
  
  def print(_n), do: :not_a_number
end
```

列表3.7中的代码演示了进行条件循环的基本方法。你首先指定一个多子句函数，提供停止递归的子句。接下来是更一般的子句，它们生成部分结果并递归调用该函数。接下来，让我们看看在循环中计算某些内容并返回结果。你在处理条件时已经看到过这个例子，但让我们重复一下。以下代码实现了一个函数，用于计算给定列表中所有元素的总和。

```elixir
# 清单3.8 计算列表的总和（sum_list.ex）
defmodule ListHelper do
  def sum([]), do: 0

  def sum([h|t]) do
    h + sum(t)
  end
end
```

这段代码看起来非常声明式：
- 空列表中所有元素的和是 0。
- 非空列表中所有元素的和等于列表的头加上列表的尾的和。 

让我们看看它是如何工作的：

```elixir
iex(4)> ListHelper.sum([1,2,3])
6

iex(5)> ListHelper.sum([])
0
```

你可能知道，从其他语言来看，函数调用会导致栈的推送，因此会消耗一些内存。非常深的递归可能会导致栈溢出，从而崩溃整个程序。由于尾调用优化，这在 Elixir 中不一定是个问题。

### 3.4.2 尾调用

如果一个函数的最后一件事是调用另一个函数（或它自己），那么你正在处理一个尾调用。

```elixir
def original_fun(...) do
  ...
  another_fun(...) # 这是尾调用
end  
```

Elixir（或者更准确地说，Erlang）以特定的方式处理尾调用，通过执行尾调用优化。在这种情况下，调用一个函数不会导致通常的栈压入。相反，发生的更像是一个跳转或转移语句。在调用函数之前不会分配额外的栈空间，这意味着尾函数调用不会消耗额外的内存。

这怎么可能呢？在之前的代码片段中，`original_fun`中最后做的事情是调用`another_fun`。`original_fun`的最终结果是`another_fun`的结果。这就是编译器可以安全地“通过跳转到`another_fun`的开头而无需额外分配内存来执行该操作的原因。当`another_fun`完成时，你会返回到`original_fun`被调用的地方。

尾调用在递归函数中特别有用。尾递归函数，也就是在最后一刻调用自己的函数，可以在几乎不消耗额外内存的情况下无限运行。

以下函数是Elixir等价于无尽循环的示例：

```elixir
def loop_forever(...) do
  ...
  loop_forever(...)
end
```

因为尾递归不消耗额外的内存，它是处理任意大迭代的合适解决方案。在下一段代码中，您将把 `ListHelper.sum/1` 函数转换为尾递归版本。

```elixir
# 清单3.9 尾递归计算前n个自然数的和(sum_list_tc.ex)
defmodule ListHelper do
  def sum(list) do
    do_sum(0, list)
  end

  defp do_sum(current_sum, []) do
    current_sum
  end

  defp do_sum(current_sum,[head | tail]) do
    new_sum = head + current_sum
    do_sum(new_sum, tail)
  end
end
```

首先需要注意的是，您有两个函数。导出的函数 `sum/1` 是由模块 clients 调用的，表面上它的工作方式与之前一样。递归发生在私有的 `do_sum/2` 函数中，该函数实现为尾递归。这是一个包含两个子句的函数，我们将逐个分析它的子句。第二个子句更有趣，因此我们将从它开始。以下是它的独立形式：

```elixir
defp do_sum(current_sum,[head | tail]) do
  new_sum = head + current_sum
  do_sum(new_sum, tail)
end
```

这个子句期待两个参数：要操作的非空列表和你当前计算的总和（current_sum）。然后它计算新的总和，并使用列表的其余部分和新的总和递归调用自身。因为调用发生在最后，所以这个函数是尾递归的，并且该调用不消耗额外的内存。

这里引入变量 `new_sum `只是为了让事情更加清晰。你也可以将计算写成一行：

```elixir
defp do_sum(current_sum, [head | tail]) do
  do_sum(current_sum + head, tail)
end
```

这个函数仍然是尾递归的，因为它在最后调用自身。最后要检查的是 `do_sum/2` 的第一个子句：

```elixir
defp do_sum(current_sum, []) do
  current_sum
end
```

该子句负责停止递归。它匹配一个空列表，这是迭代的最后一步。当你到达这里时，已经没有其他可求和的内容，因此你返回累积的结果。最后，你得到了函数 `sum/1`:”

```elixir
def sum(list) do
  do_sum(0, list)
end
```

这段函数被客户端使用，并负责初始化递归传递的 `current_sum` 参数的值。

你可以将尾递归视为命令式语言中经典循环的直接等价物。参数 `current_sum` 是一个经典的累加器：它是在每次迭代步骤中逐渐添加结果的值。`do_sum/2` 函数实现了迭代步骤并将累加器从一个步骤传递到下一个步骤。Elixir 是一种不可变语言，因此你需要这个技巧来保持整个循环中的累积值。`do_sum/2` 的第一条子句定义了迭代的结束点并返回累加器的值。

无论如何，列表求和的尾递归版本现在可以工作，因此你可以在 shell 中尝试它。

```elixir
iex(7)> ListHelper.sum([1,2,3])
6

iex(8)> ListHelper.sum([])
0
```

正如你所看到的，从调用者的角度来看，这个函数的工作方式完全相同。在内部，你依赖尾递归，因此可以在不需要额外内存的情况下处理任意大的列表。

**尾递归与非尾递归**

考虑到尾递归的特性，你可能会认为它总是执行循环的首选方法。如果你需要运行一个无限循环，尾递归是唯一可行的方式。否则，目标应该是选择更可读的版本。此外，非尾递归往往可以产生更优雅、简洁的代码，有时甚至比尾递归的实现效果更好。

**识别尾递归**

尾调用可以有不同的形式。你已经看到了最明显的情况，但还有其他几种。尾调用也可以发生在条件表达式中。

```elixir
def fun(...) do
  ...
  if something do
  ...
  another_fun(...)  # 这个也是尾递归
  end
end
```

`another_fun`的调用是一个尾调用，因为这是函数执行的最后一件事。相同的规则适用于`unless`、`cond`、`case`和`with`表达式。但是以下代码不是一个尾调用：

```elixir
def fun(...) do
  1 + another_fun(...)  # 这个不是尾递归
end
```

因为`another_fun`不是`fun`最后一个执行，在`another_fun`之后，执行了+1 。

**练习**

所有这些可能看起来很复杂，但其实并不太难。如果你来自命令式语言，可能不太习惯这种写法，适应结合模式匹配的递归思维方式需要一些时间。你可以花一些时间自己实验一下递归。以下是一些你可以写来练习的函数：

- 一个 list_len/1 函数，用于计算列表的长度  

```elixir
defmodule ListHelper do
  def len([]), do: 0
  def len([_head | tail]), do: 1 + len(tail)
end
```

- 一个 range/2 函数，它接受两个整数，从和到，并返回给定范围内所有整数的列表  

```elixir
defmodule MyRange do
  def range(from, to) when is_integer(from) and is_integer(to) and from <= to do
    [from | range(from + 1, to)]
  end

  def range(from, to) when  is_integer(from) and is_integer(to) and from > to do
    []
  end
end
```

- 一个 positive/1 函数，它接受一个列表并返回另一个只包含输入列表中正数的列表

```elixir
defmodule NumberFilter do
  def positive_numbers([]), do: []  

  def positive_numbers([head | tail]) do
    if is_number(head) and head > 0 do
      [head | positive_numbers(tail)]  
    else
      positive_numbers(tail)  
    end
  end
end
```

先尝试以非尾递归的形式编写这些函数，然后将它们转换为尾递归版本。如果遇到困难，可以在 `recursion_practice.ex` 和 `recursion_practice_tc.ex` 文件中找到解决方案（尾递归版本）。

递归是基本的循环技术，没有它就无法进行循环。但你并不需要经常写出显式的递归。许多典型任务可以通过高阶函数来完成。


### 3.4.3 高阶函数

高阶函数是一种接受一个或多个函数作为输入，或返回一个或多个函数（或两者）的函数。这里的函数指的是函数值。您在第二章中已经第一次接触到高阶函数，当时您使用 `Enum.each/2` 遍历一个列表并打印出它的所有元素。让我们回顾一下如何做到这一点：

```elixir
iex(1)> Enum.each(
...(1)>   [1, 2, 3],
...(1)>   fn x -> IO.puts(x) end  # 将函数作为参数传递给另一个函数
...(1)> )
1
2
3
```

函数 `Enum.each/2` 接受一个可枚举对象（在这种情况下是一个列表）和一个 lambda。它遍历可枚举对象，为每个元素调用 lambda。由于` Enum.each/2` 接受一个 lambda 作为输入，因此被称为高阶函数。

你可以使用 `Enum.each/2` 来遍历可枚举的结构，而无需编写递归。实际上，`Enum.each/2` 是通过递归实现的；在 Elixir 中没有其他方法可以进行循环和迭代。然而，编写递归的复杂性、重复代码以及尾递归的细节对你来说是隐藏的。

`Enum.each/2` 只是一个由高阶函数驱动的迭代的示例。Elixir 的标准库在 `Enum` 模块中提供了许多其他有用的迭代辅助函数。你应该花些时间研究模块文档（https://hexdocs.pm/elixir/Enum.xhtml）。在这里，我们将看看一些最常用的 `Enum` 函数。

**可枚举对象**

可用于枚举的 `Enum` 模块中的大多数函数。你将在第4章中了解这是什么意思。暂时来说，知道枚举是一种实现了某种契约的数据结构，使其适合被 `Enum` 模块中的函数使用就足够了。一些枚举的例子包括列表、范围、映射和 MapSet。你还可以将自己的数据结构转换为枚举，从而利用 Enum 模块的所有功能。

一种你经常需要的操作是将一个列表一一转换为另一个列表。这就是为什么提供了 `Enum.map/2`。它接受一个可枚举对象和一个将每个元素映射到另一个元素的 lambda 函数。以下示例将列表中的每个元素都翻倍：

```elixir
iex(2)> Enum.map(
...(2)>   [1, 2, 3],
...(2)>   &(2 * &1)
...(2)> )
[2, 4, 6]
```

`&(...)` 表示一个简化的 lambda 定义，其中使用 `&n` 作为 lambda 中第 `n` 个参数的占位符。另一个有用的函数是 `Enum.filter/2`，它可以根据某些条件从列表中提取特定的元素。以下代码片段返回列表中的所有奇数：

```elixir
iex(1)> Enum.filter(
...(1)>   [1, 2, 3],
...(1)>   fn x -> rem(x, 2) == 1 end
...(1)> )
[1, 3]
```   

让我们再玩一下 `Enum`。回想一下第 3.3.3 节的例子，在那里你使用了 `with` 来验证`login`、`email`和`password`是否已提交。在那个例子中，你返回了第一个遇到的错误。掌握了这个新知识后，你可以改进代码立即报告所有缺失的字段。简单回顾一下，你的输入是一个映射，你需要获取键 'login'、'email' 和 'password'，然后将它们转换为一个以原子为键的映射。如果缺少必填字段，你需要报告一个错误。在之前的版本中，你只是报告了第一个缺失的字段。更好的用户体验是返回所有缺失字段的列表。

这是一个可以轻松通过 `Enum.filter/2` 实现的功能。其思路是遍历所需字段的列表，只保留那些在映射中不存在的字段。你可以借助 `Map.has_key?/2` 来轻松检查某个键是否存在。解决方案的概要如下所示。

```elixir
# 清单3.10 报告所有缺失属性（user_extraction_2.ex)

case Enum.filter(
    ["login", "email", "password"],
     &(not Map.has_key?(user,&1))
    ) do
[] ->
  ...

missing_fields ->
 ...
```

`Enum.filter/2` 有两个可能的结果。如果结果是一个空列表，说明所有字段都已提供，您可以提取数据。否则，某些字段缺失，您需要报告错误。为了简洁起见，这里省略了每个分支的代码，但您可以在 `user_extraction_2.ex` 中找到完整的解决方案。

**REDUCE**

`Enum`模块中最灵活的函数可能是`Enum.reduce/3`，它可以将可枚举的集合转换为任何东西。如果你来自支持一等函数的语言，你可能已经知道reduce这个概念，通常称为inject或fold。用一个例子最能解释reducing的过程。你将使用reduce来计算列表中所有元素的总和。在用Elixir实现之前，我们先来看一下如何以命令式的方式完成这个任务。这是一个命令式的JavaScript示例：

```javascript
var sum = 0;
[1, 2, 3].forEach(function(element){
  sum += element;
})
```

这是一个标准的命令式模式。你初始化一个累加器（变量 sum），然后进行一些循环，在每一步调整累加器的值。当循环结束时，累加器保存最终的值。在函数式编程语言中，你不能改变累加器，但是你仍然可以通过使用` Enum.reduce/3` 按增量计算结果。这个函数具有以下结构:

```elixir
Enum.reduce(
  enumerable,
  initial_acc,
  fn element, acc ->
    ...
  end
)
```

`Enum.reduce/3`的第一个参数是一个可枚举对象。第二个参数是累加器的初始值——即你逐步计算的值。最后一个参数是一个函数，对于每个元素都会被调用。这个函数接收来自可枚举对象的元素和当前的累加器值。这个函数的任务是计算并返回新的累加器值。当迭代完成后，`Enum.reduce/3`返回最终的累加器值。

我们使用 `Enum.reduce/3` 来对列表中的元素求和:

```elixir
Enum.reduce(
  [1, 2, 3],
  0,
  fn element, sum -> sum +element end
)
```

这就是全部了！作为一个有命令式编程背景的人，将 lambda 函数视为在每次迭代步骤中被调用的函数，对我帮助很大。它的任务是将一些信息添加到结果中。

你可能还记得我提到过许多操作符实际上是函数，你可以通过调用 `&+/2`、`&*/2` 等将操作符转变为 lambda。这与高阶函数很好地结合在一起。例如，求和的例子可以用更简洁的形式来写：

```elixir
Enum.reduce([1, 2, 3], 0, &+/2)
```

值得一提的是，有一个函数叫做 `Enum.sum/1`，它的工作方式与这个代码片段完全一样。这个求和示例的目的是为了说明如何遍历一个集合并累积结果。让我们进一步研究一下 `reduce`。之前的示例仅在传入一个完全由数字组成的列表时有效。如果列表包含其他任何内容，就会抛出错误（因为 `+` 操作符仅对数字定义）。下一个示例可以作用于任何类型的列表，并且仅对其数字元素进行求和：

```elixir
Enum.reduce(
  [1, "not a number", 2, :x, 3],
  0,
  fn
    element, sum when is_number(element) ->
      sum + element

    _, sum ->
      sum
  end
)
```