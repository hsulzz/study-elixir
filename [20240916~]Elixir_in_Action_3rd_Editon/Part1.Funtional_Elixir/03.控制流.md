# 控制流

**本章涵盖:**

- 理解模式匹配 
- 处理多子句函数 
- 使用条件表达式 
- 处理循环

现在你已经熟悉了Elixir的基本构建块，是时候看看一些语言的典型低级习惯用法了。在本章中，我们将讨论条件语句和循环。正如你所看到的，这些在许多命令式语言中工作方式有所不同。

经典的条件构造，例如`if`和`case`，通常被多子句函数所替代，并且没有像`while`那样的循环语句。但是，你仍然可以在Elixir中解决任意复杂性的问题，并且得到的代码并不比典型的面向对象解决方案复杂。

所有这些听起来可能有点激进，这就是为什么条件语句和循环在本章中会详细讨论。但是在我们开始讨论分支和循环之前，您需要了解一个重要的基本机制：模式匹配

## 3.1 模式匹配

如第二章所提到的，`=` 操作符并不是赋值。在表达式 `a = 1` 中，我们将变量 `a` 绑定到值 `1`。`=` 操作符被称为`匹配操作符`，这种类似赋值的表达式是模式匹配的一个例子。

模式匹配是 Elixir 中一个重要的概念。这是一个使复杂变量（例如元组和列表）的操作变得更加简单的特性。更不明显的是，它使您能够编写优雅的、类似声明式的条件语句和循环。您将在本章结束时了解这意味着什么。

在本节中，我们将研究模式匹配的基本机械原理。让我们首先来看看匹配操作符。

### 3.1.1 匹配操作符

到目前为止，我么见了很多匹配操作符的基本用法:

```elixir
iex(1)> person = {"Bob", 25}
```

我们把这当作类似于一个任务，但实际上，这里发生的事情更复杂。在运行时，`=` 操作符的左侧与右侧进行匹配。左侧称为模式，而右侧是一个计算为 Elixir 术语的表达式。在这个例子中，你将变量 `person` 匹配到右侧的术语 `{"Bob", 25}`。变量总是与右侧的术语匹配，并且它会绑定到该术语的值。这看起来可能有点理论化，所以我们来看一个稍微复杂一些的匹配操作符的使用，它涉及元组。

### 3.1.2 匹配元组

以下示例演示了元组的基本模式匹配:

```elixir
iex(3)> {name, age} ={"Bob",25}
{"Bob", 25}
```

这个表达式假设右侧的项是一个包含两个元素的元组。当表达式被求值时，变量 `name` 和 `age` 被绑定到元组的相应元素。你现在可以验证这些变量是否被正确绑定：

```elixir
iex(4)> name
"Bob"

iex(5)> age
25
```

这个功能在调用一个返回元组的函数时很有用，当你想把那个元组的各个元素绑定到不同的变量时。以下示例调用了Erlang函数`:calendar.local_time/0`以获取当前的日期和时间：

```elixir
iex(6)> {date, time}= :calendar.local_time()
{{2024, 9, 18}, {12, 46, 54}}
```

`date`和`time`也是元组，可以进一步解构：

```elixir
iex(2)> {y,m,d} = date
{2024, 9, 18}

iex(3)> y
2024
```

如果右侧与模式不对应，会发生什么？匹配失败，并且会引发错误:

```elixir
iex(4)> {name, age} = "can't match"
** (MatchError) no match of right hand side value: "can't match"
    (stdlib 6.0.1) erl_eval.erl:652: :erl_eval.expr/6
    iex:4: (file)
```

注意，我们尚未讨论错误处理机制——这些将在第8章中讨论。现在只需说引发错误的工作方式有点类似于主流语言中的经典异常机制。当错误被引发时，控制权会立即转移到调用链上某处的代码，这些代码会捕获该错误（假设这样的代码存在）。

最后值得注意的是，正如任何其他表达式一样，匹配表达式也会返回一个值。匹配表达式的结果始终是你正在匹配的右侧项。

```elixir
iex(4)> {name, age} = {"Bob", 22} # 匹配表达式
{"Bob", 22}                       # 匹配表达式的结果
```

### 3.1.3 匹配常量

匹配不仅限于将元组元素解构到单个变量中。令人惊讶的是，甚至常量也可以出现在匹配表达式的左侧：

```elixir
iex(1)> 1 = 1 
1
```

请记住，匹配运算符 `=` 尝试将右侧的项与左侧的模式进行匹配。在这个例子中，您试图将模式 `1` 与项 `1` 进行匹配。显然，这个匹配是成功的，整个表达式的结果是右侧的项。这个例子没有太多实际意义，但它说明您可以将常量放在 `=` 的左侧，这证明 `=` 不是赋值运算符。”

常量在复合匹配中更为有用。例如，元组有时用于将记录的各种字段分组。以下代码片段创建了一个包含个人姓名和年龄的元组。

```elixir
iex(3)> person = {:person, "Bob", 25}
```

第一个元素是一个常量原子 `:person`，你用它来表示这个元组代表一个人。之后，你可以依靠这个知识来获取这个人的各个属性。

```elixir
iex(5)>{:person, name, age} = person
```

在这里，您期望右侧的项是一个三元素元组，其第一个元素的值为`:person`。匹配后，元组的其余元素绑定到变量 `name` 和 `age`，您可以轻松验证这点。

```elixir
iex(4)> name
"Bob"
 
iex(5)> age
25
```

这是在 Elixir 中一个常见的习语。许多来自 Elixir 和 Erlang 的函数会返回 `{:ok, result}` 或 `{:error, reason}`。例如，想象一下你的系统依赖于一个配置文件，并期望它始终可用。你可以通过` File.read/1` 函数读取文件内容：

```elixir
iex(8)> {:ok, contents} = File.read("my_app.config")
```

在这一行代码中，发生了三件不同的事情：

- 尝试打开并读取文件 `my_app.config`。
- 如果尝试成功，文件的内容将被提取到变量 `contents` 中。
- 如果尝试失败，会引发一个错误。这是因为 `File.read` 的结果是一个形如 `{:error, reason}` 的元组，因此与 `{:ok, contents}` 的匹配失败。

通过在模式中使用常量，你可以严格匹配，确保右侧的某些部分具有特定的值。

### 3.1.4 模式中的变量

当一个变量名出现在左侧模式中时，它总是与相应的右侧项匹配。此外，该变量被绑定到它匹配的项。偶尔，我们并不关心右侧项的某个值，但我们仍然需要进行匹配。例如，假设你想获取当前的时间。你可以使用函数 `:calendar.local_time/0`，它返回一个元组：`{date, time}`。但你并不关心日期，因此不想将其存储到一个单独的变量中。在这种情况下，你可以使用匿名变量`（_）`：

```elixir
iex(1)> {_, time} = :calendar.local_time()

iex(2)> time
{13, 13, 13}
```

在匹配时，匿名变量的工作方式与命名变量完全相同：它可以匹配任何右侧的术语。但术语的值并没有被绑定到任何变量上。您还可以在下划线字符后添加一个描述性名称。

```elixir
iex(3)> {_date, time} = :calendar.local_time()
```

`_date` 被视为一个匿名变量，因为它的名字以下划线开头。从技术上讲，您可以在程序的其他部分使用该变量，但编译器会发出警告。

模式可以任意嵌套。进一步说，假设您只想获取当前的小时：

```elixir
iex(5)> {_, {hour, _, _}} = :calendar.local_time()

iex(6)> hour
13
```

一个变量可以在同一个模式中被引用多次。在下面的表达式中，您期望得到一个RGB三元组，其中每个组件的数值相同：

```elixir
iex(7)> {amount, amount, amount} = {127, 127, 127} # 匹配具有三个相同元素的元组
{127, 127, 127}

iex(8)> {amount, amount, amount} = {127, 127, 1}    # 失败，因为元组元素不相同
** (MatchError) no match of right hand side value: {127, 127, 1}
```

偶尔，你需要匹配变量的内容。为此，提供了pin运算符 `(^)`。最好通过一个例子来解释这一点。

```elixir
iex(1)> expected_name = "Bob"              # 与任何都匹配并绑定到`expected_name`               
"Bob"

iex(2)> {^expected_name, _} = {"Bob", 25}  # 与 expected_name 变量的内容匹配
{"Bob", 25}

iex(3)> {^expected_name, _} = {"Alice", 25}
** (MatchError) no match of right hand side value: {"Alice", 25}
```

在模式中使用 `^expected_name` 表示你期望变量 `expected_name` 的值出现在右侧项的适当位置。在这个例子中，这就相当于使用硬编码模式 `({"Bob", _} = ...)`。因此，第一个匹配成功，但第二个匹配失败。

注意，pin 操作符并不会绑定变量。你期望变量已经绑定到一个值，并尝试匹配那个值。

### 3.1.5 匹配列表

列表匹配的工作方式类似于元组。以下示例分解了一个三元素列表:

```elixir
iex(1)> [first, second, third] = [1, 2, 3]
[1, 2, 3]
```

当然，之前提到的模式技巧也同样适用

```elixir
[1, second, third] = [1, 2, 3]     # 第一个元素必须是1
[first, first, first] = [1, 1, 1]  # 每个元素都必须相同  
[first, second, _ ] = [1, 2, 3]    # 不关心第三个元素，但必须表示
[^first, second, _ ] = [1, 2, 3]   # 第一个元素必须与第一个变量相同
```

匹配列表通常依赖于其递归特性。回想第二章，每个非空列表都是一种递归结构，可以表示为 `[head | tail]` 的形式。你可以使用模式匹配将这两个元素分别放入不同的变量中:

```elixir
iex(2)> [head | tail] = [1, 2, 3]
[1, 2, 3]

iex(3)> head
1

iex(4)> tail
[2, 3]
```

如果你只需要 [头, 尾] 对中的一个元素，可以使用匿名变量。以下是计算列表中最小元素的一种低效方法：

```elixir
iex(5)> [min | _] = Enum.sort([3,2,1])
[1, 2, 3]
```

首先，你对列表进行排序，然后使用模式`[min | _]`，只取（排序后的）列表的头元素。请注意，这也可以使用第2章提到的hd函数来完成。实际上，在这种情况下，hd会更优雅。当你在第3.2节中看到模式`[head | _]`时，会发现它在模式匹配函数参数时更有用。

### 3.1.6 匹配maps

可以使用以下语法匹配maps

```elixir
iex(6)> %{name: name, age: age} = %{name: "Bob", age: 24}
%{name: "Bob", age: 24}

iex(7)> name
"Bob"

iex(8)> age
24
iex
```

在匹配映射时，左侧模式不需要包含右侧术语中的所有键:

```elixir
iex(9)> %{name: name} = %{name: "Bob", age: 24}
%{name: "Bob", age: 24}

iex(10)> name
"Bob"
```

你可能会想知道这样一个部分匹配规则的目的。地图常用于表示结构化数据。在这种情况下，你通常只对map的某些字段感兴趣。例如，在前面的代码片段中，你只想提取name字段，忽略其他所有内容。部分匹配规则正是允许你做到这一点。

当然，匹配一个不存在的key会失败：

```elixir
iex(11)> %{name: name, work: work} = %{name: "Bob", age: 24}
** (MatchError) no match of right hand side value: %{name: "Bob", age: 24}
```

### 3.1.7 匹配比特串和字节序列

在本书中，我们不会过多讨论比特串和字节序列，但提到一些基本的匹配语法是值得的。请记住，比特串是一串位，而字节序列是一种特殊的位字符串，总是按字节大小对齐。

要匹配二进制，您使用的语法类似于创建一个的语法。

```elixir
iex(11)> binary = <<1, 2, 3>>
<<1, 2, 3>>

iex(13)> <<b1, b2, b3>> = binary
<<1, 2, 3>>

iex(14)> b1
1
```

这个例子匹配一个三字节的二进制数据，并将每个字节提取到不同的变量中。下面的例子通过将第一个字节放入一个变量中，其余的二进制数据放入另一个变量中来拆分二进制数据：

```elixir
iex(15)> <<b1, rest :: binary>> = binary
<<1, 2, 3>>

iex(16)> rest
<<2, 3>>
```

`rest::binary`表示你可以预期任意大小数据。你甚至可以提取单独的位或位组。以下示例将一个字节分成两个四位值：

```elixir
iex(17)> <<a :: 4, b :: 4>> = <<155>>
<<155>>
iex(18)> a
9

iex(19)> b
11
```

模式 `a::4` 表示你期望一个四位的值。在这个例子中，你将前四位放入变量 `a`，另外四位放入变量 `b`。因为数字 `155` 在二进制中表示为 `10011011`，所以你得到的值是 `9`（在二进制中为 `1001`）和 `11`（在二进制中为 `1011`）。

匹配比特串和二进制在你试图解析来自文件、外部设备或网络的压缩二进制内容时是非常有用的。在这种情况下，你可以使用二进制匹配优雅地提取单独的比特和字节。

如前所述，这本书中的例子不需要这个功能。不过，你应该记住二进制和模式匹配，以备将来需要时使用。

**MATCHING BINARY STRINGS**

请记住，字符串是字节序列的，因此您可以使用字节序列匹配从字符串中提取单个比特和字节。

```elixir
iex(20)> <<b1, b2, b3>> = "ABC"
"ABC"

iex(21)> b1
65
```

变量 b1、b2 和 b3 保存了您匹配的字符串中的相应字节。这并不是很有用，特别是当您处理 Unicode 字符串时。提取单个字符更好地使用字符串模块中的函数。

更有用的模式是匹配字符串的开头:

```elixir
iex(22)> command = "ping www.example.com"
"ping www.example.com"

iex(23)> "ping " <> url = command
"ping www.example.com"

iex(24)> url
"www.example.com"
```

在这个例子中，你构建一个包含 `ping` 命令的字符串。当你写` "ping " <> url = command` 时，你表示期望命令变量是一个以 `"ping "` 开头的二进制字符串。如果匹配成功，字符串的其余部分将绑定到变量 `url`。

### 3.1.8 符合匹配

你已经见过这个，但让我们明确一下。模式可以任意嵌套，如以下这个人为的例子所示：

```elixir
iex(1)> [_, {name, _}, _] = [{"Bob",25}, {"Alice",30}, {"John",35}]
[{"Bob", 25}, {"Alice", 30}, {"John", 35}]

iex(2)> name
"Alice"
```

在这个例子中，匹配的术语是一个包含三个元素的列表。每个元素是一个元组，表示一个人，由两个字段组成：这个人的姓名和年龄。该匹配提取列表中第二个人的姓名。另一个有趣的功能是匹配链。在您看到它如何工作之前，先让我们更详细地讨论匹配表达式。

匹配表达式具有如下通用形式：

```elixir
pattern = expression
```

如你在例子中看到的，你可以将任何表达式放在右侧:

```elixir
iex(2)> a = 1 + 3 
4
```

让我们分析一下这里发生了什么：
1. 右侧的表达式被求值
2. 结果值与左侧的模式进行匹配。
3. 模式中的变量被绑定。
4. 匹配表达式的结果是右侧项的结果。

这带来的一个重要后果是，匹配表达式可以被链式连接:

```elixir
iex(3)> a = (b = 1+ 3)
4
```

在这个（不太有用的）例子中，发生了以下事情：

1. 表达式 1 + 3 被求值。
2. 结果（4）与模式 b 进行匹配。
3. 内层匹配的结果（再次是 4）与模式 a 进行匹配。

因此，a 和 b 的值都是 4。括号是可选的，许多开发者在这种情况下会省略它们：

 ```elixir
iex(4)> a = b = 1+ 3
4
```

这产生了相同的结果，因为`=`运算符是右结合的。

现在，让我们看看一个更有用的例子。回顾一下函数:`calendar.local_time/0`：

假设你想获取函数的总结果（日期时间）以及当前的小时。以下是一种在单个复合匹配中实现此目的的方法：

```elixir
iex(5)> date_time = {_, {hour, _, _}} = :calendar.local_time()
{{2024, 9, 18}, {14, 44, 40}}

iex(6)> date_time
{{2024, 9, 18}, {14, 44, 40}}

iex(7)> hour
14
```

这是有效的，因为模式匹配的结果始终是正在匹配的项的结果（无论是匹配操作符右侧的内容）。你可以依次与该项的结果进行匹配，并提取你关注的不同部分。

### 3.1.9 通常行为

我们快要完成基本的模式匹配机制了。我们已经学习了很多例子，现在让我们试着形式化一下行为。

模式匹配表达式由两部分组成：模式（左侧）和项（右侧）。在匹配表达式中，会尝试将项与模式进行匹配。如果匹配成功，模式中的所有变量都会绑定到项中对应的值上。整个表达式的结果就是你匹配的整个项。如果匹配失败，就会引发错误。

因此，在模式匹配表达式中，你需要执行两个不同的任务：

1. 你确认对右侧项的期望。如果这些期望没有得到满足，就会引发错误。
2. 你将项的某些部分绑定到模式中的变量上。

最后，值得一提的是，我们并没有涵盖所有可能的模式。有关详细信息，你可以参考官方文档 (https://mng.bz/dd6o)。

匹配运算符 = 只是模式匹配可以使用的一个例子。模式匹配驱动许多其他类型的表达式，尤其在函数中使用时表现得特别强大。

## 3.2 函数匹配

模式匹配机制用于函数参数的规范中。回忆一下基本的函数定义：

```elixir
def my_fun(arg1, arg2) do
  ...
end
```

参数说明符 `arg1` 和 `arg2` 是模式，您可以使用标准匹配技术。让我们看看实际应用。正如第2章所提到的，元组通常用于将相关字段组合在一起。例如，如果您进行几何操作，可以用一个元组 `{a, b}` 表示一个矩形，其中包含矩形的边。以下代码展示了一个计算矩形面积的函数。

```elixir
# “Listing 3.1 Pattern matching function arguments (rect.ex)”
defmodule Rectangle do
  def area({a, b}) do
    a * b
  end 
end
```

请注意你是如何匹配参数的。函数 `Rectangle.area/1` 期望它的参数是一个包含两个元素的元组。然后，它将相应的元组元素绑定到变量中并返回结果。

您可以从 shell 检查这是否有效。启动 shell，然后加载模块：

```shell
$ iex rect.ex
```

然后尝试：

```elixir
iex(9)> Rectangle.area({2,3})
6
```

这里发生了什么？当您调用一个函数时，您提供的参数与函数定义中指定的模式进行匹配。该函数期望一个包含两个元素的元组，并将元组的元素绑定到变量 a 和 b。

调用函数时，被匹配的项是提供给函数调用的参数。您匹配的模式是参数说明符——在这种情况下是 {a, b}。

当然，如果您提供的不是一个包含两个元素的元组，就会引发错误：

```elixir
iex(10)> Rectangle.area(2)
** (FunctionClauseError) no function clause matching in Rectangle.area/1    
```

模式匹配函数参数是一个非常有用的工具。它支撑着 Elixir 的一个重要特性：多条款函数。

### 3.2.1 多条款函数

Elixir 允许通过指定多个条款来重载函数。条款是通过 `def` 表达式指定的函数定义。如果您提供多个具有相同参数个数的相同函数定义，则称该函数具有多个条款。

让我们看看这个如何运作。延续上一个例子，假设您需要开发一个可以处理各种形状的几何模块。您将用元组表示形状，并使用每个元组的第一个元素来指示它表示哪些形状

```elixir
rectangle = {:rectangle, 4, 5}
square = {:square, 5}
circle = {:circle, 4}
```

根据这些形状表示，您可以编写以下函数来计算形状的面积。

```elixir
defmodule Geometry do
  def area({:rectangle, a, b}) do
    a * b 
  end

  def area({:square, a}) do
    a * a
  end

  def area({:circle, r}) do
    r * r * 3.14
  end
end
```

正如你所看到的，你提供了同一个函数的三个子句。根据你传递的参数，相应的子句会被调用。我们从 shell 试一下这个:

```elixir
iex(13)> Geometry.area({:rectangle, 4, 5})
20
iex(14)> Geometry.area({:square, 5})
25
iex(15)> Geometry.area({:circle, 4})
50.24
```

当你调用函数时，运行时会按照源代码中指定的顺序逐个检查其每个条件，并尝试匹配提供的参数。第一个成功匹配所有参数的条件会被执行。

当然，如果没有任何条件匹配，将会引发错误。

```elixir
iex(16)> Geometry.area({:triangle,1,2,3})
** (FunctionClauseError) no function clause matching in Geometry.area/1    
```

从调用者的角度来看，多子句函数是一个单一的函数。您不能直接引用特定的子句。相反，您总是处理整个函数。回想第二章，您可以使用捕获操作符 `& `来创建函数值。

```elixir
&Module.fun/arity
```

捕获 `Geometry.area/1` 就是捕获它的所有子句:

```elixir
iex(16)> fun = &Geometry.area/1
&Geometry.area/1

iex(17)> fun.({:circle, 4})
50.24

iex(18)> fun.({:square, 5})
25
```

这证明了即使一个函数由多个子句组成，它仍然被视为一个整体。

有时，你可能希望一个函数返回一个表示失败的值，而不是抛出错误。你可以引入一个始终匹配的默认子句。让我们为面积函数这样做。下一个列表添加了一个处理任何无效输入的最终子句。

```elixir
# Listing 3.3 Multiclause function (geometry_invalid_input.ex)
defmodule Geometry do
  def area({:rectangle, a, b}) do
    a * b 
  end

  def area({:square, a}) do
    a * a
  end

  def area({:circle, r}) do
    r * r * 3.14
  end

  def area(unknown) do   # 处理不合法输入的子句
    {:error, {:unknown_shape, unknown}}
  end
end
```

如果前三个条件都不匹配，则调用最后一个条件。这是因为变量模式总是与相应的项匹配。在这种情况下，您返回一个包含两个元素的元组 `{:error, reason}`，以指示发生了错误。

```elixir
iex(2)> Geometry.area({:square, 5})
25

iex(4)> Geometry.area({:triangle, 1, 2, 3})
{:error, {:unknown_shape, {:triangle, 1, 2, 3}}}
```

提示：为了使这一切正常工作，重要的是将子句放置在适当的顺序中。运行时会根据源代码中的顺序尝试选择子句。**如果 area(unknown) 子句首先被定义，您将始终得到错误结果**。


请注意，`area(unknown)` 子句仅适用于 `area/1`。如果传递多个参数，这个子句将不会被调用。请回顾第二章，函数在名称和元数上是不同的。因为具有相同名称但不同元数的函数是两个不同的函数，所以无法指定一个无论传递多少参数都会执行的 area 子句。

最后一点：你应该始终将相同函数的子句集中在一起，而不是将它们分散在模块的各个地方。如果一个多子句函数分布在文件的各个地方，将会越来越难以分析该函数的完整行为。即使编译器也会对此投诉，并发出编译警告。

### 3.2.2 守卫

你想写一个函数，接受一个数字并根据该数字的值返回一个原子：`:negative`, `:zero` 或 `:positive`。这在你到目前为止所见的简单模式匹配中是不可能的。Elixir 为此提供了一个解决方案，使用守卫（guards）。

守卫是基本模式匹配机制的扩展。它们允许你声明额外的更广泛的期望，必须满足才能使整个模式匹配。守卫可以通过在参数列表之后提供 `when` 子句来指定。通过示例最好来说明这一点。以下代码测试给定的数字是正数、负数还是零。

```elixir
# Listing 3.4 Using guards (test_num.ex)
defmodule TestNum do
  def test(x) when x < 0 do
    :negative
  end

  def test(x) when x == 0 do
    :zero
  end

  def test(x) when x > 0 do
    :positive
  end
end
```

守卫是一个逻辑表达式，它为模式添加了额外的条件。在这个例子中，我们有三个相同模式（x）的子句，这些子句通常总能匹配。额外的守卫精炼了模式，确保只有在满足给定条件时才会调用该子句，如在下面的 shell 会话中演示的那样。

```elixir
iex(2)> TestNum.test(-1)
:negative

iex(3)> TestNum.test(0)
:zero

iex(4)> TestNum.test(1)
:positive
```

令人惊讶的是，使用非数字调用这个函数会产生奇怪的结果：

```elixir
iex(6)> TestNum.test(:not_a_number)
:positive
```

到底发生了什么？解释在于，Elixir 的术语可以使用 < 和 > 运算符进行比较，即使它们不是同一类型。在这种情况下，类型的顺序决定了结果：

```elixir
number < atom < reference < fun < port < pid <
  tuple < map < list < bitstring (binary)
```


数字总是比任何其他类型小，这就是为什么当您提供非数字时，`TestNum.test/1` 总是返回 :positive。要解决这个问题，您需要通过检查参数是否为数字来扩展守卫条件:

```elixir
defmodule TestNum do
  def test(x) when is_number(x) and x < 0 do
    :negative
  end
 
  def test(x) when x == 0 do
    :zero
  end
 
  def test(x) when is_number(x) and x > 0 do
    :positive
  end
end
```

这段代码使用函数 `Kernel.is_number/1` 来测试参数是否为数字。现在，如果你传递一个非数字的值给 `TestNum.test/1`，程序将引发错误:

```elixir
iex(8)> TestNum.test :not_a_number
** (FunctionClauseError) no function clause matching in TestNum.test/1    
```

可以在守卫中调用的运算符和函数的集合非常有限。特别是，您不能调用您自己的函数，且大多数其他函数将无效。以下是在守卫中允许的运算符和函数的一些示例：

- 比较运算符 (`==`, `!=`, `===`, `!==`, `>`, `<`, `<=`, 和 `>=`)
- 布尔运算符 (`and`, `or`) 和否定运算符 (`not`, `!`)
- 算术运算符 (`+`, `-`, `*`, 和 `/`)
- `Kernel` 模块中的类型检查函数 (例如，`is_number/1`, `is_atom/1` 等等)。

您可以在 https://mng.bz/rjVJ 找到完整的、最新的列表。

在某些情况下，守卫中使用的函数可能会导致错误被引发。例如，`length/1` 仅在用于列表时才有意义。想象一下，您有以下函数，该函数计算非空列表中的最小元素：”

```elixir
defmodule ListHelper do
  def smallest(list) when length(list) > 0 do
    Enum.min(list)
  end
 
  def smallest(_), do: {:error, :invalid_argument}
end
```

你可能认为调用 `ListHelper.smallest/1` 时，如果传入的不是列表会抛出错误，但实际上不会发生这种情况。如果在守卫内抛出了错误，它不会被传播，守卫表达式将返回 `false`。相应的子句不会匹配，但可能会有其他子句匹配。在前面的例子中，如果你调用 `ListHelper.smallest(123)`，你会得到以下结果：{:error, :invalid_argument}。这表明**守卫表达式中的错误是被内部处理的**。


### 3.2.3 多子句Lambdas

匿名函数（lambda）也可以由多个子句组成。首先，回顾一下定义和使用lambda的基本方法。

```elixir
iex(1)> double = fn x -> x * 2 end # 定义lambda

iex(2)> double.(3)                 # 调用lambda
6
```

一般的 lambda 语法具有以下形式：

```elixir
fn 
  pattern_1, pattern_2 ->
    ...           # 当 pattern_1 匹配第一个参数且 pattern_2 匹配第二个参数时执行
  pattern_3, pattern_4 ->
    ...           # 当 pattern_3 匹配第一个参数且 pattern_4 匹配第二个参数时执行
  ...
end
```

让我们通过重新实现 `test/1` 函数来实际看看，它用于检测一个数字是正数、负数还是零。

```elixir
iex(3)> test_num =
...(3)>           fn
...(3)>             x when is_number(x) and x < 0 -> :negative
...(3)>             x when x == 0 -> :zero
...(3)>             x when is_number(x) and x > 0 -> :positive
...(3)>           end
```

请注意，lambda 语句没有特定的结束终止符。该语句在开始一个新语句时（以`pattern ->` 的形式）或 lambda 定义以 `end` 结束时结束。

注意：由于 lambda 的所有子句都在同一个 `fn` 表达式下列出，因此出于约定，省略了每个子句的括号。相比之下，命名函数的每个子句都在一个单独的 `def`（或 `defp`）表达式中指定。因此，建议在命名函数参数周围使用括号。

现在你可以测试这个 lambda 了:

```elixir
iex(4)> test_num.(1)
:positive

iex(5)> test_num.(0)
:zero

iex(6)> test_num.(-1)
:negative
```

多元闭包在使用更高阶函数时非常有用，正如你在本章后面会看到的。不过，目前我们已经结束了关于多元函数的基本理论。它们在条件运行时分支中扮演着重要的角色，这是我们下一个主题。

## 3.3 条件语句

Elixir 提供了一些标准的方法来进行条件分支，例如 `if` 和 `case`。多重子句函数也可以用于这个目的。在本节中，我们将介绍所有的分支技术，从多重子句函数开始。

### 3.3.1 使用多重子句函数进行分支

你已经看到如何使用多重子句来实现条件逻辑，但让我们再看一次:

```elixir
defmodule TestNum do
  def test(x) when x < 0, do: :negative
  def test(0), do: :zero
  def test(x), do: :positive
```

这三个条件子句构成了三个条件分支。在一个典型的命令式语言中，比如`JavaScript`，你可以写出如下代码：

```javascript
funtion test(x){
if (x < 0) return "negative";
if (x == 0)  return "zero";
return "positive";
}
```

可以说，这两个版本的可读性相当。但通过多子句，你可以充分利用模式匹配的所有好处，例如根据数据的形状进行分支。在以下示例中，使用多子句来检测给定列表是否为空：

```elixir
defmodule TestList do
  def empty?([]), do: true
  def empty?([_|_]), do: false
end
```

第一个子句匹配空列表，而第二个子句依赖于非空列表的`head|tail`表示法。

通过依赖模式匹配，你可以实现多态函数，这些函数根据输入类型执行不同的操作。以下示例实现了一个将变量加倍的函数。这个函数的行为取决于它是用数字还是二进制（字符串）调用的。

```elixir
iex(9)> defmodule Polymorphic do
...(9)>           def double(x) when is_number(x), do: 2 * x
...(9)>           def double(x) when is_binary(x), do: x <> x
...(9)>         end

iex(10)> Polymorphic.double(3)
6

iex(11)> Polymorphic.double("Jar")
"JarJar"
```

多重子句的力量在递归中变得明显。生成的代码看起来是声明式的，且没有多余的 `if` 和 `return`。以下是基于多重子句的阶乘递归实现：

```elixir
iex(1)> defmodule Fact do
...(1)>   def fact(0), do: 1
...(1)>   def fact(n), do: n * fact(n - 1)
...(1)> end

iex(2)> Fact.fact 1
1

iex(3)> Fact.fact 3
6
```

多重子句驱动的递归也被用作循环的主要构建块。这将在下一节中详细解释，但这里有一个简单的例子。以下函数对列表中的所有元素进行求和：

```elixir
iex(7)> defmodule ListHelper do
          def sum([]), do: 0
          def sum([head | tail]), do: head + sum(tail)
        end
 
iex(8)> ListHelper.sum([])
0
 
iex(9)> ListHelper.sum([1, 2, 3])
6
```

这个解决方案通过依赖于列表的递归定义来实现求和。空列表的和始终为0，而非空列表的和等于其头部的值加上其尾部的和。

所有可以用经典分支表达式实现的操作，都可以通过多重子句来实现。然而，底层的模式匹配机制通常更具表现力，允许你根据函数参数的值、类型和形状进行分支。不过，在某些情况下，使用经典的命令式分支风格的代码看起来更好。让我们看看在Elixir中还有哪些其他的分支表达式。

### 3.3.2 经典分支表达式

多条件解决方案并不总是合适。使用它们需要创建一个单独的函数并传递必要的参数。有时，使用传统的分支表达式会更简单。在这种情况下，可以使用`if`、`unless`、`cond`和`case`这些表达式。它们的工作方式大致符合你的预期，尽管有一些细微的差别。让我们逐个看一下。


**IF AND UNLESS**

`if` 表达式的语法是大家熟悉的:

```elixir
if condition do
  ...
else
  ...
end
```

这会导致执行一个分支或另一个分支，取决于条件的真实性。如果条件不是 `false` 或 `nil`，你会进入主分支；否则，将调用 `else` 部分。你也可以像 `def` 表达式一样将其简化为一行代码：

```elixir
if condition, do: something, else: another_thing
```

请记住，Elixir 中的一切都是有返回值的表达式。`if` 表达式返回执行代码块的结果（也就是代码块的最后一个表达式）。

```elixir
iex(1)> if 5 > 3, do: :one
:one

iex(2)> if 5 < 3, do: :one
nil

iex(3)> if 5 < 3, do: :one, else: :two
:two
```

让我们看一个更具体的例子。以下代码实现了一个`max`函数，它返回两个元素中较大的一个（根据 `>`运算符的语义）：

```elixir
def max(a, b) do
  if a >= b, do: a, else: b
end
```

`unless` 表达式也可用，它相当于 `if not ...`。考虑以下 `if` 表达式：

```elixir
if result != :error, do: send_notification(...)
```

这也可以表达为：

```elixir
unless result == :error, do: send_notification(...)
```

**COND**

`cond `表达式可以视为` if-else-if `模式的等价物。它接受一个表达式列表，并执行第一个求值为真值的表达式块：

```elixir
cond do
  expression_1 ->
    ...
  expression_2 ->
    ...
  ...
end
```

`⁠cond` 的结果是相应执行块的结果。如果没有满足任何条件，`⁠cond` 会引发错误。当分支选择超过两个时，`⁠cond` 表达式是一个不错的选择。

```elixir
def call_status(call) do
  cond do
    call.ended_at != nil -> :ended
    call.started_at != nil -> :started
    true -> :pending  # 相当于一个默认子句
  end
end
```

在这个示例中，您正在计算通话的状态。如果 `ended_at` 字段被填充，表示通话已经结束。否则，如果 `started_at` 字段被填充，表示通话已经开始。如果这两个字段都没有被填充，通话就是待处理状态。请注意最后的条件：(true -> :pending)。由于这个条件（true）始终满足，因此这实际上成为了一个后备条件，当之前的条件在 `cond` 表达式中都不满足时会被调用。

**case**

该语句的基本语法如下：

```elixir
case expression do
  pattern_1 ->
    ...
 
  pattern_2 ->
    ...
 
  ...
end
```

这里的“pattern”一词表示它涉及模式匹配。在 `case` 表达式中，提供的表达式会被计算，然后结果会与给定的条件进行匹配。第一个匹配的条件会被执行，对应代码块的结果（最后一个表达式）就是整个 `case` 表达式的结果。如果没有条件匹配，则会抛出错误。基于 `case` 的` max` 函数版本将如下所示：

```elixir
def max(a, b) do
  case a => b do
    true -> a
    false -> b
  end
end
```

`case` 表达式最适合在你不想定义一个单独的多条件函数时使用。除此之外，`case` 和多条件函数之间没有差别。实际上，**通用的 `case` 语法可以直接转换为多条件的方法**：

```elixir
defp fun(pattern_1), do: ...
defp fun(pattern_2), do: ...
...
```

这必须通过函数语法调用：`fun(expression)`。您可以通过使用匿名变量来匹配任何内容，从而指定默认子句:

```elixir
case expression do
  pattern_1 -> ...
  pattern_2 -> ...
  ...

  -> ... # 会匹配所有的默认子句
end
```

正如你所看到的，在 Elixir 中有不同的方法来实现条件逻辑。多重子句提供了更声明式的分支方式，但它们需要你定义一个单独的函数并传递所有必要的参数。经典表达式，比如 if 和 case，更显得命令式，但通常比多重子句方法更简单。选择合适的解决方案取决于具体情况以及个人偏好。

### 3.3.3 with表达式

我们要讨论的最后一个分支表达式是`with`表达式，它在需要链式处理多个表达式并返回第一个失败表达式的错误时非常有用。我们来看一个简单的例子。假设您需要处理用户提交的注册数据。输入是一个映射，键是字符串（"login"、"email"和"password"）。下面是一个输入映射的示例：

```elixir
%{
  "login" => "alice",
  "email" => "some_email",
  "password" => "password",
  "other_field" => "some_value",
  "yet_another_field" => "...",
  ...
}
```

你的任务是将这个映射标准化为只包含`login`、`email`和`password`字段的映射。通常，如果字段集定义良好且事先已知，你可以将键表示为原子。因此，对于给定的输入，你可以返回以下结构：

```elixir
%{login: "alice", email: "some_email", password: "password"}
```

然而，某些必填字段可能在输入映射中不存在。在这种情况下，您需要报告错误，因此您的函数可以有两种不同的结果。它可以返回标准化的用户映射，或返回错误。在这种情况下，惯用的做法是让函数返回` {:ok, some_result}` 或 `{:error, error_reason}`。

在这个练习中，成功的结果是标准化的用户映射，而错误原因是描述性文本。请先编写提取每个字段的辅助函数:

```elixir
defp extract_login(%{"login"=> login}), do: {:ok, login}
defp extract_login(_), do: {:error, "login missing"}

defp extract_email(%{"email" => email}), do: {:ok, email}
defp extract_email(_), do: {:error, "email missing"}

defp extract_password(%{"password" => password}), do: {:ok, password}
defp extract_password(_), do: {:error, "password missing"}
```

在这里，您依赖模式匹配来检测字段的存在。

现在，您需要编写顶层的 `extract_user/1` 函数，来组合这三个函数。下面是使用 `case` 的一种实现方式：

```elixir
def extract_user(user) do
  case extract_login(user) do
    {:error, reason} ->
      {:error, reason}
 
    {:ok, login} ->
      case extract_email(user) do
        {:error, reason} ->
          {:error, reason}
 
        {:ok, email} ->
          case extract_password(user) do
            {:error, reason} ->
              {:error, reason}
 
            {:ok, password} ->
              %{login: login, email: email, password: password}
          end
      end
  end
end
```

这是相当复杂的，考虑到代码组合了三个函数。每次你获取某些东西时，你需要根据结果进行分支，结果会导致三个嵌套的情况。在现实生活中，你通常必须执行更多的验证，因此代码可能很快变得相当麻烦。这正是⁠`with`可以帮助你的地方。`⁠with`特殊形式允许你使用模式匹配来链接多个表达式，验证每个结果是否符合预期模式，并返回第一个意外的结果。

简单来说，⁠`with`的基本结构如下：

```elixir
with pattern_1 <- expression_1,
     pattern_2 <- expression_2,
     ...
 
do
  ...
end
```

你从顶部开始，评估第一个表达式，并将结果与相应的模式进行匹配。如果匹配成功，则继续下一个表达式。如果所有表达式都成功匹配，则进入`⁠do`块，并且`⁠with`表达式的结果是`⁠do`块中最后一个表达式的结果。

然而，如果任何匹配失败，⁠`with`将不会继续评估后续的表达式，而是会立即返回无法匹配的结果。让我们看一个例子：

```elixir
iex(4)> with {:ok, login} <- {:ok, "alice"},
...(4)>      {:ok, email} <- {:ok, "some_email"} do
...(4)>      %{login: login, email: email}
...(4)>         end
%{login: "alice", email: "some_email"}
```

在这里，您通过两个模式匹配来提取登录和电子邮件。然后，评估 `do` 块。`with` 表达式的结果是 `do` 块中表达式的最后结果。表面上，这与以下内容没有区别：

```elixir
iex(5)> with {:ok, login} <- {:error, "login missing"},
...(5)>      {:ok, email} <- {:ok, "email"} do
...(5)>      %{login: login, email: email}
...(5)>  end
{:error, "login missing"}
```

在你的情况下，这正是所需的。掌握这新知识后，重构顶层的 `extract_user` 函数。

```elixir
def extract_user(user) do
  with {:ok, login} <- extract_login(user),
       {:ok, email} <- extract_email(user),
       {:ok, password} <- extract_password(user) do
    %{login: login, email: email}
  end
end
```

如您所见，这段代码更短也更清晰。您提取所需的数据，仅在成功时继续。如果出现错误，则返回第一个“错误”。否则，您将返回标准化后的结构。完整的实现可以在 `user_extraction.ex` 中找到。试一试吧：

```elixir
iex user_extraction.ex
 
iex(1)> UserExtraction.extract_user(%{})
{:error, "login missing"}
 
iex(2)> UserExtraction.extract_user(%{"login" => "some_login"})
{:error, "email missing"}
 
iex(3)> UserExtraction.extract_user(%{
          "login" => "some_login",
          "email" => "some_email"
        })
{:error, "password missing"}
 
iex(4)> UserExtraction.extract_user(%{
          "login" => "some_login",
          "email" => "some_email",
          "password" => "some_password"
        })
{:ok, %{email: "some_email", login: "some_login",
  password: "some_password"}}
```

`with` 特殊形式有一些这里没有介绍的额外特性。我建议你在 https://mng.bz/VRxy 上更详细地研究它。这就是我们对 Elixir 中分支表达式的介绍。现在，是时候看看如何进行循环和迭代了。