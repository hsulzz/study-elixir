# [字节序列(`binary`)，字符串(`string`)和字符列表(`charlist`)](https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/pages/getting-started/binaries-strings-and-charlists.md)

## `Unicode` 和 码点(`code points`)

为了让不同计算机通过不同语言的交流有意义，需要一套标准让一连串的0和1在不同社别见传递时表示相同的意思，`Unicode`标准扮演了这个角色，用于表示我们实际上已知的所有字符，包括 古典的历史文字，emoji，格式，以及控制字符等等。

`Unicode`将所有的字符组织在一张 `code charts`中，每一个字符都被赋予了唯一的数字索引。这个数字索引被称作 `Code Point`

```elixir
# 可以通过？查看码点
iex(1)> ?a
97
```
`Unicode`查询码点使用码点的16进制表达方式，`Elixir`中可以通过`\uXXXX`的形式查看Unicode字符

```elixir
iex(8)> "\u0061"
"a"
iex(9)> "\u0061" == "a"
true
iex(10)> 0x0061 = 97 = ?a
97
```

## UTF-8 和 编码

`code point`是存储的内容，`encode`处理的是如何存储，编码是一种实现，
换句话说，我们需要一种原理将`code point`转换成`bytes`以便于存储在内存，写入硬盘。

`Elixir`使用`UTF-8`编码，每个码点被编码成一串的8位的字节(bytes)，`UTF-8`是一个可变长度的字符编码，他使用1-4个字节来存储每个码点，可以处理所有`Unicode`字符。

```elixir
# `UTF-8`还可以表示图形，一个图形有可能是有多个图形组成的。
# 比如 女性消防员`👩‍🚒` 是由 女孩，消防车和一个0长链接符组成的["👩", "‍", "🚒"]
iex(3)> String.codepoints("👩‍🚒")
["👩", "‍", "🚒"]

# Exlixir把他当成一个字符长
iex(4)> String.length("👩‍🚒")
1
```

如果要查看一个字符串的字节 可以使用`<<0>>`拼接

```elixir
# 查看字节序列 使用`<<0>>`拼接
iex(7)> "👩"<> <<0>>
<<240, 159, 145, 169, 0>>

# 也可以使用`IO.inspect/2`方法查看
iex(11)> IO.inspect "👩" , binaries: :as_binaries
<<240, 159, 145, 169>>
```

# 比特串(`bitstring`)

`Elixir`中使用`<<>>`表示比特串，他是内存中的一串连续的比特位序列。
在比特串中，默认使用8位存储每个数字，也可以通过 `::n`或者`::size(n)`手动指定位数。

```elixir
# 默认8位存储
iex(12)> <<42>> ==<<42::8>>
true

# 修改成6位存储
iex(13)> <<42::6>>
<<42::size(6)>>

iex(18)> <<1::1, 0::1, 1::1, 0::1, 1::1, 0::1>> == <<42::6>>
true

# 如果一个值溢出可以存的范围 会被截断
iex(19)> <<1>> == <<257>>
true

```

## 字节序列(`binary`)

字节序列是一个位数能被8整除的比特串，每个字节序列都是比特串，但是比特串不一定是字节序列。

```elixir
iex(21)> is_binary(<<3::4>>)
false
iex(22)> is_binary(<<3::8>>)
true
```

字节序列/比特串也可以进行模式匹配

```elixir
iex(23)> <<0, 1, x>> = <<0, 1, 2>>
<<0, 1, 2>>

iex(24)> <<0, 1, x>> = <<0, 1, 2, 3>>
** (MatchError) no match of right hand side value: <<0, 1, 2, 3>>
# 在不知道要匹配的比特串长度时，可以使用::binary
iex(24)> <<0, 1, x::binary>> = <<0, 1, 2, 3>>
<<0, 1, 2, 3>>

# 还有一系列其他的修饰符，用于字节序列的模式匹配
iex(25)> <<head::binary-size(2), rest::binary>> = <<0, 1, 2, 3>>
<<0, 1, 2, 3>>
iex(26)> head
<<0, 1>>
```

在`Elixir`中 字符串是一个UTF-8编码的字节序列，每个码点使用1-4个字节。
字符串都是字节序列，但不是所有字节序列都是合法的字符串。

```elixir
iex(27)> is_binary("hello")
true
iex(28)> is_binary(<<239, 191, 19>>)
true
iex(29)> String.valid?(<<239, 191, 19>>)
false
```

`<>`实际是字节序列的连接操作符。

```elixir
iex(30)> "a" <> "ha"
"aha"
iex(31)> <<0, 1>> <> <<2, 3>>
<<0, 1, 2, 3>>
```

我们也可以在字符串上使用 模式匹配

```elixir
iex(32)> <<head, rest::binary>> = "banana"
"banana"
iex(33)> head == ?b
true
iex(34)> rest
"anana"

# 但是 字节序列的模式匹配只作用于字节，对于多个字节存储的字符串，只会匹配第一个字节而非第一个字符。
iex(35)> "ü" <> <<0>>
<<195, 188, 0>>
iex(36)> <<x, rest::binary>> = "über"
"über"
iex(37)> x == ?ü
false
iex(38)> rest
<<188, 98, 101, 114>>
```

## 字符列表(`charlist`)

字符列表是一个码点的列表。

```elixir
iex(39)> [?h, ?e, ?l, ?l, ?o]
~c"hello"
```

iex会将，0-127的数字的列表解释成字符列表，会显示他相应的`ascii`字符。

```elixir
iex(40)> heartbeats_per_minute = [99, 97, 116]
~c"cat"

# 可以使用`inspect/2`强制打印列表中显示的内容
iex(41)> inspect(heartbeats_per_minute, charlists: :as_list)
"[99, 97, 116]"

# 字符串转字符列表
iex(42)> to_charlist("hełło")
[104, 101, 322, 322, 111]

# 字符列表转字符串
iex(43)> to_string(~c"hełło")
"hełło"

# 字符列表拼接需要使用 `++`
iex(44)> ~c"this " ++ ~c"works"
~c"this works"
iex(45)> ~c"this " <> ~c"fails"
error: invalid literal ~c"this " in <<>>
└─ iex:45

** (CompileError) cannot compile code (errors have been logged)
```

