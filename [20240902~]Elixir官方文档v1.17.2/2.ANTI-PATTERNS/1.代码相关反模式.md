# 代码相关反模式

本文档概述了与您的代码以及特定的`Elixir`习语和功能相关的潜在反模式。

## Comments overuse

### Problem

过度使用注释或评论不言自明的代码时，可能会使代码的可读性降低。

### Example

```elixir
# Returns the Unix timestamp of 5 minutes from the current time
defp unix_five_min_from_now do
  # Get the current time
  now = DateTime.utc_now()

  # Convert it to a Unix timestamp
  unix_now = DateTime.to_unix(now, :second)

  # Add five minutes in seconds
  unix_now + (60 * 5)
end
```

### Refactoring

尽可能选择清晰且不言自明的函数名称、模块名称和变量名称。在上述示例中，函数名称很好地解释了该函数的作用，因此您可能不需要在它之前进行注释。该代码还通过变量名称和明确的函数调用很好地解释了操作。

```elixir
# 我们删除了不必要的评论。我们还添加了@five_min_in_seconds模块属性，
# 该属性为“魔法”数字 60 * 5命名，使代码更清晰、更有表现力。
@five_min_in_seconds 60 * 5

defp unix_five_min_from_now do
    now = DateTime.utc_now()
    unix_now = DateTime.to_unix(now, :second)
    unix_now + @five_min_in_seconds
end
```

## Complex `else` clauses in `with`

### Problem

这种反模式指的是将所有错误子句扁平化为单个复杂的`else`块的语句。这种情况对代码的可读性和可维护性有害，因为很难知道错误值来自哪个子句。

### Example

下面例子的这种反模式，是一个函数`open_decoded_file/1`，该函数从文件中读取Base64编码的字符串内容，并返回解码的二进制字符串。该函数使用`with`语句，该语句需要处理两个可能的错误，所有这些错误都集中在一个复杂的`else`块中。

```elixir
def open_decoded_file(path) do
  with {:ok, encoded} <- File.read(path),
       {:ok, decoded} <- Base.decode64(encoded) do
    {:ok, String.trim(decoded)}
  else
    {:error, _} -> {:error, :badfile}
    :error -> {:error, :badencoding}
  end
end
```

在上述代码中，不清楚<-左侧的每个模式与末尾的错误有什么关系。A中的模式越多，代码就越不清晰，不相关的故障就越有可能相互重叠。

### Refactoring

在这种情况下，与其将所有错误处理集中在单个复杂的`else`块中，不如将特定私有函数中的返回类型归一化。通过这种方式，可以专注于成功case，error在更接近它们发生的地方进行规范化，从而导致代码更有条理和可维护。

```elixir
def open_decoded_file(path) do
  with {:ok, encoded} <- file_read(path),
       {:ok, decoded} <- base_decode64(encoded) do
    {:ok, String.trim(decoded)}
  end
end

defp file_read(path) do
  case File.read(path) do
    {:ok, contents} -> {:ok, contents}
    {:error, _} -> {:error, :badfile}
  end
end

defp base_decode64(contents) do
  case Base.decode64(contents) do
    {:ok, decoded} -> {:ok, decoded}
    :error -> {:error, :badencoding}
  end
end
```

// TODO 学完元编程和OTP后再继续