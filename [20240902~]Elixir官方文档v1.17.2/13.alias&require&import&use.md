# [`alias`, `require`, `import`, and `use`](https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/pages/getting-started/alias-require-and-import.md#L1)

为了促进重用，`Elixir`提供了三个指令(`alias`,`require`,`import`)和一个宏(`use`)。

```elixir
# 为模块起别名，方便使用别名调用
alias Foo.Bar, as: Bar

# require用于引入模块中的宏
require Foo

# import引入模块中的函数和宏，可以在调用时，省略模块名前缀
# 下面的例子，可以不用Bar.xx 来调用函数，直接使用xx
import Bar

# use调用Foo中定义的自定义代码作为扩展点
use Foo
```

# `alias`

`alias`用于给模块起别名,也平凡用于定义`shortcuts`,省略`:as`选项，
会自动将模块的最后一部分作为别名。

```elixir
# 下面两个等价
alias Math.List
alias Math.List, as: List

```

`alias`是有语句作用域的，可以在特定的函数中设置别名

```elixir
defmodule M do
    def plus(a, b) do
       # 可以在`plus`函数中以`List`调用函数
        alias Math.List
        a + b
    end

    def miuns(a, b) do
        # miuns函数中调用List则是 `Elixir.List`中的函数
        # 而不是`Math.List`
        a - b
    end
end
```

`alias`别名实际是一个开头大写的标志符，他在编译时会被转换为`atom`,
比如，`String`别名会被转换为`:"Elixir.String"`,

```elixir
iex(5)> is_atom(String)
true
iex(6)> :"Elixir.String" == String
true
```

## `require`

`Elixir`提供宏作为元编程的一种机制，宏在编译时展开。

```elixir
# 模块中的公共函数是全局可用的，但是要使用宏，需要从定义他的模块中导入。
iex(12)> Integer.is_odd(2)
** (UndefinedFunctionError) function Integer.is_odd/1 is undefined or private. However, there is a macro with the same name and arity. Be sure to require Integer if you intend to invoke this macro
    (elixir 1.17.2) Integer.is_odd(2)
    iex:12: (file)

# `Integer.is_odd/1`是一个可用作守卫的宏，需要require之后才能使用。
iex(12)> require Integer
Integer
iex(13)> Integer.is_odd(2)
false

```

## `import`

`import`用于导入宏和函数，只能导入公共函数，私有函数是无法从外部访问的。

```elixir
# 只从模块总导入某个函数 使用only
iex(3)> import List, only: [duplicate: 2]
List
iex(4)> duplicate(:ok, 3)
[:ok, :ok, :ok]
```

`import`也是有作用域的

```elixir
defmodule Math do 
    def func1 do
        import List, only: [duplicate: 2]
        duplicate(:ok, 10)
    end

    def func2 do
     # 这里无法直接通过duplicate调用
    end
end
```

## `use`

`use`用于作为一个扩展点，也就是如果`use`了`FooBar`模块,则允许`FooBar`模块像当前模块注入任何代码，比如导入他自己和其他模块，定义新函数，设置模块的状态等。

```elixir
# 这个例子中， use导入(require)了`ExUnit.Case`模块,
# 然后调用了`__using__/1`回调，允许导入的模块像当前上下文注入代码。
# 一些模块使用此机制向模块中填充一些基本行为，你的模块旨在重写或完成这些行为。
defmodule AssertionTest do
    use ExUnit.Case, async: true

    test "always pass" do 
        assert true
    end
end

# 比如下面的模块，会被变异成他下方的样子 
defmodule Example do 
    use Feature, option: :value
end
## ⬇️⬇️⬇️⬇️⬇️⬇️⬇️

defmodule Example do 
    require Feature
    Featrue.__using__(option: :value)
end

```

`use`允许任意代码运行，如果不阅读他的文档，我们无法知道他带来的副作用。
缩影如果非必需，不要在能使用`import`或`alias`的时候，使用`use`



## 模块嵌套

```elixir
# `Foo.Bar`可以在`Foo`中直接用`Bar`调用，因为他们在一个语义作用域中
defmodule Foo do
    defmoduel Bar do
    end
end

# `elixir`中不必先定义父模块，因为他们之间相互独立
defmodule Foo.Bar do 
end

defmodule Foo do
    alias Foo.Bar 
    # 这里可以用Bar进行调用
end

# 给嵌套的模块起别名，不会将他的父模块带入作用域
# 下面的`A.B.C`可以在用`C`调用,但是无法使用`A.B`调用他的父模块
defmodule A do
    defmodule B do
        defmodule C do
        end
    end
end

alias A.B.C
```

## 多个 `alias`/`import`/`require`/`use`

可以一次引用多个模块，比如引入嵌套在同一个副模块中的字模块

```elixir
alias MyApp.{A, B, C}
```





