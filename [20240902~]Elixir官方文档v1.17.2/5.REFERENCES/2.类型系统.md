# 类型系统

`Elixir`附带了声明类型和规格的语法。

`Elixir`是一个动态类型语言，所以，不会用于编译器去优化或者修改代码，他们可以用于

- 提供文档（比如`ExDoc`在文档中展示类型等）
- 被`Dialyzer`等工具用于分析代码，找出不匹配类型和潜在bug

类型星系通常使用如下属性定义在不同的上下文：

- `@type`
- `@opaque`
- `@typep`
- `spec`
- `callback`
- `macrocallback`

另外，可以使用`@typedoc` 给`@type`定义提供文档

## 示例

```elixir
defmodule StringHelpers do
    @typedoc "A word from the dictionary"
    @type word() :: String.t()

    @spec long_word?(word())  :: boolean()
    def long_word?(word) when is_binary(word) do
        String.length(word) > 8
    end
end
```

- 上面的例子中定义了一个新类型`word()` 等效于`String.t()`

- 使用`@typedoc`来描述`word()`类型，这个信息会被包含在生成的文档中

- 我们使用`word()`标注`long_word?/1`函数的入参，，返回一个`boolean()`

## 类型和类型语法

`Elixir`的类型系统语法与`Erlang`相似，`Erlang`中大多数的内置类型有同样的表现形式：`pid()`,`pid`。
- 支持parameterized types，如`list(integer)`
- 支持remote-type，如`Enum.t()` 
- 整型和原子字面量也可以当作类型，如`1`,`:atom`,`false`
- 所有其他类型都是由预定义类型的联合构建的。
- 某些类型也可以使用它们的syntactical notation来声明,如`[type]`,`{type1,type2,...}`,`<<_ * _>>`
- 使用 `|`管道，表示联合类型，如`type :: atom() | pid() | tuple()`

### 基本类型

```elixir
type ::
      any()                     # 顶部类型，包含所有类型的集合
      | none()                  # 底部类型，不包含任何类型
      | atom()
      | map()                   # 任何map
      | pid()                   # process identifier
      | port()                  # port identifier
      | reference()
      | tuple()                 # tuple of any size

                                ## Numbers
      | float()
      | integer()
      | neg_integer()           # ..., -3, -2, -1
      | non_neg_integer()       # 0, 1, 2, 3, ...
      | pos_integer()           # 1, 2, 3, ...

                                                                      ## Lists
      | list(type)                                                    # proper list ([]-terminated)
      | nonempty_list(type)                                           # non-empty proper list
      | maybe_improper_list(content_type, termination_type)           # proper or improper list
      | nonempty_improper_list(content_type, termination_type)        # improper list
      | nonempty_maybe_improper_list(content_type, termination_type)  # non-empty proper or improper list

      | Literals                # Described in section "Literals"
      | BuiltIn                 # Described in section "Built-in types"
      | Remotes                 # Described in section "Remote types"
      | UserDefined             # Described in section "User-defined types"

```

### 字面量

```elixir
type ::                               ## Atoms
      :atom                           # atoms: :foo, :bar, ...
      | true | false | nil            # special atom literals

                                      ## Bitstrings
      | <<>>                          # empty bitstring
      | <<_::size>>                   # size is 0 or a positive integer
      | <<_::_*unit>>                 # unit is an integer from 1 to 256
      | <<_::size, _::_*unit>>

                                      ## (Anonymous) Functions
      | (-> type)                     # zero-arity, returns type
      | (type1, type2 -> type)        # two-arity, returns type
      | (... -> type)                 # any arity, returns type

                                      ## Integers
      | 1                             # integer
      | 1..10                         # integer from 1 to 10

                                      ## Lists
      | [type]                        # list with any number of type elements
      | []                            # empty list
      | [...]                         # shorthand for nonempty_list(any())
      | [type, ...]                   # shorthand for nonempty_list(type)
      | [key: value_type]             # keyword list with optional key :key of value_type

                                              ## Maps
      | %{}                                   # empty map
      | %{key: value_type}                    # map with required key :key of value_type
      | %{key_type => value_type}             # map with required pairs of key_type and value_type
      | %{required(key_type) => value_type}   # map with required pairs of key_type and value_type
      | %{optional(key_type) => value_type}   # map with optional pairs of key_type and value_type
      | %SomeStruct{}                         # struct with all fields of any type
      | %SomeStruct{key: value_type}          # struct with required key :key of value_type

                                      ## Tuples
      | {}                            # empty tuple
      | {:ok, type}                   # two-element tuple with an atom and any **type**
```

### 内置类型

`Elixir`中定义了下面的类型，作为上面基本类型和字面量类型的快捷方式。

| BUILT-IN TYPE                  | DEFINED AS                                                       |
| :----------------------------- | :--------------------------------------------------------------- |
| term()                         | any()                                                            |
| arity()                        | 0..255                                                           |
| as_boolean(t)                  | t                                                                |
| binary()                       | <<_::_*8>>                                                       |
| nonempty_binary()              | <<_::8, _::_*8>>                                                 |
| bitstring()                    | <<_::_*1>>                                                       |
| nonempty_bitstring()           | <<_::1, _::_*1>>                                                 |
| boolean()                      | true | false                                                     |
| byte()                         | 0..255                                                           |
| char()                         | 0..0x10FFFF                                                      |
| charlist()                     | [char()]                                                         |
| nonempty_charlist()            | [char(), ...]                                                    |
| fun()                          | (... -> any)                                                     |
| function()                     | fun()                                                            |
| identifier()                   | pid() | port() | reference()                                     |
| iodata()                       | iolist() | binary()                                              |
| iolist()                       | maybe_improper_list(byte() | binary() | iolist(), binary() | []) |
| keyword()                      | [{atom(), any()}]                                                |
| keyword(t)                     | [{atom(), t}]                                                    |
| list()                         | [any()]                                                          |
| nonempty_list()                | nonempty_list(any())                                             |
| maybe_improper_list()          | maybe_improper_list(any(), any())                                |
| nonempty_maybe_improper_list() | nonempty_maybe_improper_list(any(), any())                       |
| mfa()                          | {module(), atom(), arity()}                                      |
| module()                       | atom()                                                           |
| no_return()                    | none()                                                           |
| node()                         | atom()                                                           |
| number()                       | integer() | float()                                              |
| struct()                       | %{:__struct__ => atom(), optional(atom()) => any()}              |
| timeout()                      | :infinity | non_neg_integer()                                    |

### Remote types

任何模块都可以定义自己的类型，Elixir中的模块也不例外。例如，`Range`模块定义了表示Range类型：该类型可以称为`Range.t/0`。以类似的方式，字符串是`String.t/0`。

### Maps

map中的键的类型是可以重叠的，如果重叠了，最左侧的会被优先使用，如果map的值包含一个不在允许的映射键中的键，则该值不属于此类型。

如果想表示没有提前定义在map中的keys也被允许，通常使用`optional(any) => any`
`map()`的语法表示是`%{optional(any) => any}`,而不是`%{}`, `%{}`表示的是空map

### Keyword lists

出了`keyword()`和`keyword(t)`之外，编写期望的keyword list也很有用

```elixir
# 这样写让option列表更加清晰，只有指定的值被允许，都是非必需的，顺序也无所谓
@type option :: {:name, String.t()} | {:max, pos_integer} | {:min, pos_integer}
@type options :: [option()]

# 也可以使用已经存在的类型编写
@type option :: {:my_option, String.t()} | Genserver.option()

@spec start_link([option()]) :: GenServer.on_start()
def start_link(opts) do
    {my_opts, gen_server_opts} = Keyword.split(opts, [:my_option])
    GenServer.start_link(__MODULE__, my_opts, gen_server_opts)
end
```

### 自定义类型

使用一下模块属性定义新类型：

- `@type`：公共类型

- `@typep`：私有类型

- `@opaque`：定义 一种类型的内部结构不可见的类型，但类型仍然是公开的。

```elixir
@type type_name :: type
@typep type_name :: type
@opaque type_name :: type

# 类型可以通过将变量定义为参数来参数化；然后这些变量可用于定义类型。
@type dict(key, value) :: [{key, value}]
```

### 定义函数类型

```elixir
# 定义函数类型
@spec function_name(t1, t2) :: return_type

# 定义带守卫的函数类型
@spec function(arg) :: [arg] when arg: atom

# 如果想指定多个变量，可以用逗号隔开
@spec function(arg1, arg2) :: {arg1, arg2} when arg1: atom, arg2: integer

# 变量不添加任何限制时，可以使用`var`定义
@spec function(arg) :: [arg] when arg: var

```

这些守卫的标志只在`@spec`,`@callback`,`macrocallback`中有效

您还可以使用`arg_name :: arg_type`语法在类型规范中命名参数。这在文档中特别有用，作为区分相同类型的多个参数（或类型定义中相同类型的多个元素）的一种方式：

```elixir
@spec days_since_epoch(year :: integer, month :: integer, day :: integer) :: integer
@type color :: {red :: integer, grenn :: integer, blue :: integer}
```

函数定义也可以重载，像普通函数一样

```elixir
@spec function(integer) :: atom
@spec function(atom) :: integer
```

### Behaviours

`Elixir`（和`Erlang`）中的`behaviour`是一种将组件的通用部分（成为`behaviour`模块）从特定部分（成为`callback`模块）中分离和抽象的方法。

行为模块定义了一组函数和宏（称为回调），实现该行为的回调模块必须导出这些函数和宏。这个“接口”标识了组件的特定部分。例如，`GenServer`行为和函数抽象了“server”进程可能希望从特定部分（如该服务器进程必须执行的操作）实现的所有消息传递（发送和接收）和错误报告。

假设我们要为解析数据结构实现一套解析器，例如 JSON解析器，MessagePack解析器。他们都有同样的行为：都提供`parse/1`和`extensions/0`方法，`parse/1`函数返回`Elixir`的结构化数据，`extensions/0`函数返回一个文件扩展列表，可以用于特定类型的数据（比如 JSON文件）

```elixir
defmodule Parser do
    @doc """
    Parses a string.
    """
    @callback parse(String.t) :: {:ok, term} | {:error, atom}

    @doc """
    Lists all supported file extensions.
    """
    @callback extensions() :: [String.t]
end
```

如上例所示，定义回调是为该回调定义规范的问题，由以下部分组成：

- 回调的名称（例子中的`parser`或者`extenions`）
- 回调的参数(`String.t`)
- 回调的返回值类型

采用`Parser`行为的模块，必须实现所有`@callback`定义的函数。

### 实现behaviour

```elixir
defmodule JSONParser do
    @behaviour Parser

    @impl Parser
    def parse(str), do: {:ok, "some json" <> str} # ... parse JSON

    @impl Parser
    def extension, do: [".json"]
end
```

```elixir
defmodule CSVParser do
    @behaviour Parser

    @impl Parser
    def parse(str), do: {:ok, "some csv" <> str} # ... parse CSV

    @impl Parser
    def extensions, do: [".csv"]
```

如果采用给定行为的模块没有实现该行为所需的回调之一，则将生成编译时警告。

### 使用行为

行为很有用，因为您可以将模块作为参数传递，然后您可以调用行为中指定的任何函数,注意为了动态调度模块定义行为并不是必须的，但这些特性都是相辅相成的。
当然也可以直接通过`CSVParser.parse(...)`调用，

```elixir
@spec parse_path(Path.t(), [module()]) :: {:ok, term} | {:error, atom}
def parse_path(filename, parsers) do
  with {:ok, ext} <- parse_extension(filename),
       {:ok, parser} <- find_parser(ext, parsers),
       {:ok, contents} <- File.read(filename) do
    parser.parse(contents)
  end
end

defp parse_extension(filename) do
  if ext = Path.extname(filename) do
    {:ok, ext}
  else
    {:error, :no_extension}
  end
end

defp find_parser(ext, parsers) do
  if parser = Enum.find(parsers, fn parse -> ext in parser.extensions() end) do
    {:ok, parser}
  else
    {:error, :no_matching_parser}
  end
end
```

### Optional callbacks

可选回调是模块非必需实现的回调，通常，行为模块知道他们是否应该根据配置调用这些回调，或者通过`function_exported?/3`或者`macro_exported?/3`检查是否回调已定义。

通过`@optional_callbacks`模块属性定义，接受关键字列表，使用函数或者宏名作为可key，arity作为值

```elixir
defmodule MyBehaviour do
    @callback vital_fun() :: any
    @callback non_vital_fun() :: any
    @macrocallback non_vital_macro(arg :: any) :: Macro.t
    @optional_callbacks non_vital_fun: 0, non_vital_macro: 1
```

### Inpecting behaviours

`@callback`,`@optional_callbacks`属性用来在定义的模块中创建一个`behaviour_info/1`的函数，这个函数用于查询定义在模块中的回调和可选模块。

比如上面的`MyBehaviour`模块中定义的`Optional callbacks`

```elixir
MyBehaviour.behaviour_info(:callbacks)
#=> [vital_fun: 0, "MACRO-non_vital_macro": 2, non_vital_fun: 0]
MyBehaviour.behaviour_info(:optional_callbacks)
#=> ["MACRO-non_vital_macro": 2, non_vital_fun: 0]
```

## Pitfalls(陷阱/误区)

使用类型系统时有几个已知陷阱。

### `string()`类型

`Elixir`不推荐使用`string()`类型，这个类型指向`Erlang`字符串，对应的是`Elixir`中是`charlists`，而不是`UTF-8`编译的字节序列。为避免混淆，在使用`string()`是，`Elixir`会发出警告，请正确使用`charlist()`,`nonempty_charlist()`,`binary()`和`String.t()`。

对于分析工具而言，`String.t()`和`binary()`是一致的。但是，`String.t()`代表的是`UTF-8`编译的字节序列。


## Functions which raise an error

Typespecs不需要指示函数可以引发错误；如果给出无效的输入，任何函数都可能随时失败。过去，Elixir标准库有时会使用`no_return()`来表示这一点，但这些用法已被删除。

`no_return()`类型也不应用于返回但目的是“副作用”的函数，如`IO.puts/1`。在这些情况下，预期返回类型为：ok。

相反，`no_return()`应用作永远无法返回值的函数的返回类型。这包括永远循环调用接收的函数，或专门存在以引起错误的函数，或关闭虚拟机的函数。