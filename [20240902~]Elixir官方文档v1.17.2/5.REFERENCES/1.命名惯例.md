# [命名惯例](https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/pages/references/naming-conventions.md#L1)

根据定义，命名惯例是Elixir语法的子集。一项公约旨在为语言和社区遵循和制定最佳实践。相反，如果您想要超越其惯例的完整引用Elixir语法，请参阅语法引用。

## 大小写规则

`Elixir`要求开发者：
- 使用`snake_case`定义变量，方法，模块属性；
- 使用`CamelCase`形式定义模块名；
- 使用模块名的`snake_case`定义文件名；
- 原子类型可以使用`snake_case`或`CamelCase`，但`Elixir`中通常使用`snake_case`

```elixir
# `snake_case`定义变量, 原子
some_map = %{this_is_a_key: "and a value"}

# `snake_case`定义方法
def this_is_a_function do
    "hello world"
end

```

## 下划线(`_foo`)

`Elixir`有几个场景使用下划线。

不使用的值需要赋值给`_`或者以下划线开头的变量

```elixir
# 不需要contents，则赋值给 `_contents`变量，也可以赋值给`_`，但是`_contents`语义上更明确
{:ok, _contents} = File.read("README.md")
```

使用`_`开头的函数，默认不会被导入。

```elixir
# 定义函数 _wont_be_imported
iex(1)> defmodule Example do
...(1)>     def _wont_be_imported do
...(1)>         :oops
...(1)>     end
...(1)> end
# 引入 Example 模块
iex(3)> import Example
# 调用函数时，提示为定义的函数，说明下划线开头的函数未被导入。
iex(4)> _wont_be_imported()
error: undefined function _wont_be_imported/0 (there is no such import)
└─ iex:4
```

由于此属性，`Elixir`依靠下划线开头的函数添加编译时元数据到模块，这类方法通常形式是`__foo__`，比如每个模块中都有`__info__/1`方法。

```elixir
iex(4)> String.__info__(:functions)
[at: 2, bag_distance: 2, byte_slice: 3, ...]
```

`Elixir`中还包含以两个下划线开头的五个特殊形式：
- `__CALLER__/0`, `__DIR__/0`, `__ENV__/0`, `__MODULE__/0`: 获取当前环境的编译时信息
- `__STACKTRACE__/0`: 获取当前异常的堆栈跟踪信息

## 后置感叹号(`foo!`)

后置感叹号表示一个函数或者宏在失败时，会抛出异常。

很多函数都成对出现，如`File.read/1`和`File.read!/1`,前者返回成功或者失败的二元组，后者返回一个普通值或者抛出异常

```elixir
iex(8)> File.read("./.git/config")
{:ok, "contents"}
iex(9)> File.read("no_such_file.txt")
{:error, :enoent}

iex(11)> File.read!("./.git/config")
"contents"
iex(12)> File.read!("no_such_file.txt")
** (File.Error) could not read file "no_such_file.txt": no such file or directory
```

在需要使用模式匹配处理不同结果时，建议使用不带后置感叹号的形式。

```elixir
case File.read(file) do
    {:ok, body} -> # do something with the `body`
    {:error, reason} -> # handle the error caused by `reason`
end
```

当明确结果应该是成功时，使用后置感叹号更加方便，他会在失败时提供更多有用的错误信息。

在考虑函数的失败案例时，我们严格考虑的是其域内发生的错误，例如无法打开文件。例如，来自无效参数类型的错误，无论函数是否有效，都必须始终引起。异常通常是`ArgumentError`或详细的`FunctionClauseError`：

```elixir
iex(12)> File.read(123)
** (FunctionClauseError) no function clause matching in IO.chardata_to_string/1    
    
    The following arguments were given to IO.chardata_to_string/1:
    
        # 1
        123
    
    Attempted function clauses (showing 2 out of 2):
    
        def chardata_to_string(string) when is_binary(string)
        def chardata_to_string(list) when is_list(list)
    
    (elixir 1.17.2) lib/io.ex:696: IO.chardata_to_string/1
    (elixir 1.17.2) lib/file.ex:371: File.read/1
    iex:12: (file)
iex(12)> 

```

## 后置问号（`foo?`）

返回布尔值的函数以后置问号命名，比如：`Keyword.keyword?/1`,`Mix.debug?/0`,`String.contains?/2`

然而，返回布尔值并在守卫中有效的函数遵循另一个惯例，如下`is_`前缀所述。

## `is_`前缀（`is_foo`)

类型检测和其他以`is_`开头的布尔值检测可以在守卫语句中使用，比如`Integer.is_even/1`,`is_list/1`

这些函数和宏遵循`erlang`的`is_`前缀命名规范，而不是使用后置问号，明确表示他们可以使用在守卫子句中。
未遵循这个规范的类型检测用在守卫子句中不合法，比如`Keyword.keyword?/1`

## 特殊命名

一些命名在`Elixir`中有特殊含义。

### length & size

函数名中包含`size`，表示这个执行时间恒定，因为长度被一起存储在了数据结构中，例如`map_size/1`,`tuple_size/1`

函数名中包含`length`，表示这个执行时间是线性的，因为需要遍历整个数据结构来获取长度，例如`length/1`,`String.length/1`

#### get,fetch,fetch!

当看到操作键值对的`get`,`fetch`和`fetch!`函数时，一般有以下行为：

- `get` key不存在时返回默认值，（通常此数据结构的默认值为`nil`),存在时返回对应value
- `fetch` 当key不存在时，返回`:error`,如果存在，返回`{:ok, value}`
- `fetch!` 当key不存在时，抛异常，如果存在返回其值

例如： `Map.get/2`, `Map.fetch/2`,`Map.fetch!/2`,`Keyword.get/2`,`Keyword.fetch/2`,`Keyword.fetch!/2`

### compare

函数`compare/2`应当返回

- `:lt` 当第一个值，小于第二个
- `:eq` 当两个值相当
- `:gt` 当自一个值大于第二个 

比如`DateTime.compare/2`

请注意，这个特定的惯例对于`Enum.sort/2`很重要,因为他基于期待的返回值。


