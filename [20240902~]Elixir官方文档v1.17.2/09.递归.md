# 递归(Recursion)

`Elixir`中不提供循环结构，使用递归和高阶函数来处理集合。

## 通过递归循环

`Elixir`中的数据是不可变的，因此函数式语言依赖于递归，
函数循环调用直到满足条件停止递归。

```elixir
defmodule Recursion do
    def print_multiple_times(msg,n) when n > 0 do
        IO.puts(msg)
        print_multiple_times(msg, n - 1)
    end

    def print_multiple_times(_mgs, 0) do
        :ok
    end
end

Recursion.print_multiple_times("Hello!", 3)
# Hello!
# Hello!
# Hello!
:ok
```

## `Reduce` 和 映射算法

将列表的值逐步递减到一个的过程，叫做`reduce`归约算法，是函数式编程的核心内容。

```elixir
defmodule  Math do
    def sum_list([head | tail], accumulator) do
        sum_list(tail, head + accumulator) 
    end

    def sum_list([],accumulator) do
        accumulator
    end
end

# 调用
iex(18)> Math.sum_list [1,2,3] ,0
6
```

遍历一个列表中的所有值并映射到另一个列表的过程称作映射算法。

```elixir
defmodule Recursion do
    def double_list([head | tail]) do
        [head *2 | double_list(tail)]
    end

    def double_list([]) do
        []
    end
end

```

但在实际的编程中，很少像上面一样操作列表，`Enum`中提供了相应的方法。

```elixir
# 上面的reduce算法
Enum.reduce([1, 2, 3], 0, fn x, acc -> x + acc end)
# 使用捕获操作符版本
Enum.reduce([1, 2, 3], 0, &+/2)

#上面的map算法
Enum.map([1, 2, 3], fn x -> x * 2 end)
# 使用捕获操作符版本
Enum.map([1, 2, 3], &(&1 * 2))
```