# 控制流

## `case`

`case`用于多次匹配，直到找到匹配类型,基于模式匹配与解构来匹配特定条件，未匹配成功会报错。

```elixir
iex(1)> case {1, 2, 3} do
...(1)>   {4, 5, 6} ->
...(1)>  "This clause won't match"
...(1)> {1, x, 3} ->
...(1)>  "This clause will match and bind x to 2 in this clause"
...(1)>  _ ->
...(1)>    "This clause would match any value"
...(1)> end

"This clause will match and bind x to 2 in this clause"

# 如果需要避免重新赋值，可以使用`^`pin操作符
iex(3)> x=1
1
iex(4)> case 10 do
...(4)> ^x -> "不会匹配"
...(4)> _ -> "会匹配"
...(4)> end
"会匹配"

# 可以通过guards添加额外限制条件
# 下面的例子，只有当x为正时才会匹配成功
iex(5)> case {1,2,3} do
...(5)>  {1,x,3} when x > 0 -> 
...(5)> "匹配成功"
...(5)> _ ->
...(5)> "当前面条件为匹配成功时，会匹配所有"
...(5)> end
"匹配成功"

# 没有匹配成功会报错 `CaseClauseError`
iex(6)> case :ok do
...(6)> :error -> "不会匹配"
...(6)> end
** (CaseClauseError) no case clause matching: :ok
```

## `if/unless`


```elixir
# if的条件如果是`nil`或者`false`则不会执行紧接在do后面的语句。
if nil do
  "This won't be seen"
else
  "This will"
end
"This will"

# if 作用域中改变变量值，只在作用域中生效，如果需要改变一个值，需要在if外部接受
iex(7)> x=1
1
iex(8)> if :a do 
...(8)> x=x+1
...(8)> end
2
# if语句外的x变量值未变
iex(9)> x
1

# 如果需要改变一个值，需要在if外部接受
iex(12)> x=1
1
iex(13)> x=if true do
...(13)>    x=x+1
...(13)> end
2
iex(14)> x
2

```

## `cond`

`cond` 用于检查多个条件，找到第一个不为`false`或`nil`的条件。
如果任何一个都不是`true`则会抛出 `CondClauseError`

```elixir

iex(20)> cond do
...(20)> 2+2 ==5 -> "这个是false"
...(20)> 2*2 ==4 -> "这个是true"
...(20)> end
"这个是true"
```

## 总结

`Elixir`开发者偏向使用模式匹配和守卫，使用`case/2`和 函数定义，因为他们简洁而精确。
如果逻辑无法套用模式匹配和守卫，考虑使用`if/2`，如果有很多条件检测，考虑使用`cond/1`