# [进程(Process)](https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/pages/getting-started/processes.md)

在`Elixir`中，代码跑在进程中，进程间相互隔离，并发相互通过消息进行通信。进程不进是`Elixir`中并发的基础，也是构建分布式和容错性代码的方式。

`Elixir`的进程不同于操作系统进程。`Elixir`中的进程在内存和CPU方面非常轻,，数万甚至数十万个进程同时运行并不罕见。

## 创建进程(spawning processes)

通过自动导入的`spawn/1`函数创建新的进程。

```elixir
# `spawn/1`会在另一个进程中执行函数,平返回函数执行的进程号PID
# 进程会随着给定函数的完成而结束。
iex(2)> pid=spawn(fn -> 1 + 2 end)
#PID<0.107.0>
iex(11)> Process.alive?(pid)
false

# 可以通过`self/0`函数查询自身进程号
iex(12)> self()
#PID<0.104.0>
iex(13)> Process.alive?(self())
true

```

## 发送和接受消息

我们可以用`send/2`发送消息，用`receive/1`接受消息。

```elixir
# `send/2` 需要 目标PID，消息内容两个参数 ,消息被保存在进程的邮箱
iex(4)> send(self(),{:hello,"world"})
{:hello, "world"}

# `receive/1` 搜索当前进程的邮箱进行匹配， 他支持守卫和多子句
iex(5)> receive do
...(5)> {:hello,msg} -> msg
...(5)> {:world,_msg} -> "won't match"
...(5)> end
"world"

# `receive/1` 会一直等待邮箱匹配到对应的消息，也可以设置超时时间。
# 当确定消息已经在邮箱中时，可以将timeout设置成 0
iex(1)> receive do
...(1)>  {:hello, msg} -> msg
...(1)> after
...(1)>  1_000 -> "time out"
...(1)> end
"time out"

# `flush/0` 可以将邮箱中的消息全部清空并打印。
iex(13)> send(self(),"1")
"1"
iex(14)> send(self(),"2")
"2"
iex(15)> flush()
"1"
"2"
:ok
```

## Links

在构建容错系统时，进程和链接发挥着重要作用。`Elixir`进程是隔离的，默认情况下不会共享任何内容。因此，一个进程中的失败永远不会崩溃或破坏另一个进程的状态。然而，链接允许进程在发生故障时建立关系。我们经常将我们的流程与`supervisors`联系起来，`supervisors`检测到死掉的进程时，会重新启动一个进程替代他。

```elixir
# `spawn/1`执行的进程报错时，母进程不会崩溃，因为进程是相互隔离的。
iex(16)> spawn(fn -> raise "oops" end)
#PID<0.105.0>

22:58:42.811 [error] Process #PID<0.105.0> raised an exception
** (RuntimeError) oops

# `spawn_link/1` 可以在子进程报错时，母进程也跟着崩溃。
# 还可以使用`Process.link/1`手动关联。
iex(17)> self()
#PID<0.104.0>
iex(18)> spawn_link(fn -> raise "oops" end)

23:00:31.811 [error] Process #PID<0.106.0> raised an exception
** (RuntimeError) oops
** (EXIT from #PID<0.104.0>) shell process exited with reason: {%RuntimeError{message: "oops"}, []}

```

## 任务(Tasks)

`Tasks`建立在`spawn`函数基础之上，提供更好的错误信息。

```elixir
# 使用`Task.start/1`和`Task.start_link`来代替`spawn/1`和`spawn_link/1`.
# 返回{:ok,pid}
# `Task`还有 `Task.async/1` and `Task.await/1`等方法。
iex(18)> Task.start(fn -> raise "oops" end)
{:ok, #PID<0.108.0>}

23:09:17.693 [error] Task #PID<0.108.0> started from #PID<0.107.0> terminating
** (RuntimeError) oops
    (elixir 1.17.2) src/elixir.erl:386: :elixir.eval_external_handler/3
Function: #Function<43.39164016/0 in :erl_eval.expr/6>
    Args: []

```

## 状态(State)

可以写一个无限循环的进程用于维护状态，接受发消息，下面是一个例子。

```elixir
defmodule KV do
    def start_link do
        Task.start(fn -> loop(%{}) end)
    end

    defp loop(map) do
        receive do
            {:get, key, caller} -> 
                send(caller, Map.get(map, key))
            {:put, key, value} ->
                loop(Map.put(map, key, value))
        end
    end
end


iex(41)> {:ok, pid} = KV.start_link()
{:ok, #PID<0.119.0>}
iex(42)> send(pid, {:put, :hello, :world})
{:put, :hello, :world}
iex(43)> send(pid, {:get, :hello, self()})
{:get, :hello, #PID<0.107.0>}
iex(44)> flush()
:world
:ok

# 可以给pid注册一个名字，可以通过名字像他发送信息
iex(3)> Process.register(pid, :kv)
true
iex(4)> send(:kv, {:get, :hello, self()})
{:get, :hello, #PID<0.104.0>}
iex(5)> flush()
nil
:ok

```

`Elixir`提供了`Agent`之类的抽象，我们一般不需要手动实现上面的操作。

```elixir
iex(6)> {:ok, pid} = Agent.start_link(fn -> %{} end)
{:ok, #PID<0.111.0>}
iex(7)> Agent.update(pid, fn map -> Map.put(map, :hello, :world) end)
:ok
iex(8)> Agent.get(pid, fn map -> Map.get(map, :hello) end)
:world

```