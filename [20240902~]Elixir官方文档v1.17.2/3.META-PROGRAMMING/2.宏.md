# 宏

尽管Elixir尽力为宏提供一个安全的环境，但使用宏编写干净代码的大部分责任都落在了开发人员身上。宏比普通的Elixir函数更难编写，在不必要的时候使用它们被认为是糟糕的风格。

Elixir已经提供了机制，通过使用其数据结构和功能，以简单易读的方式编写您的日常代码。宏只能作为最后的手段使用。记住，显式比隐式更好。清晰的代码比简洁的代码更好。

## 第一个宏

使用`defmacro/2` 定义宏


实现`unless/2`

```elixir

defmodule Unless do
    def fun_unless(clause, do: expression) do 
        if(!clause, do: expression)
    end

    # 宏接受quoted expression,将他们注入到quote，最终返回另一个quoted expression
    defmacro macro_unless(clause, do: expression) do
        quote do
            if(!unquote(clause), do: unquote(expression))
        end
    end
end
```

`Elixir`中的很多结构诸如`unless/2`,`defmacro/2`,`def/2`,`defprotocol/2`都是用纯`Elixir`编写的宏。

我们可以定义任何我们想要的函数和宏，包括那些覆盖`Elixir`提供的内置定义的函数和宏。

唯一的例外是Elixir特殊形式，这些形式在Elixir中没有实现，因此无法被覆盖,可以在`Kernel.SpecialForms`中查看特殊形式的列表。


 ## Macro hygiene

`Elixir`宏具有“late resolution”。这保证了引号中定义的变量不会与该宏展开的上下文中定义的变量冲突。例如：

```elixir
defmodule Hygiene do
  defmacro no_interference do
    quote do: a = 1
  end
end

defmodule HygieneTest do
  def go do
    require Hygiene
    a = 13
    Hygiene.no_interference()
    a
  end
end

HygieneTest.go()
# => 13
```
上面例子中宏注入了`a=1`，但是并没有影响`go/0`函数，如果希望明确影响上下文，可以使用`var!/1`

```elixir
defmodule Hygiene do
  defmacro interference do
    quote do: var!(a) = 1
  end
end

defmodule HygieneTest do
  def go do
    require Hygiene
    a = 13
    Hygiene.interference()
    a
  end
end

HygieneTest.go()
# => 1
```

变量卫生有效，因为Elixir用上下文注释变量，一个quoted变量表现如下：

```elixir
defmodule Sample do
    def quoted do
        qoute do: x
    end
end

Sample.quoted() #=>{:x, [line:3], Sample}
```
请注意，引号变量中的第三个元素是原子 `Sample`，而不是`nil`，它标记变量来自样本模块。因此，Elixir认为这两个变量来自不同的上下文，并相应地处理它们。

Elixir也为`imports`和`aliases`提供了类似的机制。这保证了宏将按照其源模块的指定行为，而不是与宏展开的目标模块发生冲突。在特定情况下，可以通过使用var等宏来绕过卫生var!/2和别名alias!/1，尽管在使用它们时必须小心，因为它们会直接改变用户环境。

有时变量名需要动态创建，`Macro.var/2`可以用于定义新变量。

```elixir
defmodule Sample do
  defmacro initialize_to_char_count(variables) do
    Enum.map(variables, fn name ->
      var = Macro.var(name, nil)
      length = name |> Atom.to_string() |> String.length()

      quote do
        unquote(var) = unquote(length)
      end
    end)
  end

  def run do
    initialize_to_char_count([:red, :green, :yellow])
    [red, green, yellow]
  end
end

> Sample.run() #=> [3, 5, 6]

```

注意`Macro.var/2`的第二个参数。这是正在使用的上下文，并将决定下一节中描述的卫生。另请查看`Macro.unique_var/2`，以获取需要生成具有唯一名称的变量的情况。

## Environment

`__ENV__/0`返回一个`Macro.Env`结构体，包含了很多关于编译环境的有用信息，包裹当前模块，文件，行，定义在当前作用于中的所有变量等。

```elixir
iex(74)> __ENV__.module
nil
iex(75)> __ENV__.file
"iex"
iex(76)> __ENV__.requires
[Application, IEx.Helpers, Kernel, Unless]
iex(77)> require Integer
Integer
iex(78)> __ENV__.requires
[Application, IEx.Helpers, Integer, Kernel, Unless]

```

## 私有宏

`Elixir` 通过`defmacrop`定义私有宏。与私有函数一样，私有宏只能用于定义他的模块，且只在编译时。

```elixir
# 必须在使用私有宏之前定义，否则报错。
iex(79)> defmodule Sample do
...(79)> def four, do: two() + two()
...(79)> defmacrop two, do: 2
...(79)> end
error: cannot invoke macro two/0 before its definition
└─ iex:80: Sample.four/0

** (CompileError) iex: cannot compile module Sample (errors have been logged)
    (elixir 1.17.2) src/elixir_module.erl:186: anonymous fn/9 in :elixir_module.compile/7
    iex:79: (file)
```


