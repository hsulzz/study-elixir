# [Quote and unquote](https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/pages/meta-programming/quote-and-unquote.md#L1)


本指南旨在介绍Elixir中可用的元编程技术。通过自己的数据结构来表示Elixir程序的能力是元编程的核心。

本章首先探索这些结构以及相关的`quote/2`和`unquote/1`结构，因此我们可以在下一个指南中查看宏，并最终构建我们自己的域特定语言。

## Quoting

`Elixir`程序的构建块是一个包含三个元素的元组。比如，函数调用`sum(1, 2, 3)`内部表示为如下形式：

```elixir
# 首个元素是函数名，第二个是包含了元数据的关键字列表，第三个是参数列表
{:sum, [], [1, 2, 3]}
```

可以通过宏`quote/2`获取任何表达式的类似表现形式。

```elixir
iex(48)> quote do: sum(1, 2, 3)
{:sum, [], [1, 2, 3]}
```

操作符也以这种元组表示

```elixir
iex(49)> quote do: 1 + 2
{:+, [context: Elixir, imports: [{1, Kernel}, {2, Kernel}]], [1, 2]}
```

`map`表现为调用`%{}`

```elixir
iex(50)> quote do: %{1 => 2}
{:%{}, [], [{1, 2}]}
```

变量表示为这种triplets，不同是最后一个元素是原子类型，而不是列表：

```elixir
iex(51)> quote do: x
{:x, [], Elixir}
```

在quote更复杂的表达式时，我们可以看到代码以这样的元组表示，这些元组通常嵌套在类似于树的结构中相互嵌套。许多语言会将这种表示称为抽象语法树（AST），Elixir称它们为引号表达：

```elixir
iex(52)> quote do: sum(1, 2 + 3, 4)
{:sum, [],
 [1, {:+, [context: Elixir, imports: [{1, Kernel}, {2, Kernel}]], [2, 3]}, 4]}
```

有时，在处理引号表达式时，恢复文本代码表示可能很有用。这可以用`Macro.to_string/1`来完成：

```elixir
iex(53)> Macro.to_string(quote do: sum(1, 2 + 3, 4))
"sum(1, 2 + 3, 4)"
```

一般来说，上面的元组是按照以下格式构建的：

```elixir
{atom | tuple, list, list | atom}
```
- 第一个元素是一个atom或者另一个相同表现形式的元组
- 第二个元素是一个包含元数据的关键字列表
- 第三个是这个函数的参数列表，或者是atom，当他是atom时，代表这个元组是一个变量。

另外，上面定义的元组，有五个`Elixir`字面值，在引用时，会返回自己（而不是元组）。他们是：

```elixir
:sum         #=> Atoms
1.0          #=> Numbers
[1, 2]       #=> Lists
"strings"    #=> Strings
{key, value} #=> Tuples with two elements
```

## Unquoting

Quoting是关于检索某些特定代码块的内部表示。然而，有时可能需要在我们想要检索的表示中注入一些其他特定的代码块。

例如，有一个`number`的变量，你想要将它注入到一个引用表达式中。

```elixir
iex(57)> number = 13
13
iex(58)> Macro.to_string(quote do: 11 + number)
"11 + number"
```

这个并不是我们想要的，因为`number`并没有被注入，为了注入这个变量，需要使用`unquote/1`

```elixir
iex(59)> number = 13
13
iex(60)> Macro.to_string(quote do: 11 + unquote(number))
"11 + 13"
```

`unquote/1`也可以用于注入函数名

```elixir
iex(62)> Macro.to_string(quote do: unquote(fun)(:world))
"hello(:world)"
```

有时，需要向一个list中注入多个值，比如：有一个 `[1, 2, 6]`的列表，想要将`[3, 4, 5]`注入

```elixir
iex(64)> inner = [3, 4, 5]
[3, 4, 5]
iex(65)> Macro.to_string(quote do: [1, 2, unquote(inner), 6])
"[1, 2, [3, 4, 5], 6]"
```

这时，可以使用`unquote_splicing/1`

```elixir
iex(66)> inner = [3, 4, 5]
[3, 4, 5]
iex(67)> Macro.to_string(quote do: [1, 2, unquote_splicing(inner), 6])
"[1, 2, 3, 4, 5, 6]"
```

Unquote 在写宏时非常有用，开发人员能够接收代码块并将其注入到其他代码块中，这些代码块可用于转换代码或编写在编译期间生成代码的代码。

## Escaping

在某些情况下，您可能需要将此类值注入引号表达式中。要做到这一点，我们首先需要在`Macro.escape/1`的帮助下将这些值转义到引号表达式中：

```elixir
iex(68)> map = %{hello: :world}
%{hello: :world}
iex(69)> Macro.escape(map)
{:%{}, [], [hello: :world]}
```

宏接收引号表达式，并且必须返回引号表达式。然而，有时在执行宏期间，您可能需要处理值，并需要区分值和引号表达式。

换句话说，区分Elixir值（如列表、映射、过程、引用等）和引号表达式很重要,一些值，如整数、原子和字符串，具有等于值本身的引号表达式。其他值，如map，需要显式转换。最后，函数和引用等值根本无法转换为引号表达式。