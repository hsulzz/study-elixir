
# [Domain-Specific Languages](https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/pages/meta-programming/domain-specific-languages.md#L1)


特定域语言（DSL）是针对特定应用域量身定制的语言。您不需要宏来拥有DSL：您在模块中定义的每个数据结构和每个函数都是特定域语言的一部分。

例如，想象一下，我们想实现一个`Validator`模块，该模块提供特定于域的数据验证语言。我们可以使用数据结构、函数或宏来实现它。让我们看看这些不同的DSL会是什么样子：

```elixir
# Data structs
import Validator
validate user, name: [length: 1..100], email: [matches: ~r/*/]

# Functions
user
|> validate_length(:name, 1..100)
|> validate_maches(:email, ~r/@/)

# Macros + modules
defmodule MyValidator do
    use Validator
    validate_length :name, 1..100
    validate_matches :email, ~r/@/
end

MyValidator.validate(user)

```

在上述所有方法中，第一个绝对是最灵活的。如果我们的域规则可以用数据结构进行编码，那么它们是迄今为止最容易编写和实现的，因为Elixir的标准库充满了操作不同数据类型的函数。

第二种方法使用函数调用，这更适合更复杂的API（例如，如果您需要传递许多选项），并且由于管道运算符，在Elixir中读取得很好。

第三种方法使用宏，是迄今为止最复杂的。它将需要更多的代码行来实现，测试既困难又昂贵（与测试简单函数相比），而且它限制了用户如何使用库，因为所有验证都需要在模块中定义。

为了指出这一点，想象一下，你只有在满足给定条件的情况下才想验证某个属性。我们可以通过第一个解决方案轻松实现它，通过相应地操作数据结构，或者通过第二个解决方案，在调用函数之前使用条件（if/else）。然而，除非其DSL得到增强，否则不可能使用宏方法做到这一点。

换句话说：`data > functions > macros`

也就是说，使用宏和模块来构建特定域语言仍然很有用。由于我们在入门指南中探索了数据结构和函数定义，本章将探索如何使用宏和模块属性来处理更复杂的DSL。


## Building our own test case

本章节目标是创建一个名为`TestCase`的模块。

```elixir
defmodule MyTest do
    use TestCase 

    test "arithmetic operations" do
        4 = 2 + 2
    end

    test "list operations" do
        [1, 2, 3] = [1, 2] ++ [3]
    end
end
```

## `test`宏

让我们从创建一个`test`模块开始，在使用时定义和导入

```elixir
defmodule TestCase do
    defmacro __using__(_opts) do
        quote do
            import TestCase
        end
    end

    defmacro test(description, do: block) do
        function_name() = String.to_atom("test " <> description)
        quote do
            def unquote(function_name(), do: unquote(block))
        end
    end
end
```

假设我们定义了`TestCase`在名为`tests.exs`的文件中，可以通过`iex tests.exs`打开他。

```elixir
iex(1)> defmodule MyTest do
...(1)>   use TestCase
...(1)> 
...(1)>   test "hello" do
...(1)>     "hello" = "world"
...(1)>   end
...(1)> end

# 执行
iex(2)> MyTest."test hello"()
** (MatchError) no match of right hand side value: "world"
    iex:5: MyTest."test hello"/0
    iex:2: (file)
```

## 使用属性保存信息

为了完成`TestCase`的实现，需要能够访问定义的所有case，其中一个方式是在运行时，通过`__MODULE__.__info__(:functions)`访问，返回给定模块的所有函数。考虑到我们可能需要存储更多信息，比如每个测试用例的名称，需要一个更有灵活的方法。

模块属性可以用于临时存储，在`__using__/1`实现中，我们要先用一个列表初始化`@tests`的属性，用于保存测试用例名称，这样就可以通过`run`函数调用测试用例。

```elixir
defmodule TestCase do
  @doc false
  defmacro __using__(_opts) do
    quote do
      import TestCase

      # Initialize @tests to an empty list
      @tests []

      # Invoke TestCase.__before_compile__/1 before the module is compiled
      @before_compile TestCase
    end
  end

  @doc """
  Defines a test case with the given description.

  ## Examples

      test "arithmetic operations" do
        4 = 2 + 2
      end

  """
  defmacro test(description, do: block) do
    function_name = String.to_atom("test " <> description)
    quote do
      # Prepend the newly defined test to the list of tests
      @tests [unquote(function_name) | @tests]
      def unquote(function_name)(), do: unquote(block)
    end
  end

  # This will be invoked right before the target module is compiled
  # giving us the perfect opportunity to inject the `run/0` function
  @doc false
  defmacro __before_compile__(_env) do
    quote do
      def run do
        Enum.each(@tests, fn name ->
          IO.puts("Running #{name}")
          apply(__MODULE__, name, [])
        end)
      end
    end
  end
end

```

启动一个IEx,接下来可以定义测试用例并执行他。

```elixir
iex(1)> defmodule MyTest do
...(1)>   use TestCase
...(1)> 
...(1)>   test "hello" do
...(1)>     "hello" = "world"
...(1)>   end
...(1)> end

iex(2)> MyTest.run()
Running test hello
** (MatchError) no match of right hand side value: "world"
    iex:5: MyTest."test hello"/0
    (elixir 1.17.2) lib/enum.ex:987: Enum."-each/2-lists^foreach/1-0-"/2
    iex:2: (file)
iex(2)> 

```

`@before_compile`回调，允许我们在定义完成时，注入代码到模块，除了`@before_compile`还有`@on_definition`，`@after_compile`之类的模块属性，可以在[`Module`](https://hexdocs.pm/elixir/Module.html)文档中查看更多，可以查看更多关于[宏](https://hexdocs.pm/elixir/Macro.html)和[编译环境](https://hexdocs.pm/elixir/Macro.Env.html)的信息

