# 列表和元组

## 列表

`Elixir`使用方括号表示，可以包含任何类型的值。

```elixir
iex(1)> list= [1,1.0,false,nil,"string"]
[1, 1.0, false, nil, "string"]

# 查询列表长度
iex(2)> length(list)
5

# 列表结合 及 去重 操作
iex(3)> list ++ list
[1, 1.0, false, nil, "string", 1, 1.0, false, nil, "string"]
iex(4)> list -- list
[]

# 列表可以通过 `hd/1`,`tl/1`获取头跟剩余的元素
iex(5)> hd(list)
1
iex(6)> tl(list)
[1.0, false, nil, "string"]
# hd获取的list为[]空列表则报错
iex(7)> hd(list--list)
** (ArgumentError) errors were found at the given arguments:

  * 1st argument: not a nonempty list

    :erlang.hd([])
    iex:7: (file)

# charlist 会被当成码点解析
iex(7)> [104, 101, 108, 108, 111]
~c"hello"

```

## 元组

`Elixir` 利用花括号表示元祖，与链表一样，可以存放任意类型的值。

```elixir
iex(1)> tuple={"a",:ok,false,1}
{"a", :ok, false, 1}

# 查看元组长度
iex(2)> tuple_size(tuple)
4
# 按照索引查找元素
iex(3)> elem(tuple,1)
:ok

# 替换对应索引位置的元素
iex(4)> put_elem(tuple,1,"world)
...(4)> ")
{"a", "world)\n", false, 1}

# 往元组里面插值需要引用 Tuple模块
iex(9)> Tuple.append(t1,:error)
{:ok, :error}
```

## 列表和元组的区别

列表在内存中是以链表的形式存储的，操作列表的速度会随着列表的长度线性增长。

```elixir
list = [1, 2, 3]
[1, 2, 3]

# This is fast as we only need to traverse `[0]` to prepend to `list`
[0] ++ list
[0, 1, 2, 3]

# This is slow as we need to traverse `list` to append 4
list ++ [4]
[1, 2, 3, 4]

```

元组是村存在一块连续的内存中的，所以获取长度，以索引访问元素非常快，
但是添加或者操作元素比较昂贵，需要重新开辟另一块新的内存，
不过，元素本身并没有被拷贝，更新元组时，所有的entry在新旧元组间共享。

```elixir
# list 通常使用在返回数量不固定的场景， tuple是定长的。
# split返回 list，因为返回的长度根据输入而决定。
iex(2)> String.split("hello world")
["hello", "world"]
#split_at返回元组，因为长度始终为2
iex(3)> String.split_at("hello world",3)
{"hel", "lo world"}
```

元组还通常与 原子类型一起创建 “打标签的元组”，比如用来返回一个操作的结果有可能成功有可能失败。

```elixir
iex(4)> File.read("~/.zshrc")
{:error, :enoent}

iex(5)> File.read("./01.Intro/intro.md")
{:ok,
 "\n # 简介\n\n ## 安装\n\n ..."}
```

另外`Elixir`也遵循这些规则，比如`list`出了提供了访问头部的方法外，并不支持按索引访问list中的元素