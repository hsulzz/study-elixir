# [模块和函数](https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/pages/getting-started/modules-and-functions.md)

`Elixir`中将多个函数组织在模块中。

`模块`使用`defmodule`宏定义，模块的首字母必须大写，
`函数`使用`def`宏在模块中定义，函数的首字母必须小写或者以下划线开头。

```elixir
defmodule Math do
    def sum(a, b) do
        a + b
    end
end
```

## 编译

很多时候将模块写到文件中，可以方便编译和重用，将上方模块放入到`math.ex`文件中去，
可以使用`elixirc` 进行编译

```shell
# 这将生成一个名为`Elixir.Math.beam`的文件，包含了已定义模块的字节码，
elixir math.ex

# 在同个目录下启动`iex`,模块定义就可用了
iex> Math.sum(1, 2)
3
```
`Elixir`项目一般由3个目录组成：
- `_build`: 包含编译好的工件
- `lib`:  包含`Elixir`代码，通常是`.ex`文件
- `test`: 包含测试代码 ，通常是`exs`文件

实际开发中，使用构建工具`mix`，用于编译以及设定合适的路径，

## 脚本模式

为了学习以及方便，`Elixir`支持脚本模式，执行不会编译任何工件。
使用`elixir`执行脚本

``` shell
elixir math.exs
```

## 函数定义

在模块中，使用`def/2`定义函数，`defp/2`定义私有函数。
`def/2`定义的含义可以在其他模块中调用，但是私有函数只能在当前模块调用。

```elixir
defmodule Math do
    def sum(a, b) do
        do_sum(a, b)
    end

    defp do_sum(a, b) do
        a + b
    end
end

IO.puts Math.sum(1, 2)    #=> 3
IO.puts Math.do_sum(1, 2) #=> ** (UndefinedFunctionError)
```

函数声明也支持守卫和多个字句。如果函数有多个子句，`Elixir`会尝试每个子句，
直到匹配成功。

```elixir
# 这是一个检测一个值是否是0的函数
defmodule Math do
    # zero? 中的问号表示函数返回一个`boolean`
    def zero?(0) do
        true
    end

    def zero?(x) when is_integer(x) do
        false
    end
end

IO.puts Math.zero?(0)         #=> true
IO.puts Math.zero?(1)         #=> false
# 给定参数如果未匹配成功，则会报错。
IO.puts Math.zero?([1, 2, 3]) #=> ** (FunctionClauseError)
IO.puts Math.zero?(0.0)       #=> ** (FunctionClauseError)

# 与 `if`相同，函数定义也支持`do:` 和`do`代码块语法。
# 虽然可以使用`do:`将代码写在一行，但是建议使用`do`代码块。
defmodule Math do
    def zero?(0), do: true
    def zero?(x) when is_integer(x), do: false
end

```

## 默认参数

`Elixir`中函数定义也支持默认参数，使用`\\`的形式定义默认参数。 

```elixir
defmodule Concat do
    def join(a, b, sep \\ " ") do
        a <> sep <> b
    end
end

IO.puts Concat.join("Hello", "world")      #=> Hello world
IO.puts Concat.join("Hello", "world", "_") #=> Hello_world
```

任何表达式都允许作为默认值，但是在函数定义期间不会被计算。只有当函数调用时，
且任何默认值被使用时，表达式才会被计算其默认值。

```elixir
defmodule DefaultTest do
    def dowork(x \\ "hello") do
        x
    end
end
```
``` elixir
iex(13)> DefaultTest.dowork()
"hello"
iex(14)> DefaultTest.dowork(123)
123
iex(15)> DefaultTest.dowork()
"hello"
```

多个字句的函数如果有默认值，需要在模块的头部声明带有默认值的函数。

```elixir
defmodule Concat do
    # 函数头部定义默认值
    def join(a, b \\ nil, sep, \\ " ") 

    #当一个参数在函数或者字句中不被使用，在参数头部添加`_`表明意图。
    def join(a, b, _sep) when is_nil(b) do
        a
    end

    def join(a, b, sep) do
        a <> sep <> b
    end
end

IO.puts Concat.join("Hello", "world")      #=> Hello world
IO.puts Concat.join("Hello", "world", "_") #=> Hello_world
IO.puts Concat.join("Hello")               #=> Hello
```

需要避免下面这种情况。

```elixir
defmodule Concat do 
    def join(a, b) do 
        IO.puts "***First join"
        a <> b
    end

    def join(a, b, sep \\ " ") do
        IO.puts "***Second join"
        a <> sep <> b
  end
end

# 编译器会提示如下警告， 传递两个参数时，`join/2`始终会选择第一个函数。
# 删除默认值可以消除警告
warning: this clause for join/2 cannot match because a previous clause at line 17 always matches
└─ iex:22

```
