# [Enum cheatsheet](https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/pages/cheatsheets/enum-cheat.cheatmd#L1)


`Enum`模块提供了操作集合的方法。

下面的所有例子都是用这个集合。

```elixir
cart = [
  %{fruit: "apple", count: 3},
  %{fruit: "banana", count: 1},
  %{fruit: "orange", count: 6}
]
```

## Predicates

### any?(enum, fun)

```elixir

iex(7)> Enum.any?(cart, & &1.fruit == "orange")
true
iex(9)> Enum.any?(cart, & &1.fruit == "pear")
false

# any?与空集合相比，始终返回false
iex(10)> Enum.any?([], & &1.fruit == "orange")
false
```

### all?(enum, fun)

```elixir
iex(11)> Enum.all?(cart, & &1.count > 0)
true
iex(12)> Enum.all?(cart, & &1.count > 1)
false

# all?与空集合相比，始终返回true
iex(13)> Enum.all?([], & &1.count > 0)
true
```

### member?(enum, value)

```elixir
iex(14)> Enum.member?(cart, %{fruit: "apple", count: 3})
true
iex(15)> Enum.member?(cart, :something_else)
false

# `item in enum` 与 `Enum.member?(enum, item)`等效
iex(16)> %{fruit: "apple", count: 3} in cart
true
```

### empty?(enum)

```elixir
iex(17)> Enum.empty?(cart)
false
iex(18)> Enum.empty?([])
true
```

## Filtering

### filter(enum, fun)

```elixir
iex(19)> Enum.filter(cart, &(&1.fruit =~ "o"))
[%{count: 6, fruit: "orange"}]

```

### reject(enum, fun)

```elixir
iex(20)> Enum.reject(cart, &(&1.fruit =~ "o"))
[%{count: 3, fruit: "apple"}, %{count: 1, fruit: "banana"}]
```

### Comprehension

```elixir
[%{count: 3, fruit: "apple"}, %{count: 1, fruit: "banana"}]
iex(21)> for item <- cart, item.fruit =~ "e" do 
...(21)>  item
...(21)> end
[%{count: 3, fruit: "apple"}, %{count: 6, fruit: "orange"}]

# 模式匹配
iex(23)> for %{count: 1, fruit: fruit} <- cart do
...(23)>   fruit
...(23)> end
["banana"]
```

## Mapping

### map(enum, fun)

```elixir
iex(24)> Enum.map(cart, & &1.fruit)
["apple", "banana", "orange"]

iex(25)> Enum.map(cart, fn item ->
...(25)>   %{item | count: item.count + 10}
...(25)> end)
[
  %{count: 13, fruit: "apple"},
  %{count: 11, fruit: "banana"},
  %{count: 16, fruit: "orange"}
]
```

### map_every(enum, nth, fun)

```elixir
iex(26)> Enum.map_every(cart, 2, fn item ->
...(26)>   %{item | count: item.count + 10}
...(26)> end)
[
  %{count: 13, fruit: "apple"},
  %{count: 1, fruit: "banana"},
  %{count: 16, fruit: "orange"}
]

```

### Comprehension

```elixir
# map 也可以使用推导式
iex(3)> for item <- cart do
...(3)>   item.fruit
...(3)> end
["apple", "banana", "orange"]

iex(4)> for item <- cart, item.fruit =~ "e" do
...(4)>   item.fruit
...(4)> end
["apple", "orange"]
```

## Side-effects

### each(enum, fun)

```elixir
iex(6)> Enum.each(cart, &IO.puts(&1.fruit))
apple
banana
orange
:ok
```

## Accumulating

### reduce(enum, acc, fun)

```elixir
iex(7)> Enum.reduce(cart, 0, fn item, acc ->
...(7)> item.count + acc
...(7)> end)
10
```

### map_reduce(enum, acc, fun)

```elixir
iex(8)> Enum.map_reduce(cart, 0, fn item, acc ->
...(8)>   {item.fruit, item.count + acc}
...(8)> end)
{["apple", "banana", "orange"], 10}
```

### scan(enum, acc, fun)

```elixir
iex(13)> Enum.scan(cart, 0, fn item, acc ->
...(13)>   item.count + acc
...(13)> end)
[3, 4, 10]
```

### reduce_while(enum, acc, fun)

```elixir
iex(15)> Enum.reduce_while(cart, 0, fn item, acc ->
...(15)>   if item.fruit == "orange" do
...(15)>     {:halt, acc}
...(15)>   else
...(15)>     {:cont, item.count + acc}
...(15)>   end
...(15)> end)
4
```

### Comprehension

```elixir
iex(16)> for item <- cart, reduce: 0 do
...(16)>   acc -> item.count + acc
...(16)> end
10

iex(17)> for item <- cart, item.fruit =~ "e", reduce: 0 do
...(17)>   acc -> item.count + acc
...(17)> end
9
```

## Aggregations

### count(enum)

```elixir
iex(18)> Enum.count(cart)
3
```

### count(enum, fun)

```elixir
iex(23)> Enum.count(cart, & &1.fruit =~ "e")
2
```

### frequncies(enum)

```elixir
iex(19)> Enum.frequencies(["apple", "banana", "orange", "apple"])
%{"apple" => 2, "banana" => 1, "orange" => 1}
```

### frequncies_by(enum, key_fun)

```elixir
iex(21)> Enum.frequencies_by(cart, &String.last(&1.fruit))
%{"a" => 1, "e" => 2}
```

### sum(enum)

```elixir
iex(24)> cart |> Enum.map(& &1.count) |> Enum.sum()
10
```

### product(enum)

```elixir
iex(25)> cart |> Enum.map(& &1.count) |> Enum.product()
18
```

## Sorting

### sort(enum, sorter \\ :asc)

```elixir
iex(27)> cart |> Enum.map(& &1.fruit) |> Enum.sort
["apple", "banana", "orange"]

iex(29)> cart |> Enum.map(& &1.fruit) |> Enum.sort(:desc)
["orange", "banana", "apple"]
```

### sort_bu(enum, mapper, sorter \\ :asc)

```elixir
iex(30)> Enum.sort_by(cart, & &1.count)
[
  %{count: 1, fruit: "banana"},
  %{count: 3, fruit: "apple"},
  %{count: 6, fruit: "orange"}
]

  iex(31)> Enum.sort_by(cart, & &1.count, :desc)
[
  %{count: 6, fruit: "orange"},
  %{count: 3, fruit: "apple"},
  %{count: 1, fruit: "banana"}
]
```

### min(enum)

```elixir
iex(32)> cart |> Enum.map(& &1.count) |> Enum.min
1
```

### min_by(enum, mapper)

```elixir
iex(33)> Enum.min_by(cart, & &1.count)
%{count: 1, fruit: "banana"}
```

### max(enum)

```elixir
iex(34)> cart |> Enum.map(& &1.count) |> Enum.max()
6
```

### max_by(enum, mapper)

```elixir
iex(35)> Enum.max_by(cart, & &1.count)
%{count: 6, fruit: "orange"}
```

## Concatenating & flattening

### concat(enum)

```elixir
iex(36)> Enum.concat([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
[1, 2, 3, 4, 5, 6, 7, 8, 9]
```

### concat(left, right)

```elixir
iex(38)> Enum.concat([1, 2, 3], [4, 5, 6])
[1, 2, 3, 4, 5, 6]
```

### flat_map(enum, fun)

```elixir
iex(43)> Enum.flat_map(cart, fn item ->
...(43)>    List.duplicate(item.fruit, item.count)
...(43)> end)
["apple", "apple", "apple", "banana", "orange", "orange", "orange", "orange",
 "orange", "orange"]
```

### flat_map_reduce(enum, acc, fun)

```elixir
iex(44)> Enum.flat_map_reduce(cart, 0, fn item, acc ->
...(44)>   list = List.duplicate(item.fruit, item.count)
...(44)>   acc = acc + item.count
...(44)>   {list, acc}
...(44)> end)
{["apple", "apple", "apple", "banana", "orange", "orange", "orange", "orange",
  "orange", "orange"], 10}
```

### Comprehension

```elixir
iex(45)> for item <- cart,
...(45)>     fruit <- List.duplicate(item.fruit, item.count) do
...(45)>   fruit
...(45)> end

```

## Conversion

### into(enum, cllectable)

```elixir
iex(46)> pairs = [{"apple", 3}, {"banana", 1}, {"orange", 6}]
[{"apple", 3}, {"banana", 1}, {"orange", 6}]
iex(47)> Enum.into(pairs, %{})
%{"apple" => 3, "banana" => 1, "orange" => 6}
```

### into(enum, collectable, transform)

```elixir
iex(48)> Enum.into(cart, %{}, fn item ->
...(48)>   {item.fruit, item.count}
...(48)> end)
%{"apple" => 3, "banana" => 1, "orange" => 6}
```

### to_list(enum)

```elixir
iex(49)> Enum.to_list(1..5)
[1, 2, 3, 4, 5]
```

### Comprehension

```elixir
iex(50)> for item <- cart, into: %{} do
...(50)>     {item.fruit, item.count}
...(50)> end
%{"apple" => 3, "banana" => 1, "orange" => 6}
```

## Duplicates & uniques

### dedup(enum)

```elixir
# 只删除相邻的重复值
iex(51)> Enum.dedup([1, 2, 2, 3, 3, 3, 1, 2, 3])
[1, 2, 3, 1, 2, 3]
```

### dedup_by(enum, fun)

```elixir
iex(52)> Enum.dedup_by(cart, & &1.fruit =~ "a")
[%{count: 3, fruit: "apple"}]
```

### uniq(enum)

```elixir
iex(53)> Enum.uniq([1, 2, 2, 3, 3, 3, 1, 2, 3])
[1, 2, 3]
```

### uniq_by(enum)

```elixir
iex(54)> Enum.uniq_by(cart, &String.last(&1.fruit))
[%{count: 3, fruit: "apple"}, %{count: 1, fruit: "banana"}]
```

## Indexing

### at(enum, index, default \\ nil)

```elixir
iex(55)> Enum.at(cart, 0)
%{count: 3, fruit: "apple"}
```

### fetch(enum, index)

```elixir
iex(58)> Enum.fetch(cart, 0)
{:ok, %{count: 3, fruit: "apple"}}
```

### fetch!(enum, index)

```elixir
iex(60)> Enum.fetch!(cart, 10)
** (Enum.OutOfBoundsError) out of bounds error
    (elixir 1.17.2) lib/enum.ex:1084: Enum.fetch!/2
    iex:60: (file)
```

### with_index(enum)

```elixir
iex(61)> Enum.with_index(cart)
[
  {%{count: 3, fruit: "apple"}, 0},
  {%{count: 1, fruit: "banana"}, 1},
  {%{count: 6, fruit: "orange"}, 2}
]
```

### with_index(enum, fun)

```elixir
iex(62)> Enum.with_index(cart, fn item, index ->
...(62)>   {item.fruit, index}
...(62)> end)
[{"apple", 0}, {"banana", 1}, {"orange", 2}]
```

## Finding

### find(enum, default \\ nil, fun)

```elixir
iex(63)> Enum.find(cart, &(&1.fruit =~ "o"))
%{count: 6, fruit: "orange"}

```

### find_index(enum, fun)

```elixir
iex(65)> Enum.find_index(cart, & &1.fruit =~ "o")
2
```

### find_value(enum, default \\ nil, fun)

```elixir
iex(66)> Enum.find_value(cart, fn item ->
...(66)>   if item.count == 1, do: item.fruit, else: nil
...(66)> end)
"banana"

iex(67)> Enum.find_value(cart, :none, fn item ->
...(67)>   if item.count == 100, do: item.fruit, else: nil
...(67)> end)
:none
```

## Grouping

### group_by(enum, key_fun)

```elixir
iex(68)> Enum.group_by(cart, &String.last(&1.fruit))
%{
  "a" => [%{count: 1, fruit: "banana"}],
  "e" => [%{count: 3, fruit: "apple"}, %{count: 6, fruit: "orange"}]
}
```

### group_by(enum, key_fun, value_fun)

```elixir
iex(69)> Enum.group_by(cart, &String.last(&1.fruit), & &1.fruit)
%{"a" => ["banana"], "e" => ["apple", "orange"]}
```

## Joining & interspersing

### join(enum, joiner \\ " ")

```elixir
iex(1)> Enum.join(["apple", "banana", "orange"], ", ")
"apple, banana, orange"
```

### map_join(enum, joiner \\ "", mapper)

```elixir
iex(5)> Enum.map_join(cart, ", ", & &1.fruit)
"apple, banana, orange"
```

### intersperse(enum, separator \\ "")

```elixir
iex(6)> Enum.intersperse(["apple", "banana", "orange"], ", ")
["apple", ", ", "banana", ", ", "orange"]
```

### map_intersperse(enum, separator \\ "", mapper)

```elixir
iex(8)> Enum.map_intersperse(cart, ", ", & &1.fruit)
["apple", ", ", "banana", ", ", "orange"]
```

## Slicing

### slice(enum, index_range)

```elixir
iex(9)> Enum.slice(cart, 0..1)
[%{count: 3, fruit: "apple"}, %{count: 1, fruit: "banana"}]

# 负数range 从后往前数
iex(10)> Enum.slice(cart, -2..-1)
[%{count: 1, fruit: "banana"}, %{count: 6, fruit: "orange"}]
```

### slice(enum, start_index, amount)

```elixir
iex(11)> Enum.slice(cart, 1, 2)
[%{count: 1, fruit: "banana"}, %{count: 6, fruit: "orange"}]
```

### slide(enum, range_or_single_index, insertion_index)

```elixir
iex(12)> fruits = ["apple", "banana", "grape", "orange", "pear"]
["apple", "banana", "grape", "orange", "pear"]
iex(13)> Enum.slide(fruits, 2, 0)
["grape", "apple", "banana", "orange", "pear"]
iex(14)> Enum.slide(fruits, 1..3, 0)
["banana", "grape", "orange", "apple", "pear"]

```

## Reversing

### reverse(enum)

```elixir
iex(15)> Enum.reverse(cart)
[
  %{count: 6, fruit: "orange"},
  %{count: 1, fruit: "banana"},
  %{count: 3, fruit: "apple"}
]
```

### reverse(enum,tail)

```elixir
iex(16)> Enum.reverse(cart, [:this_will_be, :the_tail])
[
  %{count: 6, fruit: "orange"},
  %{count: 1, fruit: "banana"},
  %{count: 3, fruit: "apple"},
  :this_will_be,
  :the_tail
]
```

### reverse_slice(enum, start_index, count)

```elixir
iex(17)> Enum.reverse_slice(cart, 1, 2)
[
  %{count: 3, fruit: "apple"},
  %{count: 6, fruit: "orange"},
  %{count: 1, fruit: "banana"}
]
```

## Splitting

### split(enum, amount)

```elixir
iex(18)> Enum.split(cart, 1)
{[%{count: 3, fruit: "apple"}],
 [%{count: 1, fruit: "banana"}, %{count: 6, fruit: "orange"}]}
```

### split_while(enum, fun)

```elixir
iex(19)> Enum.split_while(cart, &(&1.fruit =~ "e"))
{[%{count: 3, fruit: "apple"}],
 [%{count: 1, fruit: "banana"}, %{count: 6, fruit: "orange"}]}

```

### split_with(enum, fun)

```elixir
iex(20)> Enum.split_with(cart, &(&1.fruit =~ "e"))
{[%{count: 3, fruit: "apple"}, %{count: 6, fruit: "orange"}],
 [%{count: 1, fruit: "banana"}]}
```

## Splitting(drop and take)

### drop(enum, amount)

```elixir
iex(21)> Enum.drop(cart, 1)
[%{count: 1, fruit: "banana"}, %{count: 6, fruit: "orange"}]
```

### drop_every(enum, nth)

```elixir
iex(22)> Enum.drop_every(cart, 2)
[%{count: 1, fruit: "banana"}]
```

### drop_while(enum, fun)

```elixir
iex(25)> Enum.drop_while(cart, &(&1.fruit =~ "e"))
[%{count: 1, fruit: "banana"}, %{count: 6, fruit: "orange"}]
```

### take(enum, amount)

```elixir
iex(26)> Enum.take(cart, 1)
[%{count: 3, fruit: "apple"}]
```

### take_every(enum, nth)

```elixir
iex(27)> Enum.take_every(cart, 2)
[%{count: 3, fruit: "apple"}, %{count: 6, fruit: "orange"}]
```

### take_while(enum, fun)

```elixir
iex(28)> Enum.take_while(cart, &(&1.fruit =~ "e"))
[%{count: 3, fruit: "apple"}]
```

## Random

### random(enum)

```elixir
iex(29)> Enum.random(cart)
%{count: 3, fruit: "apple"}
```

### take_random(enum, count)

```elixir
iex(30)> Enum.take_random(cart, 2)
[%{count: 1, fruit: "banana"}, %{count: 6, fruit: "orange"}]
```

### shuffle(enum)

```elixir
iex(31)> Enum.shuffle(cart)
[
  %{count: 3, fruit: "apple"},
  %{count: 6, fruit: "orange"},
  %{count: 1, fruit: "banana"}
]
```

## Chunking

### chunk_by(enum, fun)

```elixir
iex(32)> Enum.chunk_by(cart, &String.length(&1.fruit))
[
  [%{count: 3, fruit: "apple"}],
  [%{count: 1, fruit: "banana"}, %{count: 6, fruit: "orange"}]
]
```

### chunk_every(enum, count)

```elixir
iex(35)> Enum.chunk_every(cart, 2)
[
  [%{count: 3, fruit: "apple"}, %{count: 1, fruit: "banana"}],
  [%{count: 6, fruit: "orange"}]
]
```

### chunk_every(enum, count, step, leftover \\ [])

```elixir
iex(36)> Enum.chunk_every(cart, 2, 2, [:elements, :to_complete])
[
  [%{count: 3, fruit: "apple"}, %{count: 1, fruit: "banana"}],
  [%{count: 6, fruit: "orange"}, :elements]
]
```

## Zipping

### zip(enum1, enum2)

```elixir
iex(37)> fruits = ["apple", "banana", "orange"]
["apple", "banana", "orange"]
iex(38)> counts = [3, 1, 6]
[3, 1, 6]
iex(39)> Enum.zip(fruits, counts)
[{"apple", 3}, {"banana", 1}, {"orange", 6}]
```

### zip_with(enum1, enum2, fun)

```elixir
iex(40)> fruits = ["apple", "banana", "orange"]
["apple", "banana", "orange"]
iex(41)> counts = [3, 1, 6]
[3, 1, 6]
iex(42)> Enum.zip_with(fruits, counts, fn fruit, count ->
...(42)>   %{fruit: fruit, count: count}
...(42)> end)
[
  %{count: 3, fruit: "apple"},
  %{count: 1, fruit: "banana"},
  %{count: 6, fruit: "orange"}
]
```

### zip_reduce(left, right, acc, fun)

```elixir
iex(43)> fruits = ["apple", "banana", "orange"]
["apple", "banana", "orange"]
iex(44)> counts = [3, 1, 6]
[3, 1, 6]
iex(45)> Enum.zip_reduce(fruits, counts, 0, fn fruit, count, acc ->
...(45)>   price = if fruit =~ "e", do: count * 2, else: count
...(45)>   acc + price
...(45)> end)
19
```

### unzip(list)

```elixir
iex(46)> cart |> Enum.map(&{&1.fruit, &1.count}) |> Enum.unzip()
{["apple", "banana", "orange"], [3, 1, 6]}
```