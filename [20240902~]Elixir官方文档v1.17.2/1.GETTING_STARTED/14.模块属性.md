# 模块属性

模块属性在`Elixir`中，主要有3个目的：
- 作为模块和函数的注解
- 编译时，做一个临时的模块存储
- 编译时，作为一个常量

## 作为注解

`Elixir`从`Erlang`中引入了模块属性的概念。
`Elixir`中预留了很多属性，下面是一些常见的。
- `@moduledoc`: 当前模块的文档
- `@doc`: 当前方法或宏的文档
- `@spec`: 函数的类型
- `@behaviour`: 定义一个OTP或者用户定义的行为

```elixir
# 定义模块文档，`Elixir`把文档当成一等公民，提供了很多方法去访问文档
# `Elixir`提倡使用Markdown写可阅读的文档。
defmodule Math do
  @moduledoc """
  Provides math-related functions.

  ## Examples

      iex> Math.sum(1, 2)
      3

  """

  @doc """
  Calculates the sum of two numbers.
  """
  def sum(a, b), do: a + b
end
```

## 作为临时存储

```elixir
# 访问未定义的属性会报warning
defmodule MyServer do
  @unknown
end
warning: undefined module attribute @unknown, please remove access to @unknown or explicitly set it before access

# 可以在函数中访问属性
defmodule MyApp.Status do
  @service URI.parse("https://example.com")
  def status(email) do
    SomeHttpClient.get(@service)
  end
end

# 模块属性定义在编译阶段，返回的是他的值，而非函数调用
# 上面的模块将被编译成下方的样子
defmodule MyApp.Status do
  def status(email) do
    SomeHttpClient.get(%URI{
      authority: "example.com",
      host: "example.com",
      port: 443,
      scheme: "https"
    })
  end
end
```

这个在提前计算值然后将结果注入到模块时很有用，模块编译完成后，这个模块属性将被丢弃，除了函数需要读取的属性。
不能调用同一个模块中的函数作为属性，因为此时函数还未被定义。

每次在函数中读取属性时,`Elixir`都会获取当前值的快照，因此，如果在多个函数中多次读取同一个属性，最终会增加编译时间，因为`Elixir`会保存每一次的快照。

```elixir
# 避免下面的写法
def some_function, do: do_something_with(@example)
def another_function, do: do_something_else_with(@example)

# 推荐
def some_function, do: do_something_with(example())
def another_function, do: do_something_else_with(example())
defp example, do: @example
```

## 作为编译时常量

模块属性也可以用作常量，但是通常来说，函数通常更适合定义常量

```elixir
# 不建议
@hours_in_a_day 24

# 推荐
defp hours_in_a_day(), do: 24
```

在很多项目中，都会有一个模块叫做`MyApp.Constants`用来定义所有常量。

```elixir
# 数据结构在`Elixir`中是不可变的，只要他没有任何可执行表达式，只有一个数据结构的实例被分配和共享。
defp system_config(), do: %{timezone: "Etc/UTC", locale: "pt-BR"}
```

作为编译时常量的使用场景是在编译时需要做一些处理之后将其值注入到函数，最常见的是作为模式或者守卫（`defguard/1`的代替方案）

```elixir
# Inside pattern
@default_timezone "Etc/UTC"
def shift(@default_timezone), do: ...

# Inside guards
@time_periods [:am, :pm]
def shift(time, period) when period in @time_periods, do: ...
```

模块参数通常是一起用做常量和临时存储的，用于计算和保存比较昂贵的值，然后作为常量暴露


库和框架可以利用模块参数提供自定义注解。

```elixir
# 具体tag如何生效的参考 元编程
defmodule MyTest do
    use ExUnit.Case, async: true

    @tag :external
    @tag os: :unix
    test "contacts external service" do
        # ...
    end
end
```