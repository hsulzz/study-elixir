# [协议](https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/pages/getting-started/protocols.md#L1)

结构是一个实现多态的机制，让`Elixir`可以根据数据类型实现不同行为。

```elixir
# 利用 模式匹配和 守卫 来实现多态
# 但是 这种方式的问题在于要为新的类型定义一个新的`type/1`函数，扩展性很差
defmodule Utility do
    def type(value) when is_binary(value), do: "string"
    def type(value) when is_integer(value), do: "integer"
    # ...
end
```

协议解决的上面使用模式匹配扩展性差的问题，他允许我们扩展原始行为。
任何已实现协议的数据类型都可以使用协议的调度，任何人都可以随时实现协议。

```elixir
# 使用defprotocol/2 定义协议
defprotocol Utility do
  @spec type(t) :: String.t()
  def type(value)
end

# 使用`defimpl/1`定义实现，`Elixir`会根据数据类型调度到合适的实现。
defimpl Utility, for: BitString do
  def type(_value), do: "string"
end

defimpl Utility, for: Integer do
  def type(_value), do: "integer"
end

```

## 示例

实现一个获取数据结构元素长度的协议（接口）

```elixir
# 定义协议
defprotocol Size do
    @doc "计算数据结构元素长度的"
    def size(data)
end

# 实现
defimpl Size, for: BitString do
    def size(string), do: byte_size(string)
end

defimpl Size, for: Map do
  def size(map), do: map_size(map)
end

defimpl Size, for: Tuple do
  def size(tuple), do: tuple_size(tuple)
end
```

## 协议和结构体

```elixir
defmodule User do
  defstruct [:name, :age]
end

defimpl Size, for: User do
 # 可以随意实现
  def size(_user), do: 2
end
```

## 实现`Any`

为所有类型实现协议重复且枯燥，`Elixir`提供了2个选项：
- 可以明确地导出我们类型的协议实现，或自动实现所有类型的协议。
- 需要为Any实施协议。

### 推导

`Elixir`允许基于`Any`的实现推导出接口实现

```elixir
# 这个实现比较粗，不合理
defimpl Size, for: Any do
    def size(_), do: 0
end
```

然而，如果我们对`Any`的实现没有意见，为了使用这种实现，我们需要告诉我们的结构显式推导`Size`协议。

```elixir 
# 下面这个`OtherUser`则会基于`Any`的实现来实现Size协议
defmodule OtherUser do
    @derive [Size]
    defstruct [:name,:age]
 end   
```
### Fallback to `Any`

另一个`@derive`的替代方案是在接口中指明，如果无法找到对应类型的实现fallback to any。可以通过`@fall_back_to_any true`来实现

```elixir
defmodule Size do
    @fallback_to_any true
    def size(data)
end
```

## 内置协议

`Elixir`提供了很多内建协议，比如`Enum`模块提供了很多方法用于已经实现了`Enumerable`协议的数据结构。

```elixir
iex(16)> Enum.map([1,2,3],&(&1*2))
[2, 4, 6]
```

另外一个比较有用的例子是`String.Chars`协议，他定义了如何将数据结构转换成string，暴露了一个`to_string`函数

```elixir
iex(18)> to_string(:hello)
"hello"

# 字符串插值 也调用了to_string
"age: #{25}"
"age: 25"
```

可以使用`inspect`函数打印复杂的数据结构，他基于`Insepct`协议。

```elixir
iex(20)> tuple = {1, 2, 3}
{1, 2, 3}
iex(21)> "tuple: #{inspect(tuple)}"
"tuple: {1, 2, 3}"
```



