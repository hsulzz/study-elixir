# [Debugging](https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/pages/getting-started/debugging.md#L1) 


## `IO.inspect/2`

`IO.inspect(item, opts \\ [])`在调试时很有用，因为它返回传递给它的项目参数item，而不会影响原始代码的行为。

```elixir
(1..10)
|> IO.inspect()
|> Enum.map(fn x -> x * 2 end)
|> IO.inspect()
|> Enum.sum()
|> IO.inspect()

# 返回结果
iex(2)> (1..10) |> IO.inspect() |> Enum.map(&(&1 * 2)) |> IO.inspect() |> Enum.sum() |> IO.inspect()
1..10
[2, 4, 6, 8, 10, 12, 14, 16, 18, 20]
110
110
```

`IO.inspect/2`可以用`label`选项标注输出：

```elixir
iex(3)> [1, 2, 3] |> IO.inspect(label: "before") |> Enum.map(&(&1 * 2)) |> IO.inspect(label: "after") |> Enum.sum

# 返回结果，标签会在被加在item前面
before: [1, 2, 3]
after: [2, 4, 6]
12

```

`IO.inspect/2`和`binding/0`搭配使用，可以返回他的变量名和值

```elixir
def some_func(a, b, c) do
    IO.inspect binding()
    ...
end

# 当`some_func`以`:foo`,"bar",":baz"调用
# 输出结果如下
[a: :foo, b: "bar", c: :baz]

```

## `dbg/2`

`Elixir` v1.14开始提供`dbg/2`函数，他与`IO.inspect/2`很相似，不过他是专为调试量身定制的。他不仅能返回传递给他的值，还能打印出代码和位置。

```elixir
iex(4)> feature = %{name: :dbg, inspiration: "Rust"}
iex(5)> dbg(feature)
[iex:5: (file)]
feature #=> %{name: :dbg, inspiration: "Rust"}

%{name: :dbg, inspiration: "Rust"}
iex(6)> dbg(Map.put(feature, :in_version, "1.14.0"))
[iex:6: (file)]
Map.put(feature, :in_version, "1.14.0") #=> %{name: :dbg, inspiration: "Rust", in_version: "1.14.0"}
```

`IO.inspect/2`需要在每个步骤都添加，`dbg/2`加在管道符最后，会打印出每一个结果

```elixir
__ENV__.file
|> String.split("/", trim: true)
|> List.last()
|> File.exists?()
|> dbg()

# 结果
[dbg_pipes.exs:5: (file)]
__ENV__.file #=> "/home/myuser/dbg_pipes.exs"
|> String.split("/", trim: true) #=> ["home", "myuser", "dbg_pipes.exs"]
|> List.last() #=> "dbg_pipes.exs"
|> File.exists?() #=> true
```

## Pry

当使用`IEx`时，可以传递`--dbg pry` 选项，在调用`dbg`的地方暂停代码执行。

```shell
$ iex --dbg pry

# 也可以在项目中调用

iex --dbg pry -S mix
```

接下来就可以在`IEx`中调用`dbg`,任何调用`dbg`的地方都会询问是否pry当前代码，如果同意，您将能够直接从IEx访问所有变量，以及从代码导入和别名。

## 断点

`dbg`调用要求我们更改我们打算调试的代码，并且具有有限的步进功能。幸运的是，`IEx`也提供了`IEx.break!/2`函数，允许您在任何`Elixir`代码上设置和管理断点，而无需修改其源代码。

与`dbg`类似，一旦达到断点，代码执行就会停止，直到调用continue（或c）或next（或n）。默认情况下，断点可以逐行导航，但是，在编译模块上设置断点时，它们无法访问别名和导入。

`mix test`任务通过`-b/--breakpoints`标志直接与断点集成。当使用标志时，每个将要运行的测试的开头都会设置一个断点：

```elixir
# Debug all failed tests
iex -S mix test --breakpoints --failed
# Debug the test at the given file:line
iex -S mix test -b path/to/file:line
```

## Observer

对于调试复杂的系统，跳转代码是不够的。有必要了解整个虚拟机、流程、应用程序，并设置跟踪机制。幸运的是，这可以在`Erlang`通过`:observer`实现。

```elixir
:observer.start()

# mix中需要如下执行

Mix.ensure_application!(:wx)             # Not necessary on Erlang/OTP 27+
Mix.ensure_application!(:runtime_tools)  # Not necessary on Erlang/OTP 27+
Mix.ensure_application!(:observer)
:observer.start()
```


// TODO

需要再精读跟hands-on 