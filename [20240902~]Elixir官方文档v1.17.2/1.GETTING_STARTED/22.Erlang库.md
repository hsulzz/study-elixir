# [Erlang 库](https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/pages/getting-started/erlang-libraries.md#L1)

`Elixir`提供了与`Erlang`库优秀的互操作性，`Elixir`不鼓励简单包装`Erlang`库，而是直接调用。
与`Elixir`的模块命名不同，`Erlang`以小写字母开头，模块名称都是原子，我们通过发送到模块名称来调用函数：

```elixir
iex(2)> is_atom(String)
true
iex(3)> String.first("hello")
"h"
iex(4)> is_atom(:binary)
true
iex(5)> :binary.first("hello")
104
```

## binary模块

`Elixir`内置的`String`模块处理`UTF-8`编码的字节序列，`:binary`模块在不是处理`UTF8`字节序列时很有用。

```elixir
# string返回码点
iex(3)> String.to_charlist("Ø")
[216]
# :binary返回原始数据字节
iex(4)> :binary.bin_to_list("Ø")
[195, 152]
```

## 格式化文本输出

`Elixir`中不包含像C语言中一样的`printf`之类的函数，`Erlang`标准库中提供了`:io.format/2`和`:io_lib.format/2`函数可以使用，前者将格式化内容输出到终端，后者输出到iolist,格式与`printf`不同。

```elixir

iex(5)> :io.format("PI is :~10.3f~n",[:math.pi])
PI is :       3.142
:ok

iex(8)> to_string(:io_lib.format("Pi is approximately given by:~10.3f~n", [:math.pi]))
"Pi is approximately given by:     3.142\n"
```

## crypto模块

`:crypto`模块包含hashing函数，数字签名，加密等

```elixir
iex(9)> Base.encode16(:crypto.hash(:sha256, "Elixir"))
"3315715A7A3AD57428298676C5AE465DADA38D951BDFAC9348A8A31E9C7401CB"
```

`:crypto`模块是`:crypto`应用的一部分，必须在配置添加,任何不包含在`:kernel`或`:stdlib`的`erlang`应用都必须明确罗列在`mix.exs`。

```elixir
# 编辑`mix.exs`
def application do
    [extra_applications: [:crypto]]
end
```

## digraph模块

`:digraph`模块和`:digraph_utils`模块包含了处理有向图的函数。构建图后，其中的算法将有助于找到，例如，两个顶点之间的最短路径，或图中的循环。

```elixir
digraph = :digraph.new()
coords = [{0.0, 0.0}, {1.0, 0.0}, {1.0, 1.0}]
[v0, v1, v2] = (for c <- coords, do: :digraph.add_vertex(digraph, c))
:digraph.add_edge(digraph, v0, v1)
:digraph.add_edge(digraph, v1, v2)
:digraph.get_short_path(digraph, v0, v2)
[{0.0, 0.0}, {1.0, 0.0}, {1.0, 1.0}]
```

## ETS

模块`:ets`和`:dets`分别在内存或磁盘上处理大型数据结构的存储。
ETS允许您创建一个包含元组的表。默认情况下，ETS表受到保护，这意味着只有所有者进程可以写入表，但任何其他进程都可以读取。ETS有一些功能，允许将表用作简单数据库、键值存储或缓存机制
Ets模块中的函数将作为副作用来修改表的状态。

```elixir
iex(4)> table = :ets.new(:ets_test, [])
iex(5)> :ets.insert(table, {"China", 1_374_000_000})
iex(6)> :ets.insert(table, {"China", 1_374_000_000})
iex(7)> :ets.insert(table, {"USA", 322_000_000})
iex(8)> :ets.i(table)
<1   > {<<"China">>,1374000000}
<2   > {<<"USA">>,322000000}

```

## math模块

`:math`模块包含了通用的数学运算，涵盖了三角学，指数和对数的函数。

```elixir
iex>angle_45_deg = :math.pi()*45.0 / 180.0
iex>:math.sin(angle_45_deg)
0.7071067811865475
```

## queue模块

`:queue`模块提供了一个数据结构实现了FIFO队列。

```elixir
iex(10)> q = :queue.new
{[], []}
iex(11)> q = :queue.in("A",q)
{["A"], []}
iex(12)> q = :queue.in("B",q)
{["B"], ["A"]}
iex(13)> {value, q} = :queue.out(q)
{{:value, "A"}, {[], ["B"]}}
iex(14)> {value, q} = :queue.out(q)
{{:value, "B"}, {[], []}}
iex(15)> {value, q} = :queue.out(q)
{:empty, {[], []}}
```

## rand模块

`:rand`具有返回随机值和设置随机种子的函数。

```elixir
iex(19)> _ = :rand.seed(:exs1024,{123, 123534, 345345})
iex(20)> :rand.uniform()
0.5820506340260994
iex(21)> :rand.uniform(8)
6
iex(22)> :rand.uniform(10)
9
```

## zip和zlib模块

`:zip`模块可以从硬盘或者内存中读写ZIP文件，也可以提取文件信息。
`:zlib`用于处理zlib格式的压缩数据。
```elixir
# 计算zip文件中文件数量
:zip.foldl(fn _, _, _, acc -> acc + 1 end, 0, :binary.bin_to_list("file.zip"))
{:ok, 633}

# zlib压缩和解压
iex(24)> song = "Mary had a little lamb,His fleece was white as snow,And everywhere that Mary went,The lamb was sure to go."
"Mary had a little lamb,His fleece was white as snow,And everywhere that Mary went,The lamb was sure to go."
iex(25)> compressed = :zlib.compress(song)
<<120, 156, 37, 140, 187, 13, 132, 48, 16, 5, 91, 121, 5, 88, 244, 64, 70, 66,
  70, 3, 11, 188, 99, 45, 25, 91, 178, 151, 91, 209, 61, 191, 108, 130, 153, 25,
  165, 158, 80, 89, 33, 72, 209, 44, 17, 73, 246, 57, 12, 177, ...>>
iex(26)> byte_size(song)
106
iex(27)> byte_size(compressed)
95
iex(28)> :zlib.uncompress(compressed)
"Mary had a little lamb,His fleece was white as snow,And everywhere that Mary went,The lamb was sure to go."

```

## 学习Erlang

// TODO https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/pages/getting-started/erlang-libraries.md#L1