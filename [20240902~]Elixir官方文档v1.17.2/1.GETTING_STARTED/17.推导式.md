# [Comprehensions](https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/pages/getting-started/comprehensions.md#L1)


推导式是一个语法糖,用于循环可枚举对象，用`for`，推导式有三个部分组成，`generators`,`filters`,`collectables`

```elixir
for n <- [1, 2, 3, 4], do: n * n
```

## Generators and filters

上面的例子中`n <- [1, 2, 3, 4]`是`generator`,他循环生成值传给推导式，任何可枚举类型都可以放在gnerator表达式的右侧。

```elixir
for n <- 1..4, do: n * n
```

`generator`表达式的左侧也支持模式匹配，未匹配的都会被忽略。

```elixir
values = [good: 1, good: 2 ,bad: 3, good: 4]

 for {:good,n} <- values, do: n * n

```

```elixir
# 可以使用`filter`过滤，filter表达式返回false,nil以外都会被选择。
for n <- 0..5, rem(n, 3) == 0, do: n * n
```

与使用`Enum`和`Stream`模块的等效函数相比，理解通常提供更简洁的表示,推导式同时支持多个`generator`和`filter`

```elixir

dirs = ["/home/mikey","/home/james"]
# 多个`filter`
for dir <- dirs,
    file = File.ls!(dir),
    path = Path.join(dir,file),
    File.regular?(path) do
  File.stat!(path).size
end

# 多个`generator`
iex(34)> for i <- [:a, :b, :c], j <- [1, 2], do:  {i, j}
[a: 1, a: 2, b: 1, b: 2, c: 1, c: 2]
```

## 比特串generator

```elixir
pixels = <<213, 45, 132, 64, 76, 32, 76, 0, 0, 234, 32, 15>>
for <<r::8, g::8, b::8 <- pixels>>, do: {r, g, b}
[{213, 45, 132}, {64, 76, 32}, {76, 0, 0}, {234, 32, 15}]
```

## `:into`选项


```elixir
# 推导式的额结果可以使用`:into`塞进不同的数据结构
# `:into`接受任何实现了`Collectable`协议的数据结构中。
iex>for <<c <- " hello world ">>, c != ?\s, into: "", do: <<c>>
"helloworld"

iex>for {key, val} <- %{"a" => 1, "b" => 2}, into: %{}, do: {key, val * val}
%{"a" => 1, "b" => 4}

iex>stream = IO.stream(:stdio, :line)
iex>for line <- stream, into: stream do
  String.upcase(line) <> "\n"
end
```




