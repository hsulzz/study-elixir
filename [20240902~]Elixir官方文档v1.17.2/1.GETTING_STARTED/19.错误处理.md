# [try ,catch 和 rescue](https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/pages/getting-started/try-catch-and-rescue.md#L1)

`Elixir`有三个错误机制：`errors`,`throws`,`exits`

## Errors

Errors用于代码中发生的异常。

```elixir
iex(64)> :foo+1
** (ArithmeticError) bad argument in arithmetic expression: :foo + 1
    :erlang.+(:foo, 1)
    iex:64: (file)
```

可以使用`raise/1`抛出 运行时错误

```elixir
iex(64)> raise "error "
** (RuntimeError) error 
    iex:64: (file)
```

可以使用`raise/2` 传递错误名称和一个关键词列表，抛出指定错误

```elixir
iex(64)> raise ArgumentError , message: "invalid argument"
** (ArgumentError) invalid argument
    iex:64: (file)
```

可以使用`defexception/1`定义自己的错误,错误名称与模块名相同

```elixir
defmodule MyError do
    defexception message: "default message"
end

iex(65)> raise MyError
** (MyError) default message
    iex:65: (file) 
```

可以捕捉异常使用`try/rescue`结构

```elixir
iex(66)> try do
...(66)>     raise "oops"
...(66)> rescue
...(66)>     e in RuntimeError -> e.message
...(66)> end
"oops"
```

实际开发者很少使用`try/rescue`结构，比如，很多语言在打开文件失败是，强制捕捉error，`Elixir`中提供`File.read/1`返回一个元组，不管打开文件是否成功。

```elixir
iex(67)> File.read("hello")
{:error, :enoent}
iex(68)> File.write("hello", "world")
:ok
iex(69)> File.read("hello")
{:ok, "world"}

# 使用`case`结构处理不同结果
case File.read("hello") do
    {:ok, body} -> IO.puts("success")
    {:error, reason} -> IO.puts("Error")
end
```

## Reraise

使用`try/rescue`的一个场景是观察和记录，当发生错误时，记录log

```elixir
# 在格式化和re-raising异常时，使用 __STACKTRACE__结构，
# 这确保我们不改变其的值和来源
try do
# ...some code...
rescue
    e -> 
        Logger.error(Exception.format(:error,e, __STACKTRACE__))
        reraise e, __STACKTRACE__
end
```

## Throws

`Elixir`可以将一个值抛出，之后再catch,`throw`和`catch`用于无法查询值的情况下使用。

```elixir
iex(70)> try do
...(70)>   Enum.each(-50..50, fn x ->
...(70)>     if rem(x, 13) == 0, do: throw(x)
...(70)>   end)
...(70)>   "Got nothing"
...(70)> catch
...(70)>   x -> "Got #{x}"
...(70)> end
"Got -39"
```

## Exits

`Elixir`的代码在进程中执行，同时相互通信，当一个进程由于`natrual causes`（比如未处理的异常）挂掉，他发送一个`exit`信号，名称发送一个`exit`信号也会终止进程。

```elixir
iex(72)> spawn_link(fn -> exit(1) end)
** (EXIT from #PID<0.104.0>) shell process exited with reason: 1

# `exit`也可使用`try/catch`捕捉
iex(72)> try do
...(72)>   exit("I am exiting")
...(72)> catch
...(72)>   :exit, _ -> "not really"
...(72)> end
"not really"
```

`catch`可以直接在函数中使用，无需配套`try`

```elixir
defmodule Example do
    def matched_catch do
        exit(:timeout)
    catch
        :exit, :timeout ->
            {:error, :timeout}
    end
    def mismatched_catch do
        exit(:timeout)
    catch
        # Since no clause matches, this catch will have no effect
        :exit, :explosion ->
        {:error, :explosion}
    end
end
```

## After

有时需要保证资源在某些作业之后被清理，否则会引起错误。可以使用`try/after`

```elixir
# `after`语句不论`try`语句是否成功都会执行。
{:ok, file} = File.open("sample", [:utf8, :write])
try do
    IO.write(file,"yes")
    raise "oops, someting went wrong"
after
    File.close(file)
end
** (RuntimeError) oops, something went wrong
```

```elixir
# 有时希望用try包裹整个方法，下面这种写法可以实现。
# 只要`after`,`rescue`或者`catch`任意一个被指定，
# elixir都会默认用try包裹整个方法。
iex(74)> defmodule RunAfter do
...(74)>   def without_even_trying do
...(74)>     raise "oops"
...(74)>   after
...(74)>     IO.puts "cleaning up!"
...(74)>   end
...(74)> end
{:without_even_trying, 0}
iex(75)> RunAfter.without_even_trying
cleaning up!
```

## Else

`else` 语句当`try`代码块没有跑异常时会匹配

```elixir
iex(75)> x = 2
2
iex(77)> try do
...(77)>   1 / x
...(77)> rescue
...(77)>   ArithmeticError ->
...(77)>     :infinity
...(77)> else
...(77)>   y when y < 1 and y > -1 ->
...(77)>     :small
...(77)>   _ ->
...(77)>     :large
...(77)> end
:small

```

## 变量作用域

与`case`,`cond`,`if`等结构相似，变量只作用于定义的代码块内

```elixir
# what_happened 无法从外部访问
iex(79)> try do
...(79)>   raise "fail"
...(79)>   what_happened = :did_not_raise
...(79)> rescue
...(79)>   _ -> what_happened = :rescued
...(79)> end

iex(80)> what_happened
error: undefined variable "what_happened"
└─ iex:80
** (CompileError) cannot compile code (errors have been logged)

# 在外部使用变量接收 what_happened
iex(80)> what_happened =
...(80)>   try do
...(80)>     raise "fail"
...(80)>     :did_not_raise
...(80)>   rescue
...(80)>     _ -> :rescued
...(80)>   end
:rescued
iex(81)> what_happened
:rescued

# do代码块中定义的another_what_happened无法在`rescue/after/else`中访问
iex(82)> try do
...(82)>   raise "fail"
...(82)>   another_what_happened = :did_not_raise
...(82)> rescue
...(82)>   _ -> another_what_happened
...(82)> end
error: undefined variable "another_what_happened"
└─ iex:86

** (CompileError) cannot compile code (errors have been logged)
```


