# [Enumerables and Streams](https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/pages/getting-started/enumerable-and-streams.md)

`Elixir`允许我们写递归代码，大部分我们用于操作集合的方法都在`Enum`和`Stream`模块中。

## Enumerables

`Elixir`提供了可枚举对象的概念和`Enum`模块，包含了变形，排序，分组，过滤，查询可枚举对象的元素的诸多方法,他可以用于实现了`Enumerable`协议的任何数据类型。
`Elixir`中还提供`Range`，他也是可枚举对象。

```elixir
# map
iex(1)> Enum.map(1..3, fn x -> x * 2 end)
[2, 4, 6]
# reduce
iex(2)> Enum.reduce(1..3, 0, &+/2)
6
```

## Eager vs Lazy

`Enum`模块中的所有函数都是`eager`的,许多函数都是期待可枚举对象参数，返回一个列表。

```elixir
odd?= &(rem(&1, 2) != 0) 
Enum.filter(1..3,odd?)

iex(4)> Enum.filter(1..3,odd?)
[1, 3]
```

这意味着，当进行多个操作时，都会生成一个中间列表，直到拿到结果。

```elixir
# `|>` 是`elixir`的管道操作符，每个操作前都生成一个中间列表，直到最后Enum.sum()返回.
iex(5)> 1..100_000 |> Enum.map(&(&1 * 3)) |> Enum.filter(odd?) |> Enum.sum()
7500000000
```

## 管道操作符

`|>` 管道操作符 将左侧的输出 传递给 右侧函数当成第一个参数，这种写法使得代码更加简洁。

```elixir
# 上面例子不用 管道操作符的版本
iex(9)> Enum.sum(Enum.filter(Enum.map(1..100_000, &(&1 * 3)), odd?))
7500000000 
```

## Steams

`Elixir`提供了`Stream`作为 `Enum`的替代品，支持惰性操作。
流也是一种`Enumerable`  

```elixir
iex(3)> odd? = &(rem(&1,2)!=0)
#Function<42.39164016/1 in :erl_eval.expr/6>
iex(4)> 1..100_000 |> Stream.map(&(&1 * 3)) |> Stream.filter(odd?) |> Enum.sum()
7500000000

# 返回一个Stream
iex(5)> 1..100_000 |> Stream.map(&(&1 * 3))
#Stream<[enum: 1..100000, funs: [#Function<50.38948127/1 in Stream.map/2>]]>

# 流是可合并的，可以使用多个管道符操作流
iex(6)> 1..100_000 |> Stream.map(&(&1 * 3)) |> Stream.filter(odd?)
#Stream<[
  enum: 1..100000,
  funs: [#Function<50.38948127/1 in Stream.map/2>,
   #Function<40.38948127/1 in Stream.filter/2>]

```

流不生成中间列表，而是构建一系列计算，只有当我们将底层流传递给`Enum`时才会调用,
在用于比较庞大或者近无限的列表时非常有用。


```elixir
# `Stream`模块的很多函数接受任意类型的可枚举类型作为参数，返回一个流作为结果，
# 同时也提供了创建流的方法，`Stream.cycle/1`可以创建一个无限循环的额枚举类型流。
# 不要用`Enum.map/2`调用这样的流，会无限循环。
iex(1)> stream = Stream.cycle([1, 2, 3])
#Function<65.38948127/2 in Stream.unfold/2>
iex(2)> Enum.take(stream, 10)
[1, 2, 3, 1, 2, 3, 1, 2, 3, 1]

# `Stream.unfold/2`用于从一个给定初始值生成一串值
iex(1)> stream = Stream.unfold("hełło", &String.next_codepoint/1)
#Function<65.38948127/2 in Stream.unfold/2>
iex(3)> Enum.take(stream, 3)
["h", "e", "ł"]

# `Stream.resource/3` 用于包裹资源，保证他们在枚举前打开，在枚举后关闭，即便发生错。
# `File.stream!/1`基于`Stream.resource/3`构建。
iex(5)> stream = File.stream!("path/to/file")
%File.Stream{
  path: "path/to/file",
  modes: [:raw, :read_ahead, :binary],
  line_or_bytes: :line,
  raw: true,
  node: :nonode@nohost
}
# 获取 文件的前10行
iex(6)> Enum.take(stream, 10)
```

