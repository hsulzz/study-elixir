# 编写文档

`Elixir`把文档当成一等公民，文档必须易写易读。

## Mardown

`Elixir`使用markdown 编写文档。可以参考 [GitHub的文档](https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax)

## 模块属性

- `@moduledoc`属性用于添加模块文档
- `@doc`属性写在函数前，用于添加函数文档
- `@typedoc` 用于添加类型文档

Elixir还支持向文档添加metadata，通过传送一个关键字列表给`@doc`等

```elixir
defmodule MyApp.Hello do

  @moduledoc """
  这是一个模块
  """
  @moduledoc since: "1.0.0"

  @doc """
  Says hello to the given `name`.

  Returns `:ok`.

  ## Examples

      iex> MyApp.Hello.world(:john)
      :ok

  """
  @doc since: "1.3.0"
  def world(name) do
    IO.puts("hello #{name}")
  end
end

```

## 函数参数

当给函数写文档时，参数名由编译器推断

```elixir
# 比如这个函数的参数名会被推导为`map`
# 当一个函数包含多个字句用类型匹配的时候，这个参数名并不好。
def size(%{size: size}) do
    size
end

# 始终在函数前声明一个合适的参数名
def size(map_with_size)
def size(%{size: size}) do
  size
end
```

## 文档元数据

`Elixir`允许添加任意元数据到文档，通过传递关键字列表给相关的模块属性。
最常用的一个元数据是`:since`, 这个用于标注特定的模块，方法，类型，回调使用某个版本添加的。
`:deprecated`警示该用法已经不推荐。

```elixir
# 这个元数据，在调用函数时，不会提示警告
@doc deprecated: "Use Foo.bar/2 instead"

# 如果需要提示警告 需要 使用`@deprecated`这个模块属性
@deprecated "Use Foo.bar/2 instead"
```
元数据可以是任意key，文档工具使用元数据提供更多的数据丰富用户体验

## 建议

编写文档时

- 保持文档的第一段简洁明了，通常是一行。像[ExDoc](https://github.com/elixir-lang/ex_doc/)这样的工具使用第一行来生成摘要。

- 使用模块的全名。
    mardown使用(\`)包裹代码，`Elixir`也基于这个自动生成对应模块或方法的链接。

- 本地模块的函使用函数名和arity，比如`world/1`,如果是指向外部模块，需要写成`External.Hello.world/1`

- 引用`@callback`时，在前面加`c:`,比如 `c:world/1`

- 引用`@type`时，在前面加`t:`,比如`t:values/0`

- 以`##`二级header写新段落，一级header预留给了模块跟函数。

- 为多子句的函数写文档时，将文档放在第一个子句前，文档以函数和arity为单位而非子句。

- 添加新函数或模块时，使用`:since`标注元数据。

## Doctets

建议开发者编写文档时包含example，使用``## Examples`` 标题，确保例子没有过期，`ExUnit`提供一个特性叫做`doctest`，可以用来测试文档中的例子。

## 文档！= 代码注释

文档和代码注释时两个不同的概念，文档是您与API用户之间的明确合同，无论是第三方开发人员、同事还是您未来的自己。如果模块和函数是您的API的一部分，则必须始终记录在案。

注释主要目的在于帮助程序员阅读代码。

由于私有函数不能外部访问，给私有函数提供`@doc`属性时，`Elixir`会报警病丢弃内容，可以添加代码注释。

总之，文档是与您的API用户的合约，他们不一定需要访问源代码，而代码注释适用于那些直接与源代码交互的人。您可以通过将这两个概念分开来学习和表达关于软件的不同保证。

## 隐藏内部模块和函数

除了作为公共接口一部分提供的模块和功能库外，库还可以实现不属于其API的重要功能。虽然这些模块和功能可以访问，但它们应该是库内部的，因此不应该为最终用户提供文档。

`Elixir`可以通过`@doc false` ，`@moduledoc false` 来隐藏函数和这个那个模块， 被隐藏的函数和模块你依旧可以给他编写文档，但是他不会显示在文档中。

```elixir

# 隐藏整个模块文档
defmodule MyApp.Hidden do
    @moduledoc false

    @doc """
    This function won't be listed in  docs.
    """
    def function_that_wont_be_listed_in_docs do
        # ...
    end
end

# 隐藏特定函数文档
defmodule MyApp.Sample do
    @doc false
    def add(a, b), do: a + b
end
```

`@moduledoc false`和`@doc false`不会让函数变成私有，因此依旧可以调用函数，所以使用`@doc false`需要小心，可以使用以下2个替代方案

- 将未编写文档的函数移动一个使用`@moduledoc false`的模块中去，保证这个函数不会被意外暴露或引入。

- 函数名以`_`或者`__`开头，比如`__add__/2`,以下划线开头的函数默认是被隐藏的，当然也可以明确添加`@doc false`来隐藏。编译器不会夹在以下划线开头的方法，下划线用于提示函数的私有用途。

### `Code.fetch_docs/1`

`Elixir`将文档以特定的块的形式存储在编译生成的字节码中，模块加载后也不会将文档读入到内存，需要使用`Code.fetch_docs/1`从硬盘中读取
但局限的是，内存中定义的模块，如IEx中定义的模块，无法访问其文档，因为它们不会将字节码写入磁盘。