# [IO及文件系统](https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/pages/getting-started/io-and-the-file-system.md#L1)

## `IO`模块

`IO`模块是`Elixir`中读取和写入标准输入/输出（`:stdio`）、标准错误（`:stderr`）、文件和其他IO设备的主要机制。

```elixir
iex(1)> IO.puts("hello world")
hello world
:ok
iex(2)> IO.gets("yes or no? ")
yes or no? n
"n\n"
```

`IO`模块默认从标准输入读取，写入到默认输出。可以传递给`:stderr`来改变。

```elixir
iex(3)> IO.puts(:stderr, "hello world")
hello world
:ok
```

## `File`模块

`File`模块提供以`IO`设备的形式打开文件的方法。默认情况下，文件以二进制模式打开，这要求开发人员使用`IO`模块中的特定`IO.binread/2`和`IO.binwrite/2`函数。

```elixir
iex(8)> {:ok,file}=File.open("../test.md",[:write])
{:ok, #PID<0.107.0>}
iex(9)> IO.binwrite(file, "world")
:ok
iex(10)> File.close(file)
:ok
iex(11)> File.read("../test.md")
{:ok, "world"}
```

也可以用`:append`选项打开文件，这样可以保存文件内容。
还可以传递`:utf8`选项，`File`模块解析从文件中读取的字节时解释成utf-8-encoded-bytes

除了打开、读取和写入文件的功能外，文件模块还具有许多与文件系统配合使用的功能。这些函数是以其UNIX等效函数命名的。例如，`File.rm/1`可用于删除文件，`File.mkdir/1`可用于创建目录，`File.mkdir_p/1`可用于创建目录及其所有父链。甚至还有`File.cp_r/2`和`File.rm_rf/1`可以分别递归复制和删除文件和目录（即复制和删除目录的内容）。

```elixir
# File模块中的方法提供了两个变种，一个`regular`版本，一个`!`版本
# 比如`read!/1`返回文件内容，而不是饭回元组，如果报错则抛异常
# 如果要用模式匹配处理不同结果，建议使用不带`!`的版本
iex(2)> File.read("path/to/file/hello")
{:error, :enoent}
iex(3)> File.read!("path/to/file/hello")
** (File.Error) could not read file "path/to/file/hello": no such file or directory
    (elixir 1.17.2) lib/file.ex:385: File.read!/1
    iex:3: (file)

# 如果要用模式匹配处理不同结果，建议使用不带`!`的版本
case File.read("path") do
    {:ok, body} -> # do something with the `body`
    {:error, reason} -> # handle the error caused by
end

# 如果期望文件已存在，则建议使用`!`版本，可以得到有用的错误信息。

```

# `Path`模块

`File`模块中的大部分函数需要一个path参数。
使用`Path`模块中的函数取代直接操作字符串，因为Path模块默默处理不同系统的路径

```elixir
iex(4)> Path.join("foo","bar")
"foo/bar"
iex(5)> Path.expand("~/hello")
"/Users/hsulzz/hello"
```

## 进程

`IO`模块工作于进程，读取到的文件是一个进程，当写入信息到已经关闭的文件中时，
则会报错，因为进程已经关闭。

```elixir
iex(10)> {:ok, file} = File.open("../helloworld/mix.exs")
{:ok, #PID<0.113.0>}
iex(11)> File.close(file)
:ok
iex(12)> IO.write(file, "test")
** (ErlangError) Erlang error: :terminated:

  * 1st argument: the device has terminated

    (stdlib 6.0.1) io.erl:198: :io.put_chars(#PID<0.113.0>, "test")
    iex:12: (file)
```

### `iodata`和`chardata`

`Elixir`中的IO函数，不仅可以接受`binaries`hairy接受`iodata`或者`chardata`。
使用`iodata`或者`chardata`的主要原因是提升性能。

```elixir
name = "Mary"

# `Elixir`中的字符串是不可变的，他会将“Mary”拷贝到新的字符串中。
# 如果字符串比较大，创建的成本就相对高昂。
IO.puts("Hello " <> name <> "!")

# 传递一个字符串的列表，不会发生拷贝。
# 这种list 被称作`iodata`或者`chardata`
IO.puts(["Hello ", name, "!"])
```

`iodata`或者`chardata`区别在于如何表示整数。
 `iodata` 整数相当于字节，而 `chardata`在`Unicode`中整数相当于码点。
 在`ASCII`字符中，字节跟码点一致。IO设备默认使用`chardata`

列表中的`Integer`可能代表一串字节，也可能代表一串字符，这取决于IO设备的编码。
打开文件为指定编码时，默认是Raw模式。必须使用IO模块中`bin*`开头的函数，这些方法都 期望以`iodata`做为参数，整数被表示为字节。

以默认IO设备`stdio`和以`:utf8`编码打开的文件，可以使用IO模块中的其他方法。这些方法都期望一个`chardata`作为参数，整数被表示为码点。

`charlist`是`chardata`的一个特殊情况，他所有的值都是整数，代表unicode的码点。可以使用`~c`魔符创建


