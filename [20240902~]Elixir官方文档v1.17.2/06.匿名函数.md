# [匿名函数](https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/pages/getting-started/anonymous-functions.md)


## 匿名函数语法

`Elixir`中使用`fn` 和 `end`定义匿名函数。

```elixir
# 匿名函数定义
iex(1)> add = fn a,b -> a+b end
#Function<41.39164016/2 in :erl_eval.expr/6>

# 匿名函数调用
iex(2)> add.(1,2)
3

# 匿名函数也一样通过接受参数数量识别
iex(3)> is_function(add,2)
true
```

## 闭包

匿名函数可以访问函数定义时的作用域的变量，这称作闭包。

```elixir
iex(5)> double = fn a -> add.(a, a) end
#Function<42.39164016/1 in :erl_eval.expr/6>
iex(6)> double.(2)
4

# 在函数内部赋值的变量，不会影响外部变量。
iex(7)> x=42
42
iex(8)> (fn -> x=0 end).()
0
iex(9)> x
42

```

## 子句与守卫

与`case/2`相似，可以为参数进行模式匹配，定义多个子句和守卫。

```elixir
iex(10)> f = fn 
...(10)> x, y when x > 0 -> x+y
...(10)> x, y -> x*y
...(10)> end
#Function<41.39164016/2 in :erl_eval.expr/6>
iex(11)> f.(1,3)
4
iex(12)>  f.(-1,3)
-3

# 字句中的 参数个数必须相同，否则会报`CompileError`
iex(13)> f2 = fn
...(13)> x, y when x >0 -> x + y
...(13)> x, y, z -> x * y + z
...(13)> end
** (CompileError)  cannot mix clauses with different arities in anonymous functions
```

## 捕获运算符

使用`&`可以捕获已经存在的函数，与匿名函数类似

```elixir
# 使用`&`捕获已经存在的函数
iex(13)> fun = &is_atom/1
&:erlang.is_atom/1

iex(14)> is_function(fun)
true

# 调用方式与匿名函数一样
iex(15)> fun.(:hello)
true

# 可以捕捉module中的函数
iex(16)> fun = &String.length/1
&String.length/1
iex(17)> fun.("hello")
5

# 可以捕捉 操作符
iex(18)> add=&+/2
&:erlang.+/2
iex(19)> add.(1,2)
3

# 捕获操作符也可以用作创建函数的语法
# &1代表函数接受的第一个参数
iex(20)> fun = &(&1 + 1)
#Function<42.39164016/1 in :erl_eval.expr/6>
iex(21)> fun.(1)
2
iex(22)> fun2 = &"Good #{&1}"
#Function<42.39164016/1 in :erl_eval.expr/6>
iex(23)> fun2.("morning")
"Good morning"
```
