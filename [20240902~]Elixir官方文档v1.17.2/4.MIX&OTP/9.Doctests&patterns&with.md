# [Doctests, patterns and with](https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/pages/mix-and-otp/docs-tests-and-with.md#L1)

在本章中，我们将实现解析第一章中描述的命令的代码。

```markdwon
CREATE shopping
OK

PUT shopping milk 1
OK

PUT shopping eggs 3
OK

GET shopping milk
1
OK

DELETE shopping eggs
OK
```

解析完成后，我们将更新我们的服务器，将解析出的命令分发到我们之前构建的 `:kv` 应用程序中。

## Doctests

在语言主页上，我们提到`Elixir`将文档视为一等公民。我们在本指南中多次探讨了这一概念，无论是通过`mix help`，还是在`IEx`控制台中输入`h Enum`或其他模块。在本节中，我们将实现解析功能，为其编写文档，并确保我们的文档与`doctests`保持最新。这有助于我们提供带有准确代码示例的文档。让我们在`lib/kv_server/command.ex`中创建我们的命令解析器，并从`doctest`开始：

```elixir
defmodule KVServer.Command do
  @doc ~S"""
  Parses the given `line` into a command.

  ## Examples

      iex> KVServer.Command.parse("CREATE shopping\r\n")
      {:ok, {:create, "shopping"}}

  """
  def parse(_line) do
    :not_implemented
  end
end
```

文档字符串中的 doctests 通过四个空格的缩进后跟 `iex>` 提示符来指定。如果一个命令跨多行，则可以使用 `...>`，与 IEx 相同。预期结果应从 `iex>` 或 `...>` 行后面的下一行开始，并以换行符或新的 `iex>` 前缀终止。

另外，请注意，我们使用 `⁠@doc ~S"""" `开始文档字符串。` ⁠~S` 防`止 ⁠\r\n `字符在测试中评估之前被转换为回车和换行。

为了运行我们的文档测试，我们将在 `⁠test/kv_server/command_test.exs` 创建一个文件，并在测试用例中调用 `⁠doctest KVServer.Command`。

```elixir
defmodule KVServer.CommandTest do
  use ExUnit.Case, async: true
  doctest KVServer.Command
end
```

运行测试套件，`doctest`应该会失败：

```elixir
  1) doctest KVServer.Command.parse/1 (1) (KVServer.CommandTest)
     test/kv_server/command_test.exs:3
     Doctest failed
     doctest:
       iex> KVServer.Command.parse("CREATE shopping\r\n")
       {:ok, {:create, "shopping"}}
     code: KVServer.Command.parse "CREATE shopping\r\n" === {:ok, {:create, "shopping"}}
     left:  :not_implemented
     right: {:ok, {:create, "shopping"}}
     stacktrace:
       lib/kv_server/command.ex:7: KVServer.Command (module)
```

现在让我们使 `doctest` 通过。我们来实现` parse/1` 函数：

```elixir
def parse(line) do
  case String.split(line) do
    ["CREATE", bucket] -> {:ok, {:create, bucket}}
  end
end
```

我们的实现将行拆分为以空白字符为分隔，然后将命令与列表进行匹配。使用 `String.split/1 `意味着我们的命令不区分空白字符。前导和尾随空白不重要，单词之间的连续空格也不会影响。让我们添加一些新的文档测试，以测试这种行为以及其他命令：

```elixir
@doc ~S"""
Parses the given `line` into a command.

## Examples

    iex> KVServer.Command.parse "CREATE shopping\r\n"
    {:ok, {:create, "shopping"}}

    iex> KVServer.Command.parse "CREATE  shopping  \r\n"
    {:ok, {:create, "shopping"}}

    iex> KVServer.Command.parse "PUT shopping milk 1\r\n"
    {:ok, {:put, "shopping", "milk", "1"}}

    iex> KVServer.Command.parse "GET shopping milk\r\n"
    {:ok, {:get, "shopping", "milk"}}

    iex> KVServer.Command.parse "DELETE shopping eggs\r\n"
    {:ok, {:delete, "shopping", "eggs"}}

Unknown commands or commands with the wrong number of
arguments return an error:

    iex> KVServer.Command.parse "UNKNOWN shopping eggs\r\n"
    {:error, :unknown_command}

    iex> KVServer.Command.parse "GET shopping\r\n"
    {:error, :unknown_command}

"""
```

手头有文档测试后，就轮到你使测试通过了！一旦你准备好了，可以将你的工作与我们下面的解决方案进行比较：

```elixir
def parse(line) do
  case String.split(line) do
    ["CREATE", bucket] -> {:ok, {:create, bucket}}
    ["GET", bucket, key] -> {:ok, {:get, bucket, key}}
    ["PUT", bucket, key, value] -> {:ok, {:put, bucket, key, value}}
    ["DELETE", bucket, key] -> {:ok, {:delete, bucket, key}}
    _ -> {:error, :unknown_command}
  end
end
```

注意到我们能够优雅地解析命令，而不需要添加大量检查命令名称和参数数量的`if/else`分支了吗！

最终，您可能已经观察到每个doctest对应我们套件中的不同测试，目前总共报告了7个`doctest`。这是因为ExUnit将以下内容视为定义两个不同的`doctest`：

```elixir
KVServer.Command.parse("UNKNOWN shopping eggs\r\n")
{:error, :unknown_command}

KVServer.Command.parse("GET shopping\r\n")
{:error, :unknown_command}
```

没有换行，如下所示，`ExUnit` 会将其编译成一个单一的 `doctest`。

```elixir
KVServer.Command.parse("UNKNOWN shopping eggs\r\n")
{:error, :unknown_command}
KVServer.Command.parse("GET shopping\r\n")
{:error, :unknown_command}
```

顾名思义，`doctest`首先关注文档，然后是测试。它的目标不是替代测试，而是提供最新的文档。您可以在`ExUnit.DocTest`文档中阅读更多关于`doctest`的信息。

##  `with`

我们现在能够解析命令，因此我们终于可以开始实现执行命令的逻辑了。暂时让我们为这个函数添加一个简化的定义：

```elixir
defmodule KVServer.Command do
  @doc """
  Runs the given command.
  """
  def run(command) do
    {:ok, "OK\r\n"}
  end
end
```

在我们实现这个功能之前，让我们先修改我们的服务器，以开始使用新的 `parse/1 `和 `run/1` 函数。请记住，当客户端关闭套接字时，我们的 `read_line/1` 函数也会崩溃，因此我们也借此机会修复它。打开 `lib/kv_server.ex` 并替换现有的服务器定义：

```elixir
defp serve(socket) do
  msg =
    case read_line(socket) do
      {:ok, data} ->
        case KVServer.Command.parse(data) do
          {:ok, command} ->
            KVServer.Command.run(command)
          {:error, _} = err ->
            err
        end
      {:error, _} = err ->
        err
    end

  write_line(socket, msg)
  serve(socket)
end

defp read_line(socket) do
  :gen_tcp.recv(socket, 0)
end

defp write_line(socket, {:ok, text}) do
  :gen_tcp.send(socket, text)
end

defp write_line(socket, {:error, :unknown_command}) do
  # Known error; write to the client
  :gen_tcp.send(socket, "UNKNOWN COMMAND\r\n")
end

defp write_line(_socket, {:error, :closed}) do
  # The connection was closed, exit politely
  exit(:shutdown)
end

defp write_line(socket, {:error, error}) do
  # Unknown error; write to the client and exit
  :gen_tcp.send(socket, "ERROR\r\n")
  exit(error)
end
```

如果我们启动服务器，现在可以向它发送命令。现在，我们将收到两种不同的响应：当命令被识别时返回“OK”，否则返回“UNKNOWN COMMAND”。

```shell
telnet 127.0.0.1 4040
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
CREATE shopping
OK
HELLO
UNKNOWN COMMAND
```

这意味着我们的实现正在朝着正确的方向前进，但看起来并不太优雅，是吗？

之前的实现使用了管道，使逻辑很容易理解。然而，现在我们需要在过程中处理不同的错误代码，因此我们的服务器逻辑嵌套在许多 `case` 调用中。

幸运的是，Elixir v1.2 引入了` ⁠with` 结构，这使得你可以简化上面的代码，将嵌套的 `case` 调用替换为一系列匹配的子句。让我们重写 `⁠serve/1` 函数以使用 `⁠with`。

```elixir
defp serve(socket) do
  msg =
    with {:ok, data} <- read_line(socket),
         {:ok, command} <- KVServer.Command.parse(data),
         do: KVServer.Command.run(command)

  write_line(socket, msg)
  serve(socket)
end
```

太好了！`⁠with`语句将从`⁠<-`的右侧获取返回值，并将其与左侧的模式进行匹配。如果值与模式匹配，`⁠with`将继续下一个表达式。如果没有匹配，则返回不匹配的值

换句话说，我们将传递给`⁠case/2`的每个表达式转换为`⁠with`中的一个步骤。一旦任何步骤返回的值不匹配`⁠{:ok, x}`，`⁠with`将中止并返回不匹配的值。

您可以在我们的文档中阅读有关[⁠with/1](https://hexdocs.pm/elixir/Kernel.SpecialForms.html#with/1)的更多信息。

## Running commands

最后一步是实现⁠`KVServer.Command.run/1`，以便在`⁠:kv`应用程序中执行解析后的命令。它的实现如下所示：

```elixir
@doc """
Runs the given command.
"""
def run(command)

def run({:create, bucket}) do
  KV.Registry.create(KV.Registry, bucket)
  {:ok, "OK\r\n"}
end

def run({:get, bucket, key}) do
  lookup(bucket, fn pid ->
    value = KV.Bucket.get(pid, key)
    {:ok, "#{value}\r\nOK\r\n"}
  end)
end

def run({:put, bucket, key, value}) do
  lookup(bucket, fn pid ->
    KV.Bucket.put(pid, key, value)
    {:ok, "OK\r\n"}
  end)
end

def run({:delete, bucket, key}) do
  lookup(bucket, fn pid ->
    KV.Bucket.delete(pid, key)
    {:ok, "OK\r\n"}
  end)
end

defp lookup(bucket, callback) do
  case KV.Registry.lookup(KV.Registry, bucket) do
    {:ok, pid} -> callback.(pid)
    :error -> {:error, :not_found}
  end
end
```

每个函数子句将相应的命令分派给我们在⁠`:kv`应用程序启动期间注册的`⁠KV.Registry`服务器。由于我们的⁠`:kv_server`依赖于`⁠:kv`应用程序，因此依赖于它提供的服务是完全可以的。

您可能注意到，我们有一个没有主体的函数头`⁠def run(command)`。在模块与函数一章中，我们了解到，body为空的函数可以用于为多子句函数声明默认参数。这是另一种使用无主体函数来文档化参数的用例。

请注意，我们还定义了一个名为`⁠lookup/2`的私有函数，以帮助实现查找桶的常见功能，如果存在则返回其`PID`；否则，返回`⁠{:error, :not_found}`

顺便提一下，由于我们现在返回⁠`{:error, :not_found}`，我们应该修改`⁠KVServer`中的`⁠write_line/2`函数，以便也能打印此类错误

```elixir
defp write_line(socket, {:error, :not_found}) do
  :gen_tcp.send(socket, "NOT FOUND\r\n")
end
```

我们的服务器功能几乎完成；只缺少测试。这次，我们将测试放在最后，因为有一些重要的考虑因素需要考虑。

` KVServer.Command.run/1` 的实现将命令直接发送到名为 `KV.Registry` 的服务器，该服务器由 `:kv` 应用程序注册。这意味着该服务器是全局的，如果我们有两个测试同时向它发送消息，我们的测试将相互冲突（并可能失败）。我们需要在编写独立且可以异步运行的单元测试，或编写在全局状态上运行但能测试我们应用程序完整堆栈的集成测试之间做出决定，而后者正是我们希望在生产中使用的方式。

到目前为止，我们只编写了单元测试，通常直接测试单个模块。然而，为了使 `KVServer.Command.run/1` 作为单元可测试，我们需要改变其实现，使其不直接将命令发送到` KV.Registry` 进程，而是将服务器作为参数传递。例如，我们需要将` run` 的签名更改为 `⁠def run(command, pid)`，然后相应地更改所有子句。

```elixir
def run({:create, bucket}, pid) do
  KV.Registry.create(pid, bucket)
  {:ok, "OK\r\n"}
end

# ... other run clauses ...
```

请您随意进行上述更改，并编写一些单元测试。这个想法是，您的测试将启动一个 `KV.Registry` 的实例，并将其作为参数传递给 `run/2`，而不是依赖于全局的 `KV.Registry`。这有一个好处，那就是保持我们的测试异步，因为没有共享状态。

但让我们也尝试一些不同的做法。我们来编写一些集成测试，这些测试依赖于全局服务器名称，以全面测试从 TCP 服务器到存储桶的整个栈。我们的集成测试将依赖于全局状态，并且必须是同步的。通过集成测试，我们可以覆盖应用程序中组件之间如何协同工作，代价是测试性能。这些测试通常用于测试应用程序中的主要流程。例如，我们应该避免使用集成测试来测试我们命令解析实现中的边缘情况。

我们的集成测试将使用一个 TCP 客户端，该客户端向我们的服务器发送命令，并断言我们得到了期望的响应。

让我们在 `test/kv_server_test.exs `中实现集成测试，如下所示：

```elixir
defmodule KVServerTest do
  use ExUnit.Case

  setup do
    Application.stop(:kv)
    :ok = Application.start(:kv)
  end

  setup do
    opts = [:binary, packet: :line, active: false]
    {:ok, socket} = :gen_tcp.connect('localhost', 4040, opts)
    %{socket: socket}
  end

  test "server interaction", %{socket: socket} do
    assert send_and_recv(socket, "UNKNOWN shopping\r\n") ==
           "UNKNOWN COMMAND\r\n"

    assert send_and_recv(socket, "GET shopping eggs\r\n") ==
           "NOT FOUND\r\n"

    assert send_and_recv(socket, "CREATE shopping\r\n") ==
           "OK\r\n"

    assert send_and_recv(socket, "PUT shopping eggs 3\r\n") ==
           "OK\r\n"

    # GET returns two lines
    assert send_and_recv(socket, "GET shopping eggs\r\n") == "3\r\n"
    assert send_and_recv(socket, "") == "OK\r\n"

    assert send_and_recv(socket, "DELETE shopping eggs\r\n") ==
           "OK\r\n"

    # GET returns two lines
    assert send_and_recv(socket, "GET shopping eggs\r\n") == "\r\n"
    assert send_and_recv(socket, "") == "OK\r\n"
  end

  defp send_and_recv(socket, command) do
    :ok = :gen_tcp.send(socket, command)
    {:ok, data} = :gen_tcp.recv(socket, 0, 1000)
    data
  end
end
```

我们的集成测试检查所有服务器交互，包括未知命令和未找到的错误。值得注意的是，与 ETS 表和关联进程一样，关闭套接字并不是必需的。一旦测试进程结束，套接字会自动关闭。

这次，由于我们的测试依赖于全局数据，我们没有给 `ExUnit.Case` 设置 `async: true`。此外，为了确保我们的测试始终处于干净的状态，我们在每个测试之前停止并启动 `:kv `应用程序。事实上，停止` :kv` 应用程序时甚至会在终端上打印警告：

```shell
18:12:10.698 [info] Application kv exited: :stopped
```

为了在测试期间避免打印日志消息，ExUnit 提供了一个很棒的功能，称为 `:capture_log`。通过在每个测试之前设置 `@tag :capture_log` 或在整个测试模块中使用 `@moduletag :capture_log`，ExUnit 将自动捕获测试运行期间记录的任何内容。如果我们的测试失败，捕获的日志将与 ExUnit 报告一起打印。

在使用 `ExUnit.Case` 和 `setup` 之间，添加以下调用：

```elixir
@moduletag :capture_log
```

如果测试崩溃，您将看到如下报告：

```elixir
  1) test server interaction (KVServerTest)
     test/kv_server_test.exs:17
     ** (RuntimeError) oops
     stacktrace:
       test/kv_server_test.exs:29

     The following output was logged:

     13:44:10.035 [notice] Application kv exited: :stopped
```

通过这个简单的集成测试，我们开始理解为什么集成测试可能会很慢。这个测试不仅无法异步运行，还需要高开销的设置来停止和启动 :kv 应用程序。


在一天的结束时，决定最佳测试策略的责任在于你和你的团队。你需要在代码质量、信心和测试套件的运行时间之间取得平衡。例如，我们可能会开始仅使用集成测试对服务器进行测试，但如果服务器在未来的版本中持续增长，或者它成为一个频繁出现bug的应用程序的一部分，那么考虑将其拆分并编写更强大的单元测试就显得尤为重要，因为这些单元测试不负责集成测试的负担。让我们进入下一章。我们将通过添加一个桶路由机制最终使我们的系统实现分布式。我们也将借此机会提升我们的测试能力。