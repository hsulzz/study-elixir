# [Speeding up with ETS](https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/pages/mix-and-otp/erlang-term-storage.md#L1)

每次我们需要查找存储桶时，我们都需要向注册表发送消息。如果多个进程同时访问我们的注册表，注册表可能会成为一个瓶颈！

在本章中，我们将了解ETS（Erlang Term Storage）以及如何将其用作缓存机制。

>警告！不要过早地使用ETS作为缓存！记录和分析您的应用程序性能，并确定哪些部分是瓶颈，这样您就知道是否应该缓存，以及应该缓存什么。一旦确定了需求，本章只是如何使用ETS的一个例子。

## ETS作为缓存

ETS允许我们将任何Elixir术语存储在内存表中。使用ETS表是通过Erlang的:ets模块完成的

```elixir
iex(1)> table = :ets.new(:buckets_registry, [:set, :protected])
#Reference<0.1541849146.978452482.99113>
iex(2)> :ets.insert(table, {"foo", self()})
true
iex(3)> :ets.lookup(table, "foo")
[{"foo", #PID<0.126.0>}]
```

创建ETS表时，需要两个参数：表名和一组选项。从可用选项中，我们传递了表类型及其访问规则。我们选择了`:set`类型，这意味着键不可重复。我们还将表的访问设置为`:protected`，这意味着只有创建表的进程可以写入它，但所有进程都可以从中读取。可能的访问控制：

- `:public`: 所有进程都可以读/写。
- `:protected`: 所有进程都可以阅读。只能由所有者流程写。这是默认值。
- `:private`: 读取/写入仅限于所有者进程。

请注意，如果您的读/写调用违反了访问控制，该操作将引发`ArgumentError`。最后，由于`:set`和`:protected`是默认值，从现在开始我们将跳过它们。

ETS表也可以命名，允许我们通过给定的名称访问它们：

```elixir
iex(4)> :ets.new(:buckets_registry, [:named_table])
:buckets_registry
iex(5)> :ets.insert(:buckets_registry, {"foo", self()})
true
iex(6)> :ets.lookup(:buckets_registry, "foo")
[{"foo", #PID<0.126.0>}]
```

让我们将`KV.Registry`更改为使用ETS表。第一个变化是修改我们的注册表，以需要一个名称参数，我们将使用它来命名ETS表和注册表进程本身。ETS名称和进程名称存储在不同的位置，因此不会发生冲突。

打开`lib/registry.ex`，让我们改变它的实现。我们在源代码中添加了注释，以突出显示我们所做的更改：

```elixir
defmodule KV.Registry do
  use GenServer

  ## Client API

  @doc """
  Starts the registry with the given options.

  `:name` is always required.
  """
  def start_link(opts) do
    # 1. Pass the name to GenServer's init
    server = Keyword.fetch!(opts, :name)
    GenServer.start_link(__MODULE__, server, opts)
  end

  @doc """
  Looks up the bucket pid for `name` stored in `server`.

  Returns `{:ok, pid}` if the bucket exists, `:error` otherwise.
  """
  def lookup(server, name) do
    # 2. Lookup is now done directly in ETS, without accessing the server
    case :ets.lookup(server, name) do
      [{^name, pid}] -> {:ok, pid}
      [] -> :error
    end
  end

  @doc """
  Ensures there is a bucket associated with the given `name` in `server`.
  """
  def create(server, name) do
    GenServer.cast(server, {:create, name})
  end

  ## Server callbacks

  @impl true
  def init(table) do
    # 3. We have replaced the names map by the ETS table
    names = :ets.new(table, [:named_table, read_concurrency: true])
    refs  = %{}
    {:ok, {names, refs}}
  end

  # 4. The previous handle_call callback for lookup was removed

  @impl true
  def handle_cast({:create, name}, {names, refs}) do
    # 5. Read and write to the ETS table instead of the map
    case lookup(names, name) do
      {:ok, _pid} ->
        {:noreply, {names, refs}}

      :error ->
        {:ok, pid} = DynamicSupervisor.start_child(KV.BucketSupervisor, KV.Bucket)
        ref = Process.monitor(pid)
        refs = Map.put(refs, ref, name)
        :ets.insert(names, {name, pid})
        {:noreply, {names, refs}}
    end
  end

  @impl true
  def handle_info({:DOWN, ref, :process, _pid, _reason}, {names, refs}) do
    # 6. Delete from the ETS table instead of the map
    {name, refs} = Map.pop(refs, ref)
    :ets.delete(names, name)
    {:noreply, {names, refs}}
  end

  @impl true
  def handle_info(_msg, state) do
    {:noreply, state}
  end
end
```

请注意，在我们更改之前，`KV.Registry.lookup/2`向服务器发送了请求，但现在它直接从ETS表读取，该表在所有进程中共享。这就是我们正在实施的缓存机制背后的主要思想

为了使缓存机制工作，创建的ETS表需要具有访问`:protected`（默认），因此所有客户端都可以从中读取，而只有`KV.Registry`进程写入它。我们还设置了`read_concurrency:true`，为并发读取操作的常见场景优化表。

我们在上面执行的更改破坏了我们的测试，因为注册表在启动时需要`:name`。此外，一些注册表操作，如`lookup/2`，要求将名称作为参数，而不是PID，因此我们可以进行ETS表查找。让我们更改`test/kv/registry_test.exs`中的设置功能，以解决这两个问题：

```elixir
  setup context do
    _ = start_supervised!({KV.Registry, name: context.test})
    %{registry: context.test}
  end
```

由于每个测试都有一个唯一的名称，我们使用测试名称来命名我们的注册表。这样，我们不再需要传递注册表PID，而是通过测试名称来识别它。

另请注意，我们将`start_supervised！`结果赋值给了下划线`（_）`。这个通常用来表示我们对`start_supervised!`的结果不感兴趣。

一旦我们更改`setup`，一些测试将继续失败。您甚至可能会注意到，测试在运行之间通过和失败不一致。例如，“spawns bucket”测试：

```elixir
test "spawns buckets", %{registry: registry} do
  assert KV.Registry.lookup(registry, "shopping") == :error

  KV.Registry.create(registry, "shopping")
  assert {:ok, bucket} = KV.Registry.lookup(registry, "shopping")

  KV.Bucket.put(bucket, "milk", 1)
  assert KV.Bucket.get(bucket, "milk") == 1
end
```

可能这行失败了：

```elixir
{:ok, bucket} = KV.Registry.lookup(registry, "shopping")
```

如果我们刚刚在上一行中创建了桶，这行怎么会失败？

发生这些失败的原因是，出于教学目的，我们犯了两个错误：

- 我们正在过早地优化（通过添加此缓存层）
- 我们正在使用`cast/2`（而我们应该使用`call/2`）

## Race condition?

在Elixir中开发并不能使您的代码没有race condition。然而，Elixir的抽象默认不共享任何东西，使其更容易发现race conditio的根本原因。

在我们的测试中，在操作和我们可以在ETS表中观察到这种变化的时间之间存在延迟。以下是我们预期发生的事情：

1. 我们调用`KV.Registry.create(registry, "shopping")`
2. 注册表创建存储桶并更新缓存表
3. 我们通过`KV.Registry.create(registry, "shopping")`从表中访问信息
4. 上面的命令返回`{:ok, bucket}`

然而，由于`KV.Registry.create/2`是一个cast操作，该命令将在我们实际写入表之前返回！换句话说，这种情况正在发生：

1. 我们调用`KV.Registry.create(registry, "shopping")`
2. 我们通过`KV.Registry.create(registry, "shopping")`从表中访问信息
3. 上面的命令返回`:error`
4. 注册表创建存储桶并更新缓存表

为了修复故障，我们需要使用`call/2`而不是`cast/2`使`KV.Registry.create/2`同步。这将保证客户端只有在对表进行更改后才会继续。让我们回到`lib/kv/registry.ex`，并更改函数及其回调如下：

```elixir
def create(server, name) do
  GenServer.call(server, {:create, name})
end
```

```elixir
@impl true
def handle_call({:create, name}, _from, {names, refs}) do
  case lookup(names, name) do
    {:ok, pid} ->
      {:reply, pid, {names, refs}}

    :error ->
      {:ok, pid} = DynamicSupervisor.start_child(KV.BucketSupervisor, KV.Bucket)
      ref = Process.monitor(pid)
      refs = Map.put(refs, ref, name)
      :ets.insert(names, {name, pid})
      {:reply, pid, {names, refs}}
  end
end
```

我们将回调从`handle_cast/2`更改为`handle_call/3`，并将其更改为使用创建桶的PID进行回复。一般来说，Elixir开发人员更喜欢使用`call/2`而不是`cast/2`，因为它还提供了背压——阻塞直到收到回复。在非必要时使用`cast/2`也可以被视为过早的优化。

让我们再进行一次测试。不过，这次我们将传递`--trace`选项：

```shell
mix test --trace
```

当您的测试陷入僵局或有竞赛条件时，`--trace`选项很有用，因为它同步运行所有测试（`async: true`），并显示有关每个测试的详细信息。如果您多次运行测试，您可能会看到这种间歇性故障：

```elixir
  1) test removes buckets on exit (KV.RegistryTest)
     test/kv/registry_test.exs:19
     Assertion with == failed
     code:  assert KV.Registry.lookup(registry, "shopping") == :error
     left:  {:ok, #PID<0.109.0>}
     right: :error
     stacktrace:
       test/kv/registry_test.exs:23
```

根据错误信息，我么期望桶已经不存在表中，但他还在。这个问题和我们刚刚解决的问题相反：虽然以前创建存储桶的命令和更新表之间存在延迟，但现在存储桶进程死亡及其条目从表中删除之间存在延迟，由于这是一个竞赛条件，您可能无法在机器上重现它，但它就在那里。

上次，我们通过将异步`cast`替换为同步`call`操作来修复了竞赛条件。不幸的是，我们用来接收`:DOWN`消息并从ETS表中删除条目的`handle_info/2`回调没有同步等价物。这一次，我们需要找到一种方法来保证注册表已处理存储桶进程终止时发送的`:DOWN`通知。

一个简单的方法是，在我们进行存储桶查找之前，向注册表发送同步请求,`Agent.stop/2`操作是同步的，只有在存储桶进程终止后才会返回。因此，一旦`Agent.stop/2`返回，注册表已收到`:DOWN`消息，但可能尚未处理。。为了保证`:DOWN`消息的处理，我们可以进行同步请求。由于消息是按顺序处理的，一旦注册表回复同步请求，那么`:DOWN`消息肯定会被处理.

在`test/kv/registry_test.exs`的两个“删除”测试中，在`Agent.stop/2`之后，通过创建一个“bogus”桶来做到这一点，这是一个同步请求：

```elixir
  test "removes buckets on exit", %{registry: registry} do
    KV.Registry.create(registry, "shopping")
    {:ok, bucket} = KV.Registry.lookup(registry, "shopping")
    Agent.stop(bucket)

    # Do a call to ensure the registry processed the DOWN message
    _ = KV.Registry.create(registry, "bogus")
    assert KV.Registry.lookup(registry, "shopping") == :error
  end

  test "removes bucket on crash", %{registry: registry} do
    KV.Registry.create(registry, "shopping")
    {:ok, bucket} = KV.Registry.lookup(registry, "shopping")

    # Stop the bucket with non-normal reason
    Agent.stop(bucket, :shutdown)

    # Do a call to ensure the registry processed the DOWN message
    _ = KV.Registry.create(registry, "bogus")
    assert KV.Registry.lookup(registry, "shopping") == :error
  end
```