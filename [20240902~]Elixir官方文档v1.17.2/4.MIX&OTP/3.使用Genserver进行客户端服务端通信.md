# 使用`GenServer`进行Client-server通信

在2.使用agents进行状态管理中，我们用agents实现了buckets，因为bucket是进程，每个bucket都有一个进程标志符（PID），之前我们介绍可以给进程注册一个atom的名字.

```elixir
iex(1)> Agent.start_link(fn -> %{} end, name: :shopping)
{:ok, #PID<0.105.0>}
iex(2)> Agent.update(:shopping, &Map.put(&1,"milk",3))
:ok
iex(3)> Agent.get(:shopping,&Map.get(&1,"milk"))
3
```

然而，用原子命名动态进程是一个糟糕的主意！如果我们使用原子，我们需要将存储桶名称（通常从外部客户端接收）转换为原子，我们**永远不应该将用户输入转换为原子**。这是因为原子不会被GC回收。原子一旦被创造，就永远不会被回收。从用户输入中生成原子意味着用户可以注入足够多的不同名称来耗尽我们的系统内存。

实际上，在内存耗尽之前，您更有可能达到Erlang VM的最大原子数量限制，无论如何，这都会使您的系统停机。

我们将创建自己的进程注册表，将存储桶名称与存储桶进程相关联，而不是滥用内置名称功能。注册表需要保证始终是最新的，例如，如果其中一个存储桶进程因错误而崩溃，注册表必须注意到此更改，并避免提供陈旧的条目，在Elixir中，注册表需要监控每个桶，由于我们的注册表需要能够接收和处理来自系统的临时消息，因此agent API是不够的。

我们将使用`GenServer`创建一个可以监控存储桶进程的注册表进程，`GenServer`为在`Elixir`和`OTP`中构建服务器提供工业强度功能。

## GenServer回调

`GenServer`是在特定条件下调用一组有限函数的进程。当我们使用`Agent`时，我们会将客户端代码和服务器代码并排保存，如下：

```elixir
def put(bucket, key, value) do
    # Here is the client code
    Agent.update(bucket, fn state -> 
      # Here is the server code
      Map.put(state, key, value)
    end
    )
    # Back to the client code
end
```

在上述代码中，我们有一个进程，我们称之为“客户端”，向代理“服务器”发送请求。请求包含一个匿名函数，该函数必须由服务器执行。

在`GenServer`中，上面的代码将是两个独立的函数，大致如下：

```elixir
def put(buckt, key, value) do
    # Send the server  a :put "instruction"
    GenServer.call(bucket, {:put, key, value})
end

# 服务端回调

def handle_call({:put, key, value}, _from, state) do
    {:reply, :ok, Map.put(state, key, value)}
end
```

GenServer代码中还有相当多的仪式，但正如我们将看到的，它也带来了一些好处。

目前，我们只会为我们的存储桶注册逻辑编写服务器回调，而不提供适当的API，我们稍后会这样做。

创建一个`lib/kv/registry.ex`文件，内容如下：

```elixir
defmodule KV.Registry do
  use GenServer

  ## Missing Client API  - will add this later

  ## Defining  GenServer Callbacks

  @impl true
  def init(:ok) do
    {:ok, %{}}
  end

  @impl true
  def handle_call({:lookup, name}, _from, names) do
    {:reply, Map.fetch(names, name), names}
  end

  @impl true
  def handle_cast({:create, name}, names) do
    if Map.has_key?(names, name) do
      {:noreply,names}
    else
      {:ok, bucket} =KV.Bucket.start_link([])
      {:noreply, Map.put(names,name, bucket)}
    end
  end
end
```

您可以向`GenServer`发送两种类型的请求：`call`和`cast`。`call`是同步的，服务器必须向此类请求返回响应。当服务器计算响应时，客户端等待。`cast`是异步的：服务器不会发送响应，因此客户端不会等待响应。这两个请求都是发送到服务器的消息，将按顺序处理。在上述实现中，我们在`:create`消息上进行模式匹配，将作为`cast`处理，在`:lookup`消息上，将作为`call`处理。

为了调用上述回调，我们需要通过相应的`GenServer`函数。让我们启动一个注册表，创建一个有名称的桶，然后查找它：

```elixir
iex(1)> {:ok, registry} = GenServer.start_link(KV.Registry, :ok)
{:ok, #PID<0.149.0>}
iex(2)> GenServer.cast(registry, {:create, "shopping"})
:ok
iex(3)> {:ok, bk} = GenServer.call(registry, {:lookup, "shopping"})
{:ok, #PID<0.150.0>}
```

我们的`KV.Registry`进程按照这个顺序收到了带有`{:create, "shopping"}`的`cast`和带有`{:lookup, "shopping"}`的调用。一旦消息发送到注册表，`GenServer.cast`将立即返回。另一方面，`GenServer.call`是我们等待响应的地方，由上述`KV.Registry.handle_cal`l回调提供。您可能还注意到，我们在每个回调前都添加了`@impl true`。他告诉编译器，随后定义的函数是一个回调的实现，。如果我们碰巧在函数名称或参数数量上犯了错误，比如我们定义了`handle_call/2`，编译器会警告我们没有任何`handle_call/2`需要定义，并将向我们提供`GenServer`模块已知回调的完整列表。

这一切都很好，但我们仍然想为我们的用户提供一个API，允许我们隐藏我们的实现细节。

## 客户端API

`GenServer`分为两部分：客户端API和服务器回调。您可以将两个部分合并到一个模块中，也可以将它们分成客户端模块和服务器模块。客户端是调用客户端函数的任何进程。服务器始终是我们将显式作为参数传递给客户端API的进程标识符或进程名称。在这里，我们将为服务器回调和客户端API使用单个模块。

在`lib/kv/registry.ex`上编辑文件，为客户端API填空：

```elixir

  ## Client API

  @doc """
  Starts the registry
  """
  def start_link(opts) do
    GenServer.start_link(__MODULE__, :ok, opts)
  end

  @doc """
  Looks up the bucket pid for `name` stored in `server`.

  Returns `{:ok, pid}` id the bucket exists,  `:error` otherwise.
  """
  def lookup(server, name) do
    GenServer.call(server, {:lookup, name})
  end

  @doc """
  Ensures there is a bucket associated with the given `name` in `server`.
  """
  def create(server, name) do
    GenServer.cast(server, {:create, name})
  end

```

第一个函数是`start_link/1`，它启动一个新的`GenServer`，传递一个选项列表。`start_link/1`调用`GenServer.start_link/3`，它需要三个参数：

   1. 实现了服务器回调的模块，在这种情况下`__MODULE__`（指当前模块）
   2. 初始化参数，在这种情况下是原子`:ok`
   3. 可用于指定服务器名称等内容的选项列表。目前，我们将在`start_link/1`上收到的选项列表转发到`GenServer.start_link/3`

接下来的两个函数，`lookup/2`和`create/2`，负责将这些请求发送到服务器,在这种情况下，我们分别使用了`{:lookup, name}`和`{:create, name}`。请求通常被指定为元组，像这样，以便在第一个参数插槽中提供多个“参数”,通常将请求的操作指定为元组的第一个元素，并在其余元素中指定该操作的参数。请注意，请求必须与`handle_call/3`或`handle_cast/2`的第一个参数相匹配。

这就是客户端API的。在服务器端，我们可以实现各种回调，以保证服务器初始化、终止和处理请求。这些回调是可选的，目前，我们只实施了我们关心的回调。让我们总结一下。

第一个是`init/1`回调，它接收给`GenServer.start_link/3`的第二个参数，并返回`{:ok, state}`，其中`state`是一个map。。我们已经可以注意到`GenServer` API如何使客户端/服务器分离更加明显。`start_link/3`发生在客户端中，而`init/1`是在服务器上运行的相应回调。

对于`call/2`请求，我们实现了一个`handle_call/3`回调，该回调接收请求、我们接收请求的进程`（_from）`和当前服务器状态`（names）`。`handle_call/3`回调返回一个格式为`{:reply, reply, new_state}`的元组。元组的第一个元素`:reply`表示服务器应该向客户端发送回复。第二个元素，`reply`，是将发送给客户端的内容，而第三个，`new_state`是新的服务器状态。

对于`cast/2`请求，我们实现了接收请求和当前服务器状态（`names`）的`handle_cast/2`回调。`handle_cast/2`回调返回格式为`{:noreply, new_state}`的元组。请注意，在真实应用程序中，我们可能会使用同步调用而不是异步抛出来实现：创建回调。我们这样做是为了说明如何实现`cast`回调。

还有其他元组格式，`handle_call/3`和`handle_cast/2`回调都可以返回。我们可以实现其他回调，`terminate/2`和`code_change/3`。欢迎您探索完整的`GenServer`文档，以了解有关这些文档的更多信息。

## 测试GenServer

测试`GenServer`与测试Agent没有太大区别。我们将在`setup`回调上生成服务器，并在整个测试过程中使用它。在`test/registry_test.exs`中创建一个包含以下内容的文件：

```elixir

```