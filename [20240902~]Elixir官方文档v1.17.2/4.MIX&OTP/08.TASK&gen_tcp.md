# [TASK and gen_tcp](https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/pages/mix-and-otp/task-and-gen-tcp.md#L1)

在本章中，我们将学习如何使用`Erlang`的`:gen_tcp`模块来服务请求。这为探索`Elixir`的`Task`模块提供了一个很好的机会。在未来的章节中，我们将扩展我们的服务器，以便它能够真正为命令提供服务。


## Echo server

我们将首先通过实现一个回声服务器来启动我们的TCP服务器,它将发送带有请求中收到的文本的回复,我们将慢慢改进我们的服务器，直到它受到监督并准备好处理多个连接。

一个TCP服务器大致执行以下步骤：

1. 监听一个端口，直到该端口可用并获取到套接字；
2. 在该端口等待客户端连接并接受连接；
3. 读取客户端请求并写回响应。

让我们实现这些步骤。前往 `apps/kv_server` 应用程序，打开 l`ib/kv_server.ex`，并添加以下功能:

```elixir
defmodule KVServer do
  require Logger

  def accept(port) do
    # The options below mean:
    #
    # 1. `:binary` - receives data as binaries (instead of lists)
    # 2. `packet: :line` - receives data line by line
    # 3. `active: false` - blocks on `:gen_tcp.recv/2` until data is available
    # 4. `reuseaddr: true` - allows us to reuse the address if the listener crashes
    #
    {:ok, socket} =
      :gen_tcp.listen(port, [:binary, packet: :line, active: false, reuseaddr: true])
    Logger.info("Accepting connections on port #{port}")
    loop_acceptor(socket)
  end

  defp loop_acceptor(socket) do
    {:ok, client} = :gen_tcp.accept(socket)
    serve(client)
    loop_acceptor(socket)
  end

  defp serve(socket) do
    socket
    |> read_line()
    |> write_line(socket)

    serve(socket)
  end

  defp read_line(socket) do
    {:ok, data} = :gen_tcp.recv(socket, 0)
    data
  end

  defp write_line(line, socket) do
    :gen_tcp.send(socket, line)
  end
end
```

我们将通过调用 `KVServer.accept(4040)` 来启动我们的服务器，其中 `4040` 是端口。`accept/1` 的第一步是监听该端口，直到套接字可用，然后调用 `loop_acceptor/1`。`loop_acceptor/1 `是一个循环，用于接受客户端连接。对于每个被接受的连接，我们调用 `serve/1`。

`serve/1` 是另一个循环，它从套接字读取一行，并将这些行写回套接字。请注意，`serve/1` 函数使用管道操作符` |>/2` 来表达这一操作流程。管道操作符计算左侧的值，并将其结果作为第一个参数传递给右侧的函数。

```elixir
socket |> read_line() |> write_line(socket)
```

等效于：

```elixir
write_line(read_line(socket), socket)
```

`read_line/1 `的实现使用` :gen_tcp.recv/2` 从套接字接收数据，而 `write_line/2 `则使用 `:gen_tcp.send/2` 向套接字写入数据。请注意，`serve/1 `是一个无限循环，依次在 `loop_acceptor/1 `中调用，因此对` loop_acceptor/1` 的尾调用永远不会被达到，可以避免。然而，正如我们将看到的，我们需要在一个单独的进程中执行 `serve/1`，所以我们很快就会需要这个尾调用。以上就是我们实现回声服务器所需的全部内容。让我们试一试吧!

这几乎是我们实现回声服务器所需要的一切。让我们试一试吧！

在 `kv_server `应用程序中启动一个 `IEx` 会话，可以使用 `⁠iex -S mix` 命令。在 `IEx` 中，运行：

```shell
iex> KVServer.accept(4040)
```
服务器现在正在运行，你会注意到控制台被阻塞了。我们来使用`telnet`客户端来访问我们的服务器。大多数操作系统都有可用的客户端，它们的命令行通常是相似的：

```shell
telnet 127.0.0.1 4040
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
hello
hello
is it me
is it me
you are looking for?
you are looking for?
```

输入“hello”，按回车键，您将收到“hello”。优秀！

我的特定telnet客户端可以通过输入`Ctrl + ]`、然后输入`quit`并按`<Enter>`键来退出，但您的客户端可能需要不同的步骤。

一旦您退出`telnet`客户端，您可能会在`IEx`会话中看到一个错误：

```markdown
** (MatchError) no match of right hand side value: {:error, :closed}
    (kv_server) lib/kv_server.ex:45: KVServer.read_line/1
    (kv_server) lib/kv_server.ex:37: KVServer.serve/1
    (kv_server) lib/kv_server.ex:30: KVServer.loop_acceptor/1
```

这因为我们期望从 `:gen_tcp.recv/2` 接收到数据，但客户端关闭了连接。我们需要在未来版本的服务器中更好地处理此类情况。

目前，我们需要修复一个更重要的 bug：如果我们的 TCP 接受器崩溃会发生什么？由于没有监督，服务器会崩溃，我们将无法处理更多请求，因为它将不会被重启。这就是为什么我们必须将服务器迁移到监督树。

## Tasks

我们已经学习了代理、通用服务器和监督者。它们都是为了处理多个消息或管理状态而设计的。但是当我们只需要执行某个任务时，该使用什么呢？

` Task` 模块正好提供了这个功能。例如，它有一个` Task.start_link/1` 函数，该函数接受一个匿名函数并在一个新的进程中执行该函数，而这个进程将成为监督树的一部分。

让我们试试看。打开 `lib/kv_server/application.ex`，然后我们将 `start/2` 函数中的监督者更改为以下内容：

```elixir
  def start(_type, _args) do
    children = [
      {Task, fn -> KVServer.accept(4040) end}
    ]

    opts = [strategy: :one_for_one, name: KVServer.Supervisor]
    Supervisor.start_link(children, opts)
  end
```

像往常一样，我们传递了一个包含两个元素的元组作为子进程的规格，它将调用 `Task.start_link/1`。

有了这个变化，我们表明希望将 `KVServer.accept(4040)` 作为任务来运行。目前我们对端口进行了硬编码，但可以通过几种方法进行更改，例如在启动应用程序时从系统环境中读取端口：

```elixir
port = String.to_integer(System.get_env("PORT") || "4040")
# ...
{Task, fn -> KVServer.accept(port) end}
```

将这些更改插入到你的代码中，现在你可以使用以下命令启动应用程序`：⁠PORT=4321 mix run --no-halt`。请注意，我们将端口作为变量传递，但如果未指定，则默认值仍为`4040`

现在服务器是监督树的一部分，它应该在我们运行应用程序时自动启动。启动你的服务器，传递端口，然后再次使用`Telnet`客户端确保一切正常。

```shell
telnet 127.0.0.1 4321
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
say you
say you
say me
say me
```

是的，它可以工作！不过，它能扩展吗？

尝试同时连接两个`telnet`客户端。当你这样做时，你会注意到第二个客户端没有回显。

```shell
telnet 127.0.0.1 4321
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
hello
hello?
HELLOOOOOO?
```

它似乎根本无法工作。这是因为我们在同一个进程中处理请求，接受连接。当一个客户端连接时，我们无法接受另一个客户端。

## Task supervisor

为了让我们的服务器能够处理同时连接，我们需要有一个进程作为接收器，来生成其他进程以处理请求。一种解决方案是更改：

```elixir
defp loop_acceptor(socket) do
  {:ok, client} = :gen_tcp.accept(socket)
  Task.start_link(fn -> serve(client) end)
  loop_acceptor(socket)
end
```

我们直接从接收者进程开始一个链接任务。但我们已经犯过一次这样的错误。你还记得吗？

这与我们直接从注册表调用` KV.Bucket.start_link/1` 时所犯的错误类似。这意味着任何一个桶的失败都会导致整个注册表崩溃。上面的代码有同样的缺陷：如果我们将 `serve(client)` 任务链接到接受者，处理请求时的崩溃将导致接受者以及所有其他连接崩溃。我们通过使用一个简单的一对一监督者来修复注册表的问题。我们将在这里使用相同的策略，只是这个模式在任务中非常常见，以至于 `Task `已经提供了解决方案：一个简单的一对一监督者，可以将临时任务作为我们监督树的一部分启动。

让我们再次更改 `start/2`，以在我们的树中添加一个监督者：

```elixir
  def start(_type, _args) do
    port = String.to_integer(System.get_env("PORT") || "4040")

    children = [
      {Task.Supervisor, name: KVServer.TaskSupervisor},
      {Task, fn -> KVServer.accept(port) end}
    ]

    opts = [strategy: :one_for_one, name: KVServer.Supervisor]
    Supervisor.start_link(children, opts)
  end
  ```

我们现在将启动一个名为 `KVServer.TaskSupervisor` 的 `Task.Supervisor` 进程。请记住，由于接受者任务依赖于此监视器，因此必须先启动监视器。现在，我们需要将 `loop_acceptor/1` 修改为使用 `Task.Supervisor` 来处理每个请求：

```elixir
defp loop_acceptor(socket) do
  {:ok, client} = :gen_tcp.accept(socket)
  {:ok, pid} = Task.Supervisor.start_child(KVServer.TaskSupervisor, fn -> serve(client) end)
  :ok = :gen_tcp.controlling_process(client, pid)
  loop_acceptor(socket)
end
```

你可能会注意到，我们添加了一行代码：`:ok = :gen_tcp.controlling_process(client, pid)`。这使得子进程成为客户端套接字的“控制进程”。如果我们不这样做，接受者在崩溃时会导致所有客户端都失效，因为套接字会绑定到接受它们的进程（这是默认行为）。启动一个新的服务器，使用命令 `PORT=4040 mix run --no-halt`，现在我们可以同时打开多个 telnet 客户端。你还会注意到，退出一个客户端并不会导致接受者崩溃。太棒了！

这里是完整的回声服务器实现：

```elixir
defmodule KVServer do
  require Logger

  @doc """
  Starts accepting connections on the given `port`.
  """
  def accept(port) do
    {:ok, socket} = :gen_tcp.listen(port,
                      [:binary, packet: :line, active: false, reuseaddr: true])
    Logger.info "Accepting connections on port #{port}"
    loop_acceptor(socket)
  end

  defp loop_acceptor(socket) do
    {:ok, client} = :gen_tcp.accept(socket)
    {:ok, pid} = Task.Supervisor.start_child(KVServer.TaskSupervisor, fn -> serve(client) end)
    :ok = :gen_tcp.controlling_process(client, pid)
    loop_acceptor(socket)
  end

  defp serve(socket) do
    socket
    |> read_line()
    |> write_line(socket)

    serve(socket)
  end

  defp read_line(socket) do
    {:ok, data} = :gen_tcp.recv(socket, 0)
    data
  end

  defp write_line(line, socket) do
    :gen_tcp.send(socket, line)
  end
end
```

由于我们已经更改了监督规范，我们需要问：我们的监督策略仍然正确吗？

在这种情况下，答案是肯定的：如果接受者崩溃了，现有连接不需要崩溃。另一方面，如果任务监督者崩溃了，也不需要让接受者崩溃。

然而，还有一个问题需要关注，那就是重启策略。默认情况下，任务的 `:restart` 值设置为 `:temporary`，这意味着它们不会被重启。这是通过 `Task.Supervisor` 启动的连接的一个优秀默认设置，因为重启一个失败的连接没有意义。然而，对接收器来说，这是一个糟糕的选择。如果接收器崩溃了，我们希望将接收器重新启动并恢复运行。

我们来修正一下这个问题。我们知道，对于形状为` {Task, fun}` 的子进程，`Elixir` 会调用 `Task.child_spec(fun) `来检索底层子进程规范。因此，可能有人会想要修改 `{Task, fun}` 规范，使其具有 `:restart `选项为` :permanent`，我们需要更改` Task` 模块。然而，这是不可能的，因为` Task `模块是作为 `Elixir` 标准库的一部分定义的（即使有可能这样做，这也不太可能是一个好主意）。幸运的是，我们可以使用 `Supervisor.child_spec/2` 来完成此操作，它允许我们用新值配置子进程规范。让我们再一次重写 `KVServer.Application` 中的 `start/2`：

```elixir
  def start(_type, _args) do
    port = String.to_integer(System.get_env("PORT") || "4040")

    children = [
      {Task.Supervisor, name: KVServer.TaskSupervisor},
      Supervisor.child_spec({Task, fn -> KVServer.accept(port) end}, restart: :permanent)
    ]

    opts = [strategy: :one_for_one, name: KVServer.Supervisor]
    Supervisor.start_link(children, opts)
  end
```

现在我们有一个始终在运行的接收器，它在一个始终在运行的任务管理器下启动临时任务进程。在下一章中，我们将开始解析客户端请求并发送响应，从而完成我们的服务器。