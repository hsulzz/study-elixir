# Mix简介

在本指南中，我们将构建一个完整的`Elixir`应用程序，其中包含自己的监督树、配置、测试等。
该应用程序作为一个分布式键值存储器工作。我们将把键值对组织成桶，并将这些桶分布在多个节点上。我们还将构建一个简单的客户端，允许我们连接到任何这些节点并发送请求，例如：

```elixir
CREATE shopping
OK

PUT shopping milk 1
OK

PUT shopping eggs 3
OK

GET shopping milk
1
OK

DELETE shopping eggs
OK
```

为了构建我们的关键价值应用程序，我们将使用三个主要工具：

- **OTP** Open Telecom Platform ）一套`Erlang`提供的库。`Erlang`开发者使用`OTP`来构建强大、容错的应用程序。

- **Mix** `Elixir`的构建工具，提供创建，编译，测试程序的，管理程序依赖等功能

- **ExUnit** 基于`Elixir`的单元测试框架


## 第一个项目

使用`mix new` 创建新项目

```shell
# `mix new` 的命令参考
  $ mix new PATH [--app APP] [--module MODULE] [--sup] [--umbrella]

"""
A project at the given PATH will be created. The application name and module
name will be retrieved from the path, unless --module or --app is given.

An --app option can be given in order to name the OTP application for the
project.

A --module option can be given in order to name the modules in the generated
code skeleton.

A --sup option can be given to generate an OTP application skeleton including
a supervision tree. Normally an app is generated without a supervisor and
without the app callback.

An --umbrella option can be given to generate an umbrella project.
"""
```

执行如下命令创建项目

```shell
mix new kv --module KV
```

生成如下文件

```shell
* creating README.md
* creating .formatter.exs
* creating .gitignore
* creating mix.exs
* creating lib
* creating lib/kv.ex
* creating test
* creating test/test_helper.exs
* creating test/kv_test.exs
```

### 项目编译

`mix.exs` 主要用于配置项目,文件中主要定义了

- 公共函数
  - `project` 返回项目配置，如项目名称和版本
  - `application` 用于生成应用程序文件。

- 私有函数
  - `deps` 被`project`函数调用，定义程序的依赖，单独定义`deps`函数不是必须的，但是这会让项目配置保持整洁

```elixir
defmodule KV.MixProject do
  use Mix.Project

  def project do
    [
      app: :kv,
      version: "0.1.0",
      elixir: "~> 1.17",
      start_permanent: Mix.env() == :prod,
      deps: deps()
    ]
  end

  # Run "mix help compile.app" to learn about applications.
  def application do
    [
      extra_applications: [:logger]
    ]
  end

  # Run "mix help deps" to learn about dependencies.
  defp deps do
    [
      # {:dep_from_hexpm, "~> 0.3.0"},
      # {:dep_from_git, git: "https://github.com/elixir-lang/my_dep.git", tag: "0.1.0"}
    ]
  end
end
```

mix还生成了`lib/kv.ex`文件，包含了一个`hello`函数

```elixir
defmodule KV do
  @moduledoc """
  Documentation for KV.
  """

  @doc """
  Hello world.

  ## Examples

    iex> KV.hello()
    :world

  """
  def hello do
    :world
  end
end
```

以上结构已经足够用于编译,执行下方命令，`lib/kv.ex`被编译成一个名为`kv.app`的程序清单，所有编译工件都放置于`_build`文件夹下，基于`mix.exs`文件中定义的选项。

```shell
╰─± cd kv 

╰─± mix compile
Compiling 1 file (.ex)
Generated kv app
```

项目编译完成后，可以通过`iex -S mix`在项目下启动一个session，`-S mix`选项用于将项目加载到交互shell中,当项目代码变动时，可以在iex中直接重新编译

```shell
# 因为代码没有改变，返回`:noop`
iex(1)> recompile()
:noop
```

## 运行测试

Mix还为运行我们的项目测试生成了适当的结构。mix项目始终遵循命名规范在`test`目录中为`lib`目录中的每个文件提供`<filename>_test.exs`,因此，我们已经可以看到一个与`lib/kv.ex`相对应的`test/kv.exs`测试文件

```elixir
defmodule KVTest do
  use ExUnit.Case
  doctest KV

  test "greets the world" do
    assert KV.hello() == :world
  end
end
```

比较重要的几点：

1. 测试文件是一个`.exs`脚本文件。因为我们不想在执行他们之前编译测试文件。

2. 我们定义了一个`KVTest`的模块，并使用`use ExUnit.Case`注入测试API

3. 使用导入的宏`ExUnit.DocTest.doctest/1`来表明KV模块包含文档测试

Mix还生成来了一个`test/test_helper.exs`文件，用与设定测试框架。

```elixir
ExUnit.stat()
```

在我们运行测试之前，Mix每次都需要此文件。我们可以用`mix test`执行测试：
执行`mix test`，mix又将代码重新编译了一次，这是因为mix支持多环境，测试环境的代码默认被放到了`_build/test`文件夹下。

```shell
╰─± mix test
Compiling 1 file (.ex)
Generated kv app
Running ExUnit with seed: 445614, max_cases: 20

..
Finished in 0.00 seconds (0.00s async, 0.00s sync)
1 doctest, 1 test, 0 failures
```

修改`test/kv_test.exs`的assertion

```elixir
assert KV.hello() == :oops
```

重新执行`mix test`(这次没有重新编译代码)

```shell
╰─± mix test
Running ExUnit with seed: 897642, max_cases: 20

  1) test greets the world (KVTest)
     test/kv_test.exs:5
     Assertion with == failed
     code:  assert KV.hello() == :oops
     left:  :world
     right: :oops
     stacktrace:
       test/kv_test.exs:7: (test)

.
Finished in 0.01 seconds (0.00s async, 0.01s sync)
1 doctest, 1 test, 1 failure
```

`ExUnit`会给每个失败用例打印详细的报告，包含测试用例名称，失败的代码，以及`==`左侧和右侧的值

## 自动代码格式化

`mix new`还生成了`.formatter.exs`文件，`Elixir`提供了代码格式化工具，他可以按照恒定的风格自动化格式化我们的代码。执行`mix format`触发格式化任务。`.formatter.exs`定义了需要格式化的文件

建议开发者在CI中运行 `mix format --check-formatted`确保当前和将来的代码都符合标准。

## 环境

mix提供了环境的概念，这让开发者可以自定义编译和为特定场景制定其他选项。mix默认理解下面三个环境

- `:dev` mix任务执行的默认环境（如 `compile`)
- `:test` 用于`mix test`
- `:prod` 用于在生成环境执行项目

环境只应用于当前项目，可以访问`mix.exs`文件中的`Mix.env/0`获取当前环境，我么在`:start_permanent`选项中使用了它

```elixir
def project do
  [
     ...,
     start_permanent: Mix.env() == :prod,
     ...
  ]
end
```

当返回`true`时，`:start_permanent`选项以永久模式启动应用程序，这意味着如果应用程序的监督树关闭，Erlang VM将崩溃。请注意，我们不希望在开发和测试中有这种行为，因为出于故障排除目的，保持虚拟机实例在这些环境中运行是有用的。

Mix将默认为`:dev`环境，`:test`环境的测试任务除外。可以通过`MIX_ENV`环境变量更改环境：

```shell
MIX_ENV=prod mix compile
```