# [分布式任务和标签 ](https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/pages/mix-and-otp/distributed-tasks.md#L1)


在这一章中，我们将回到 `:kv` 应用程序，并添加一个路由层，以便根据桶名称在节点之间分配请求。

路由层将接收以下格式的路由表：

```elixir
[
  {?a..?m, :"foo@computer-name"},
  {?n..?z, :"bar@computer-name"}
]
```

路由器将检查桶名称的第一个字节与表格进行匹配，并根据该字节将其调度到适当的节点。例如，以字母“a”开头的桶（“a”表示字母“a”的Unicode编码点）将被调度到节点`foo@computer-name`。

如果匹配的条目指向正在处理请求的节点，那么我们已经完成路由，这个节点将执行请求的操作。 如果匹配的条目指向不同的节点，我们将把请求传递给该节点，该节点将查看自己的路由表（可能与第一个节点的路由表不同）并相应地执行。 如果没有匹配的条目，将会引发错误。

> 注意：在本章中，我们将使用同一台机器上的两个节点。您可以自由使用同一网络上的两台（或更多）不同机器，但首先需要进行一些准备工作。首先，请确保所有机器都有一个`~/.erlang.cookie`文件，并且其内容完全相同。然后，您需要确保`epmd`运行在一个未被阻塞的端口上（您可以运行`epmd -d`获取调试信息）。

## 第一个分布式代码

Elixir 附带了连接节点并在它们之间交换信息的功能。事实上，我们在分布式环境中工作时使用相同的概念，如进程、消息传递和接收消息，因为 Elixir 进程是位置透明的。这意味着在发送消息时，接收进程是在同一个节点上还是在另一个节点上并不重要，虚拟机在这两种情况下都能够传递消息。

为了运行分布式代码，我们需要使用一个名称启动虚拟机。这个名称可以是短的（在同一网络中）或长的（需要完整的计算机地址）。让我们开始一个新的 IEx 会话：

```shell
iex --sname foo
```

您现在可以看到提示略有不同，它显示了节点名称以及计算机名称：

```shell
Interactive Elixir (1.17.2) - press Ctrl+C to exit (type h() ENTER for help)
iex(foo@Z-MBP-M2)1>
```

我的计算机名称是 `Z-MBP-M2`，因此在上面的示例中我看到 `foo@Z-MBP-M2`，但您会得到不同的结果。我们将在以下示例中使用 `foo@计算机名称`，您在尝试代码时应相应地进行更新。

让我们在这个终端中定义一个名为 `Hello` 的模块：

```elixir
iex(foo@Z-MBP-M2)1> defmodule Hello do
...(foo@Z-MBP-M2)1>   def world, do: IO.puts "hello world"
...(foo@Z-MBP-M2)1> end
```

如果你在同一个网络上有另一台安装`了Erlan`g和`Elixir`的计算机，你可以在其上启动另一个`shell`。如果没有，你可以在另一个终端中启动另一个`IEx`会话。在这两种情况下，请将短名称设置为`bar`：

```shell
iex --sname bar
```

请注意，在这个新的 `IEx` 会话中，我们无法访问 `Hello.world/0`。

```shell
iex(bar@Z-MBP-M2)1> Hello.world
** (UndefinedFunctionError) function Hello.world/0 is undefined (module Hello is not available)
    Hello.world()
    iex:1: (file)
```

但是，我们可以在 `bar@computer-name` 上从 `foo@computer-name` 启动一个新进程！让我们试试看（其中 `@computer-name` 是您本地看到的名称）：

```shell
iex(bar@Z-MBP-M2)2> Node.spawn_link(:"foo@Z-MBP-M2", fn -> Hello.world() end)
#PID<14265.119.0>
hello world
```

Elixir 在另一个节点上生成了一个进程并返回了它的 PID。然后代码在存在 `Hello.world/0` 函数的另一个节点上执行并调用了该函数。请注意，“hello world”的结果是在当前节点（bar）上打印的，而不是在（foo）上。换句话说，打印的消息是从（foo）发送回（bar）的。这是因为在另一个节点（foo）上生成的进程知道所有输出应发送回原始节点！

我们可以像往常一样从 `Node.spawn_link/2 `返回的 PID 发送和接收消息。让我们试一个快速的ping-pong示例：

```elixir
iex(bar@Z-MBP-M2)3> pid =Node.spawn_link(:"foo@Z-MBP-M2", fn->
...(bar@Z-MBP-M2)3>     receive do
...(bar@Z-MBP-M2)3>         {:ping, client} -> send(client,:pong)
...(bar@Z-MBP-M2)3>     end
...(bar@Z-MBP-M2)3> end)
#PID<14265.120.0>
iex(bar@Z-MBP-M2)4> send(pid, {:ping, self()})
{:ping, #PID<0.114.0>}
iex(bar@Z-MBP-M2)5> flush()
:pong
:ok
```

根据我们的快速探索，我们可以得出结论，每当我们需要进行分布式计算时，应该使用 ⁠Node.spawn_link/2 在远程节点上创建进程。然而，在本指南中，我们了解到尽量避免在监督树之外创建进程，因此我们需要寻找其他选项。

在我们的实现中，有三个比 `⁠Node.spawn_link/2` 更好的替代方案：
1.	我们可以使用` Erlang` 的 `⁠:erp`c 模块在远程节点上执行函数。 在上面的 `⁠bar@computer-name` shell 中，您可以调用 `⁠:erpc.call(:"foo@computer-name", Hello, :world, [])`，它将打印“hello world”。
2.	我们可以在另一个节点上运行一个服务器，并通过 `GenServer` API 向该节点发送请求。例如，您可以使用 `⁠GenServer.call({name, node}, arg)` 调用远程节点上的服务器，或者将远程进程的 `PID` 作为第一个参数传递。
3.	我们可以使用任务，这是我们在前一章中学到的，因为它们可以在本地和远程节点上创建。

这些选项具有不同的属性。`GenServer`将在单个服务器上序列化您的请求，而任务在远程节点上异步运行，唯一的序列化点是由监督者进行的生成。

对于我们的路由层，我们将使用任务，但请随时探索其他替代方案。

## async/await

到目前为止，我们已经探讨了那些独立启动和运行的任务，而不考虑它们的返回值。然而，有时候运行一个任务以计算一个值并在之后读取其结果是很有用的。为此，任务还提供了` async/await` 模式：

```elixir
task = Task.async(fn -> compute_something_expensive() end)
res  = compute_something_else()
res + Task.await(task)
```

`async/await` 提供了一种非常简单的机制来并发计算值。不仅如此，它还可以与我们在前面的章节中使用的同一个` Task.Supervisor` 一起使用。我们只需调用 `Task.Supervisor.async/2`，而不是 `Task.Supervisor.start_child/2`，并使用` Task.await/2` 来稍后读取结果。

## 分布式任务

分布式任务与有监督任务是完全一样的。唯一的区别在于我们在启动任务时传递节点名称给监督者。从`:kv` 应用程序中打开 `lib/kv/supervisor.ex`。让我们将一个任务监督者作为树的最后一个子节点添加进去。

```elixir
{Task.Supervisor, name: KV.RouterTasks},
```

现在，让我们在`:kv` 应用程序内部再次启动两个命名节点：

```shell
iex --sname foo -S mix
iex --sname bar -S mix
```

从计算机名称中的内部命令行，我们现在可以通过管理者直接在另一个节点上生成任务：

```elixir
task = Task.Supervisor.async({KV.RouterTasks, :"foo@computer-name"}, fn ->
  {:ok, node()}
end)
%Task{
  mfa: {:erlang, :apply, 2},
  owner: #PID<0.122.0>,
  pid: #PID<12467.88.0>,
  ref: #Reference<0.0.0.400>
}
Task.await(task)
{:ok, :"foo@computer-name"}
```

我们的第一个分布式任务是获取任务运行所在节点的名称。请注意，我们将一个匿名函数传递给了` Task.Supervisor.async/2`，但在分布式情况下，更好地明确给出模块、函数及参数。

```elixir
task = Task.Supervisor.async({KV.RouterTasks, :"foo@computer-name"}, Kernel, :node, [])
%Task{
  mfa: {Kernel, :node, 0},
  owner: #PID<0.122.0>,
  pid: #PID<12467.89.0>,
  ref: #Reference<0.0.0.404>
}
Task.await(task)
:"foo@computer-name"
```

不同之处在于匿名函数要求目标节点必须与调用者拥有完全相同的代码版本。使用模块、函数和参数更为稳健，因为您只需要在给定的模块中找到一个具有匹配参数数目的函数。

## 路由层

在`lib/kv/router.ex` 中创建一个文件，内容如下：

```elixir
defmodule KV.Router do
  @doc """
  Dispatch the given `mod`, `fun`, `args` request
  to the appropriate node based on the `bucket`.
  """
  def route(bucket, mod, fun, args) do
    # Get the first byte of the binary
    first = :binary.first(bucket)

    # Try to find an entry in the table() or raise
    entry =
      Enum.find(table(), fn {enum, _node} ->
        first in enum
      end) || no_entry_error(bucket)

    # If the entry node is the current node
    if elem(entry, 1) == node() do
      apply(mod, fun, args)
    else
      {KV.RouterTasks, elem(entry, 1)}
      |> Task.Supervisor.async(KV.Router, :route, [bucket, mod, fun, args])
      |> Task.await()
    end
  end

  defp no_entry_error(bucket) do
    raise "could not find entry for #{inspect bucket} in table #{inspect table()}"
  end

  @doc """
  The routing table.
  """
  def table do
    # Replace computer-name with your local machine name
    [{?a..?m, :"foo@computer-name"}, {?n..?z, :"bar@computer-name"}]
  end
end
```

让我们编写一个测试，以验证我们的路由器是否正常工作。创建一个名为 `test/kv/router_test.exs` 的文件，内容为：

```elixir
defmodule KV.RouterTest do
  use ExUnit.Case, async: true

  test "route requests across nodes" do
    assert KV.Router.route("hello", Kernel, :node, []) ==
             :"foo@computer-name"
    assert KV.Router.route("world", Kernel, :node, []) ==
             :"bar@computer-name"
  end

  test "raises on unknown entries" do
    assert_raise RuntimeError, ~r/could not find entry/, fn ->
      KV.Router.route(<<0>>, Kernel, :node, [])
    end
  end
end
```

第一个测试调用 `Kernel.node/0`，它根据桶名“hello”和“world”返回当前节点的名称。根据我们到目前为止的路由表，我们应该分别得到 foo@计算机名称 和 bar@计算机名称 的响应。

第二个测试检查代码是否对未知条目引发错误。

为了运行第一个测试，我们需要有两个节点在运行。我们进入 apps/kv 目录，重启名为 bar 的节点，该节点将用于测试。

```shell
iex --sname bar -S mix
```

现在，使用以下内容运行测试

```shell
elixir --sname foo -S mix test
```

测试应该通过。

## Test filters and tags

虽然我们的测试通过了，但我们的测试结构变得越来越复杂。尤其是，仅使用 `mix test`运行测试会导致我们测试套件中的失败，因为我们的测试需要与另一个节点建立连接。

幸运的是，`ExUnit` 附带了一个标记测试的功能，这使我们能够根据这些标签运行特定的回调，甚至完全过滤测试。在前一章中，我们已经使用了 `⁠:capture_log` 标签，该标签的语义由 `ExUnit` 本身定义。

这次，让我们在 `⁠test/kv/router_test.exs` 中添加一个 `⁠:distributed` 标签。

```elixir
@tag :distributed
test "route requests across nodes" do
```

编写 `⁠@tag :distributed` 相当于编写 `⁠@tag distributed: true`。当测试正确标记后，我们可以检查节点是否在网络上存活，如果没有，我们可以排除所有分布式测试。打开` ⁠:kv `应用中的 `⁠test/test_helper.exs` 并添加以下内容：

```elixir
exclude =
  if Node.alive?(), do: [], else: [distributed: true]

ExUnit.start(exclude: exclude)
```

现在运行测试，使用 ⁠`mix test`

```shell
mix test
Excluding tags: [distributed: true]

.......

Finished in 0.05 seconds
9 tests, 0 failures, 1 excluded
```

这次，所有测试都通过了，ExUnit 警告我们分布式测试被排除了。如果使用 `$ elixir --sname foo -S mix test` 运行测试，只要 `bar@computer-name` 节点可用，就会运行一个额外的测试并成功通过。

`mix test`命令还允许我们动态地包含和排除标签。例如，我们可以执行 `$ mix test --include distributed` 来运行分布式测试，而不管在 `test/test_helper.exs` 中设置的值如何。我们也可以传递 `--exclude` 来从命令行排除特定标签。最后，`--only` 可用于仅运行带有特定标签的测试。

```shell
elixir --sname foo -S mix test --only distributed
```

您可以在 `ExUnit.Case` 模块文档中读取有关过滤器、标签和默认标签的更多信息。

## 将所有的连接起来

现在我们有了路由系统，让我们将 `KVServer` 更改为使用路由器。将 `KVServer.Command` 中的 `lookup/2` 函数替换为以下内容：

```elixir
defp lookup(bucket, callback) do
  case KV.Router.route(bucket, KV.Registry, :lookup, [KV.Registry, bucket]) do
    {:ok, pid} -> callback.(pid)
    :error -> {:error, :not_found}
  end
end
```

我们不再直接查找注册表，而是使用路由器来匹配特定的节点。接着，我们获得一个可以来自集群中任何进程的 pid。从现在开始，GET、PUT 和 DELETE 请求将全部路由到相应的节点。

让我们确保在创建新桶时，它会被分配到正确的节点。将 `KVServer.Command` 中与 `:create` 命令匹配的 `run/1` 函数替换为以下内容：

```elixir
def run({:create, bucket}) do
  case KV.Router.route(bucket, KV.Registry, :create, [KV.Registry, bucket]) do
    pid when is_pid(pid) -> {:ok, "OK\r\n"}
    _ -> {:error, "FAILED TO CREATE BUCKET"}
  end
end
```

现在，如果你运行测试，你会发现一个检查服务器交互的现有测试会失败，因为它尝试使用路由表。为了解决这个失败，像我们对`:kv`所做的那样，修改`:kv_server`应用程序的`test_helper.exs`，并将`@tag :distributed`也添加到
这个测试中：

```elixir
@tag :distributed
test "server interaction", %{socket: socket} do
```

但是，请记住，通过将测试分布式处理，我们可能会减少运行频率，因为我们可能不会在每次测试运行中都设置分布式环境。我们将在下一章学习如何有效地使路由表可配置，从而解决这个问题。

## 总结


我们对分布式系统的可能性仅仅是触及了皮毛。

在我们所有的示例中，我们依赖于Erlang的能力，在每次请求时自动连接节点。例如，当我们调用 Node.spawn_link(:"foo@computer-name", fn -> Hello.world() end) 时，Erlang会自动连接到指定节点并启动一个新进程。然而，您也可能希望采用更明确的连接方式，使用 Node.connect/1 和 Node.disconnect/1。

默认情况下，Erlang建立一个完全互连的网络，这意味着所有节点彼此相连。在这种拓扑结构下，Erlang的分布式系统能够扩展到同一集群中的数十个节点。Erlang还具有隐藏节点的概念，这使开发者能够构建自定义拓扑，如在Partisan项目中所见。

在生产环境中，节点可能随时连接和断开。在这种情况下，您需要提供节点的可发现性。像libcluster和dns_cluster这样的库提供使用DNS、Kubernetes等进行节点可发现的多种策略。

在实际应用中的分布式键值存储需要考虑节点随时可能上下线，并且还需在节点之间迁移桶。此外，桶通常需要在节点之间进行复制，以确保一个节点的故障不会导致整个桶的丢失。这个过程称为复制。我们的实现不会尝试解决此类问题，而是假设节点数量是固定的，因此使用一个固定的路由表。

这些主题乍一听可能令人畏惧，但请记住，大多数Elixir框架为您抽象了这些问题。例如，当使用Phoenix Web框架时，它的即插即用抽象能够处理消息的发送以及用户如何加入和离开集群的跟踪。然而，如果您对分布式系统仍然感兴趣，还有很多值得探索的内容。这里有一些额外的参考资料：

- 《Learn You Some Erlang》中优秀的Distribunomicon章节
- Erlang的全局模块，可以提供全局名称和全局锁，从而在整个机器集群中实现唯一名称和唯一锁
- Erlang的pg模块，允许进程加入跨整个集群共享的不同组
- Phoenix PubSub项目，提供分布式消息系统和用于跟踪集群中用户和进程的分布式在线系统

您还会在整个Erlang生态系统中找到许多用于构建分布式系统的库。现在，是时候回到我们的简单分布式键值存储，学习如何为生产环境进行配置和打包了。