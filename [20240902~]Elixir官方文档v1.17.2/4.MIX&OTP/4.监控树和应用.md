# 监控树和应用

在上一章`GenServer`相关内容中，我们实现了`KV.Registry`来管理存储桶。在某些时候，监存储桶，可以让我们在`KV.Bucket`崩溃时采取行动。虽然变化相对较小，但它引入了一个`Elixir`开发人员经常问的问题：当失败时会发生什么?

在我们添加监控之前，如果存储桶崩溃，注册表将永远指向不再存在的存储桶。如果用户尝试读取或写入崩溃的桶，它将失败。任何尝试创建具有相同名称的新存储桶的尝试都会返回崩溃存储桶的`PID`。换句话说，那个桶的注册表条目将永远处于糟糕的状态。一旦我们添加了监控，注册表就会自动删除崩溃桶的条目。现在尝试查找崩溃的存储桶（正确）显示存储桶不存在，如果需要，系统用户可以成功创建一个新的存储桶。

在实践中，我们并不期望像桶一样工作的过程会失败。但是，如果它确实发生了，无论出于什么原因，我们可以放心，我们的系统将继续按预期工作。

如果您之前有编程经验，您可能会想：“我们可以保证桶一开始就不会崩溃吗？”。正如我们将看到的，Elixir开发人员倾向于将这些做法称为“防御性编程”。这是因为生产系统有很多不同的原因导致出错。磁盘可能会出现故障，内存可能会损坏，出现错误，网络可能会停止工作一秒钟，等等。如果我们编写试图保护或规避所有这些错误的软件，我们将花更多时间处理故障，而不是编写自己的软件！

因此，Elixir开发人员更喜欢“让它崩溃”或“快速失败”。我们从故障中恢复的最常见方法之一是重新启动系统崩溃的任何部分。

例如，想象一下您的计算机、路由器、打印机或任何设备无法正常工作。你多久重新启动一次来修复它？一旦我们重新启动设备，我们将设备重置为初始状态，该状态已过良好测试，并保证工作。在Elixir中，我们对软件应用了同样的方法：每当进程崩溃时，我们都会启动一个新进程来执行与崩溃进程相同的工作。

在Elixir中，这是由Supervisor完成的。Supervisor是一个监督其他进程并在它们崩溃时重新启动的进程。为做到这一点，Supervisor管理任何受监督进程的整个生命周期，包括启动和关闭。

在本章中，我们将学习如何通过监督`KV.Registry`进程，将这些概念付诸实践。毕竟，如果注册表出了问题，整个注册表就会丢失，再也找不到桶了！为了解决这个问题，我们将定义一个`KV.Supervisor`模块，以保证我们的`KV.Registry`在任何给定时刻都能启动并运行。

在本章的结尾，我们还将讨论应用程序。正如我们将看到的，Mix一直在将我们所有的代码打包到一个应用程序中，我们将学习如何自定义我们的应用程序，以确保我们的Supervisor和注册表在系统启动时都能启动并运行。


## Our first Supervisor

Supervisor是监督其他进程的进程，我们称之为子进程。监督一个过程的行为包括三个不同的责任，第一个是启动子进程。一旦子进程运行，Supervisor可能会重新启动子进程，要么是因为它异常终止，要么是因为满足某个条件。例如，如果任何子进程死亡，Supervisor可以重新启动所有子进程。最后，当系统关闭时，Supervisor还负责关闭子进程。有关更深入的讨论，请参阅Supervisor模块。

创建Supervisor与创建GenServer没有太大区别。我们将在`lib/supervisor.ex`文件中定义一个名为`KV.Supervisor`的模块，该模块将使用Supervisor行为：

到目前为止，我们的Supervisor只有一个子进程：`KV.Registry`。在我们定义一个子列表后，我们调用`Supervisor.init/2`，传递子进程和监督策略。

监督策略决定了当其中一个子进程崩溃时会发生什么。`:one_for_one`意味着如果一个子进程死亡，它将是唯一一个重新启动的子进程。我们现在就只有一个子进程，这就够了。Supervisor行为支持几种策略，我们将在本章中讨论。

一旦Supervisor启动，它将遍历子项列表，并将在每个模块上调用`child_spec/1`函数。

`child_spec/1`函数返回子进程spec，该spec描述了如何启动进程，该进程是worker还是Supervisor，该进程是临时的、流动的还是永久的等等。当我们使用`agent`、`GenServer`、使用`Supervisor`等时，`child_spec/1`函数会自动定义。让我们在`iex-S mix`的终端中尝试一下：

```elixir
iex(1)> KV.Registry.child_spec([])
%{
  id: KV.Registry,
  start: {KV.Registry, :start_link,
   [[]]}
}
```

在推进本指南时，我们将了解这些细节。如果您更愿意提前查看，请查看`Supervisor`文档。

在`Supervisor`获取所有子进程spec后，它将按照定义的顺序逐一启动其子进程，使用子进程spec中`:start`键的信息。对于我们当前的规范，它将调用`KV.Registry.start_link([])`。

```elixir
iex(2)> {:ok, sup} = KV.Supervisor.start_link([])
{:ok, #PID<0.150.0>}
iex(3)> Supervisor.which_children(sup)
[
  {KV.Registry, #PID<0.151.0>,
   :worker, [KV.Registry]}
]
```

到目前为止，我们已经启动了Supervisor，并列出了其子进程。一旦Supervisor启动，他会启动所有子进程。

如果我们故意破坏Supervisor启动的注册表，会发生什么？让我们通过`call`发送错误输入：

```elixir
iex(4)> [{_, registry, _, _}] = Supervisor.which_children(sup)
[
  {KV.Registry, #PID<0.151.0>,
   :worker, [KV.Registry]}
]
iex(5)> GenServer.call(registry, :bad_input)

14:48:01.832 [error] GenServer #PID<0.151.0> terminating
** (FunctionClauseError) no function clause matching in KV.Registry.handle_call/3
    (kv 0.1.0) lib/registry.ex:39: KV.Registry.handle_call(:bad_input, {#PID<0.149.0>, [:alias | #Reference<0.0.19075.2674133225.1061224453.159218>]}, {%{}, %{}})
    (stdlib 6.0.1) gen_server.erl:2209: :gen_server.try_handle_call/4
    (stdlib 6.0.1) gen_server.erl:2238: :gen_server.handle_msg/6
    (stdlib 6.0.1) proc_lib.erl:329: :proc_lib.init_p_do_apply/3
Last message (from #PID<0.149.0>): :bad_input
State: {%{}, %{}}
Client #PID<0.149.0> is alive

    (stdlib 6.0.1) gen.erl:260: :gen.do_call/4
    (elixir 1.17.2) lib/gen_server.ex:1125: GenServer.call/3
    (elixir 1.17.2) src/elixir.erl:386: :elixir.eval_external_handler/3
    (stdlib 6.0.1) erl_eval.erl:904: :erl_eval.do_apply/7
    (elixir 1.17.2) src/elixir.erl:364: :elixir.eval_forms/4
    (elixir 1.17.2) lib/module/parallel_checker.ex:112: Module.ParallelChecker.verify/1
    (iex 1.17.2) lib/iex/evaluator.ex:332: IEx.Evaluator.eval_and_inspect/3
    (iex 1.17.2) lib/iex/evaluator.ex:306: IEx.Evaluator.eval_and_inspect_parsed/3
** (exit) exited in: GenServer.call(#PID<0.151.0>, :bad_input, 5000)
    ** (EXIT) an exception was raised:
        ** (FunctionClauseError) no function clause matching in KV.Registry.handle_call/3
            (kv 0.1.0) lib/registry.ex:39: KV.Registry.handle_call(:bad_input, {#PID<0.149.0>, [:alias | #Reference<0.0.19075.2674133225.1061224453.159218>]}, {%{}, %{}})
            (stdlib 6.0.1) gen_server.erl:2209: :gen_server.try_handle_call/4
            (stdlib 6.0.1) gen_server.erl:2238: :gen_server.handle_msg/6
            (stdlib 6.0.1) proc_lib.erl:329: :proc_lib.init_p_do_apply/3
    (elixir 1.17.2) lib/gen_server.ex:1128: GenServer.call/3
    iex:5: (file)
iex(5)> Supervisor.which_children(sup)
[
  {KV.Registry, #PID<0.152.0>,
   :worker, [KV.Registry]}
]
```

请注意，Supervisor如何自动启动一个新的注册表，使用新的PID来代替因输入错误导致崩溃的旧注册表。

在前几章中，我们总是直接启动进程。例如，调用`KV.Registry.start_link([])`，它将返回`{:ok, pid}`，这将允许我们通过`pid`与其交互。既然进程是由Supervisor启动的，我们必须直接询问Supervisor谁是其子进程，并从返回的子列表中获取PID。在实践中，每次都这样做会非常昂贵。为了解决这个问题，我们通常会为进程命名，允许它们从代码中的任何地方在一台机器中唯一识别。

## 给进程命名

虽然我们的应用程序将有许多存储桶，但它将只有一个注册表。因此，每当我们启动registy时，我们都想给它一个唯一的名称，这样我们就可以从任何地方访问它。我们通过将`:name`选项传递给`KV.Registry.start_link/1`来做到这一点。

让我们稍微改变我们的子定义（`KV.Supervisor.init/1`），变成元组列表，而不是原子列表：

```elixir
  def init(:ok) do
    children = [
      {KV.Registry, name: KV.Registry}
    ]
```

有了这个，supervisor 现在将通过调用`KV.Registry.start_link(name: KV.Registry)`来启动`KV.Registry`。

如果您重新访问`KV.Registry.start_link/1`实现，您会记住它只是将选项传递给`GenServer`：

```elixir
  def start_link(opts) do
    GenServer.start_link(__MODULE__, :ok, opts)
  end
```
这将用给定的名称注册进程。`:name`选项期望为本地命名的进程提供一个原子（本地命名意味着它可用于此机器——还有其他选项，我们在这里不会讨论）。由于模块标识符是原子（在`IEx`中尝试`i（KV.Registry）`），我们可以以实现它的模块命名一个进程，前提是该名称只有一个进程。这有助于调试和内省系统。

让我们在`iex-S mix`尝试一下更新的supervisor：

```elixir
iex(1)> KV.Supervisor.start_link([])
{:ok, #PID<0.141.0>}
iex(2)> KV.Registry.create(KV.Registry, "shopping")
:ok
iex(3)> KV.Registry.lookup(KV.Registry, "shopping")
{:ok, #PID<0.143.0>}
```

这一次，Supervisor启动了一个命名的注册表，允许我们创建存储桶，而无需从Supervisor那里明确获取PID,。您还应该知道如何在不查找其PID的情况下再次使注册表崩溃：试一试。

在这一点上，您可能想知道：您是否也应该在本地命名存储桶进程？请记住，存储桶是根据用户输入动态启动的。由于本地名称必须是原子，我们必须动态创建原子，这是一个坏主意，因为一旦定义了原子，它永远不会被删除或垃圾收集。这意味着，如果我们根据用户输入动态创建原子，我们最终将耗尽内存（或者更准确地说，虚拟机将崩溃，因为它对原子数量施加了硬限制）。这一限制正是我们创建自己的注册表的原因（或者为什么人们会使用Elixir的内置注册表模块）。

我们越来越接近一个功能齐全的系统。Supervisor自动启动注册表。但是，每当我们的系统启动时，我们如何自动启动Supervisor？为了回答这个问题，让我们来谈谈应用程序。

## 理解应用

这段时间，我们一直在应用程序内工作。每次我们更改文件并运行`mix compile`时，我们都可以在编译输出中看到`Generated kv app`消息。

我们可以在`_build/dev/lib/kv/ebin/kv.app`上找到生成的`.app`文件。让我们看看它的内容：

```elixir
{application,kv,
             [{applications,[kernel,stdlib,elixir,logger]},
              {description,"kv"},
              {modules,['Elixir.KV','Elixir.KV.Bucket','Elixir.KV.Registry',
                        'Elixir.KV.Supervisor']},
              {registered,[]},
              {vsn,"0.1.0"}]}.
```

此文件包含`Erlang`术语（使用`Erlang`语法编写）。尽管我们不熟悉`Erlang`，但很容易猜到这个文件包含我们的应用程序定义。它包含我们的应用程序版本、它定义的所有模块，以及我们依赖的应用程序列表，如`Erlang`的内核、`elixir`本身和`logger`。

> `logger`应用程序作为`Elixir`的一部分。我们通过在`mix.exs`的`:extra_applications`列表中指定它来声明我们的应用程序需要它。有关更多信息，请参阅[官方文件](https://hexdocs.pm/logger/Logger.html)。

简而言之，应用程序由`.app`文件中定义的所有模块组成，包括`.app`文件本身。应用程序通常只有两个目录`:ebin`，用于`Elixir`工件，如`.beam`和`.app`文件，以及`priv`，以及您在应用程序中可能需要的任何其他工件或assets。

虽然`Mix`为我们生成和维护`.app`文件，但我们可以通过向`mix.exs`项目文件中的`application/0`函数添加新条目来自定义其内容。我们很快就会进行第一次定制。

## 启动程序

我们系统中的每个应用程序都可以启动和停止。启动和停止应用程序的规则也在`.app`文件中定义。当我们调用`iex -S mix`时，Mix会编译我们的应用程序，然后启动它。

让我们在实践中看看这个。使用`iex -S mix`启动控制台并尝试：

```elixir
iex(1)> Application.start(:kv)
{:error, {:already_started, :kv}}
```

哎呀，它已经启动了。`Mix`会自动启动当前应用程序及其所有依赖项。`mix test`和许多其他混合命令也是如此。

然而，我们可以停止我们的`:kv`应用程序，以及`:logger`应用程序：

```elixir
iex(2)> Application.stop(:kv)

22:41:52.819 [notice] Application kv exited: :stopped
:ok
iex(3)> Application.stop(:logger)
:ok
```

让我们尝试再次启动我们的应用程序：

```elixir
iex(4)> Application.start(:kv)
{:error, {:not_started, :logger}}
```
现在我们收到一个错误，因为`:kv`依赖的应用程序（在这种情况下是`:logger`）没有启动。我们需要按照正确的顺序手动启动每个应用程序,或者调用`Application.ensure_all_started/1 `

```elixir
iex(5)> Application.ensure_all_started(:kv)
{:ok, [:logger, :kv]}
```

在实践中，我们的工具总是为我们启动应用程序，但如果您需要精细控制，可以使用API。

## 程序回调

每当我们调用`iex -S mix`时，`Mix`会自动通过调用`Application.start(:kv)`来启动我们的应用程序。但是我们可以定制应用程序启动时会发生什么吗？事实上，我们可以！为此，我们定义了一个应用程序回调。

第一步是告诉我们的应用程序定义（例如，我们的`.app`文件）哪个模块将实现应用程序回调。让我们通过打开`mix.exs`并将`def application`更改为以下内容来做到这一点：

```elixir
def application do
    [
        extra_applications: [:logger],
        mod: {KV, []}
    ]
end
```

`:mod`选项指定了“应用程序回调模块”，然后是应用程序启动时要传递的参数。应用程序回调模块可以是实现应用程序行为的任何模块。

要实现`Application`行为，我们必须`use Application`并定义一个`start/2`函数。`start/2`的目标是启动一个supervisor，然后该superviso将启动任何子服务或执行我们的应用程序可能需要的任何其他代码。让我们利用这个机会开始我们在本章前面实施的`KV.Supervisor`。

由于我们已经指定了`KV`作为模块回调，让我们更改`lib/kv.ex`中定义的KV模块以实现`start/2`函数：

```elixir
defmodule KV do
    use Application

    @impl true
    def start(_type, _args) do
        # Although we don't use the supervisor name below directly,
        # it can be useful when debugging or introspecting the system.
        KV.Supervisor.start_link(name: KV.Supervisor)
    end
end
```

>请注意，这样做，我们正在打破在`KV`中测试`hello`函数的模板测试案例。你可以简单地移除那个测试用例。

当我们`use Application`时，我们可能会定义几个功能，类似于我们使用`Supervisor`或`GenServer`时。这一次，我们只需要定义一个`start/2`函数。`Application`行为也有`stop/1`回调，但在实践中很少使用。您可以查看文档以获取更多信息。

既然您已经定义了一个应用程序回调来启动我们的Supervisor，我们预计一旦我们启动`iex-S mix`，`KV.Registry`进程就会启动并运行。让我们再试一次：

```elixir
KV.Registry.create(KV.Registry, "shopping")
:ok
KV.Registry.lookup(KV.Registry, "shopping")
{:ok, #PID<0.88.0>}
```

让我们总结一下正在发生的事情。每当我们调用`iex -S mix`时，它会自动通过调用`Application.start(:kv)`启动我们的应用程序，然后调用应用程序回调。应用程序回调的工作是启动监督树。现在，我们的主管只有一个子进程叫`KV.Registry`，以`KV.Registry`开头。我们的主管可以有其他子进程，其中一些子进程可以和自己的子进程一起成为自己的主管，从而形成所谓的监督树。

## 项目还是应用？

Mix区分项目和应用程序。根据我们`mix.exs`文件的内容，我们会说我们有一个定义`:kv`应用程序的`Mix`项目。正如我们将在后面的章节中看到的那样，有些项目没有定义任何应用程序。

当我们说“项目”时，你应该考虑`Mix`。`Mix`是管理你项目的工具。它知道如何编译您的项目、测试您的项目等。它还知道如何编译和启动与您的项目相关的应用程序。

当我们谈论应用程序时，我们谈论的是OTP。应用程序是运行时启动和停止的实体。您可以在应用程序模块的文档中了解有关应用程序的更多信息，以及它们与整个系统的启动和关闭的关系。