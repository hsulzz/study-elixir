# 监控树和应用

在上一章`GenServer`相关内容中，我们实现了`KV.Registry`来管理存储桶。在某些时候，监存储桶，可以让我们在`KV.Bucket`崩溃时采取行动。虽然变化相对较小，但它引入了一个`Elixir`开发人员经常问的问题：当失败时会发生什么?

在我们添加监控之前，如果存储桶崩溃，注册表将永远指向不再存在的存储桶。如果用户尝试读取或写入崩溃的桶，它将失败。任何尝试创建具有相同名称的新存储桶的尝试都会返回崩溃存储桶的`PID`。换句话说，那个桶的注册表条目将永远处于糟糕的状态。一旦我们添加了监控，注册表就会自动删除崩溃桶的条目。现在尝试查找崩溃的存储桶（正确）显示存储桶不存在，如果需要，系统用户可以成功创建一个新的存储桶。

在实践中，我们并不期望像桶一样工作的过程会失败。但是，如果它确实发生了，无论出于什么原因，我们可以放心，我们的系统将继续按预期工作。

如果您之前有编程经验，您可能会想：“我们可以保证桶一开始就不会崩溃吗？”。正如我们将看到的，Elixir开发人员倾向于将这些做法称为“防御性编程”。这是因为生产系统有很多不同的原因导致出错。磁盘可能会出现故障，内存可能会损坏，出现错误，网络可能会停止工作一秒钟，等等。如果我们编写试图保护或规避所有这些错误的软件，我们将花更多时间处理故障，而不是编写自己的软件！

因此，Elixir开发人员更喜欢“让它崩溃”或“快速失败”。我们从故障中恢复的最常见方法之一是重新启动系统崩溃的任何部分。

例如，想象一下您的计算机、路由器、打印机或任何设备无法正常工作。你多久重新启动一次来修复它？一旦我们重新启动设备，我们将设备重置为初始状态，该状态已过良好测试，并保证工作。在Elixir中，我们对软件应用了同样的方法：每当进程崩溃时，我们都会启动一个新进程来执行与崩溃进程相同的工作。

在Elixir中，这是由Supervisor完成的。Supervisor是一个监督其他进程并在它们崩溃时重新启动的进程。为做到这一点，Supervisor管理任何受监督进程的整个生命周期，包括启动和关闭。

在本章中，我们将学习如何通过监督`KV.Registry`进程，将这些概念付诸实践。毕竟，如果注册表出了问题，整个注册表就会丢失，再也找不到桶了！为了解决这个问题，我们将定义一个`KV.Supervisor`模块，以保证我们的`KV.Registry`在任何给定时刻都能启动并运行。

在本章的结尾，我们还将讨论应用程序。正如我们将看到的，Mix一直在将我们所有的代码打包到一个应用程序中，我们将学习如何自定义我们的应用程序，以确保我们的Supervisor和注册表在系统启动时都能启动并运行。


## Our first Supervisor

Supervisor是监督其他进程的进程，我们称之为子进程。监督一个过程的行为包括三个不同的责任，第一个是启动子进程。一旦子进程运行，Supervisor可能会重新启动子进程，要么是因为它异常终止，要么是因为满足某个条件。例如，如果任何子进程死亡，Supervisor可以重新启动所有子进程。最后，当系统关闭时，Supervisor还负责关闭子进程。有关更深入的讨论，请参阅Supervisor模块。

创建Supervisor与创建GenServer没有太大区别。我们将在`lib/supervisor.ex`文件中定义一个名为`KV.Supervisor`的模块，该模块将使用Supervisor行为：

到目前为止，我们的Supervisor只有一个子进程：`KV.Registry`。在我们定义一个子列表后，我们调用`Supervisor.init/2`，传递子进程和监督策略。

监督策略决定了当其中一个子进程崩溃时会发生什么。`:one_for_one`意味着如果一个子进程死亡，它将是唯一一个重新启动的子进程。我们现在就只有一个子进程，这就够了。Supervisor行为支持几种策略，我们将在本章中讨论。

一旦Supervisor启动，它将遍历子项列表，并将在每个模块上调用`child_spec/1`函数。

`child_spec/1`函数返回子进程spec，该spec描述了如何启动进程，该进程是worker还是Supervisor，该进程是临时的、流动的还是永久的等等。当我们使用`agent`、`GenServer`、使用`Supervisor`等时，`child_spec/1`函数会自动定义。让我们在`iex-S mix`的终端中尝试一下：

```elixir
iex(1)> KV.Registry.child_spec([])
%{
  id: KV.Registry,
  start: {KV.Registry, :start_link,
   [[]]}
}
```

在推进本指南时，我们将了解这些细节。如果您更愿意提前查看，请查看`Supervisor`文档。

在`Supervisor`获取所有子进程spec后，它将按照定义的顺序逐一启动其子进程，使用子进程spec中`:start`键的信息。对于我们当前的规范，它将调用`KV.Registry.start_link([])`。

```elixir
iex(2)> {:ok, sup} = KV.Supervisor.start_link([])
{:ok, #PID<0.150.0>}
iex(3)> Supervisor.which_children(sup)
[
  {KV.Registry, #PID<0.151.0>,
   :worker, [KV.Registry]}
]
```

到目前为止，我们已经启动了Supervisor，并列出了其子进程。一旦Supervisor启动，他会启动所有子进程。

如果我们故意破坏Supervisor启动的注册表，会发生什么？让我们通过`call`发送错误输入：

```elixir
iex(4)> [{_, registry, _, _}] = Supervisor.which_children(sup)
[
  {KV.Registry, #PID<0.151.0>,
   :worker, [KV.Registry]}
]
iex(5)> GenServer.call(registry, :bad_input)

14:48:01.832 [error] GenServer #PID<0.151.0> terminating
** (FunctionClauseError) no function clause matching in KV.Registry.handle_call/3
    (kv 0.1.0) lib/registry.ex:39: KV.Registry.handle_call(:bad_input, {#PID<0.149.0>, [:alias | #Reference<0.0.19075.2674133225.1061224453.159218>]}, {%{}, %{}})
    (stdlib 6.0.1) gen_server.erl:2209: :gen_server.try_handle_call/4
    (stdlib 6.0.1) gen_server.erl:2238: :gen_server.handle_msg/6
    (stdlib 6.0.1) proc_lib.erl:329: :proc_lib.init_p_do_apply/3
Last message (from #PID<0.149.0>): :bad_input
State: {%{}, %{}}
Client #PID<0.149.0> is alive

    (stdlib 6.0.1) gen.erl:260: :gen.do_call/4
    (elixir 1.17.2) lib/gen_server.ex:1125: GenServer.call/3
    (elixir 1.17.2) src/elixir.erl:386: :elixir.eval_external_handler/3
    (stdlib 6.0.1) erl_eval.erl:904: :erl_eval.do_apply/7
    (elixir 1.17.2) src/elixir.erl:364: :elixir.eval_forms/4
    (elixir 1.17.2) lib/module/parallel_checker.ex:112: Module.ParallelChecker.verify/1
    (iex 1.17.2) lib/iex/evaluator.ex:332: IEx.Evaluator.eval_and_inspect/3
    (iex 1.17.2) lib/iex/evaluator.ex:306: IEx.Evaluator.eval_and_inspect_parsed/3
** (exit) exited in: GenServer.call(#PID<0.151.0>, :bad_input, 5000)
    ** (EXIT) an exception was raised:
        ** (FunctionClauseError) no function clause matching in KV.Registry.handle_call/3
            (kv 0.1.0) lib/registry.ex:39: KV.Registry.handle_call(:bad_input, {#PID<0.149.0>, [:alias | #Reference<0.0.19075.2674133225.1061224453.159218>]}, {%{}, %{}})
            (stdlib 6.0.1) gen_server.erl:2209: :gen_server.try_handle_call/4
            (stdlib 6.0.1) gen_server.erl:2238: :gen_server.handle_msg/6
            (stdlib 6.0.1) proc_lib.erl:329: :proc_lib.init_p_do_apply/3
    (elixir 1.17.2) lib/gen_server.ex:1128: GenServer.call/3
    iex:5: (file)
iex(5)> Supervisor.which_children(sup)
[
  {KV.Registry, #PID<0.152.0>,
   :worker, [KV.Registry]}
]
```

请注意，Supervisor如何自动启动一个新的注册表，使用新的PID来代替因输入错误导致崩溃的旧注册表。

在前几章中，我们总是直接启动进程。例如，调用`KV.Registry.start_link([])`，它将返回`{:ok, pid}`，这将允许我们通过`pid`与其交互。既然进程是由Supervisor启动的，我们必须直接询问Supervisor谁是其子进程，并从返回的子列表中获取PID。在实践中，每次都这样做会非常昂贵。为了解决这个问题，我们通常会为进程命名，允许它们从代码中的任何地方在一台机器中唯一识别。

## 给进程命名

