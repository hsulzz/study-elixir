# 使用`GenServer`进行Client-server通信

在2.使用agents进行状态管理中，我们用agents实现了buckets，因为bucket是进程，每个bucket都有一个进程标志符（PID），之前我们介绍可以给进程注册一个atom的名字.

```elixir
iex(1)> Agent.start_link(fn -> %{} end, name: :shopping)
{:ok, #PID<0.105.0>}
iex(2)> Agent.update(:shopping, &Map.put(&1,"milk",3))
:ok
iex(3)> Agent.get(:shopping,&Map.get(&1,"milk"))
3
```

然而，用原子命名动态进程是一个糟糕的主意！如果我们使用原子，我们需要将存储桶名称（通常从外部客户端接收）转换为原子，我们**永远不应该将用户输入转换为原子**。这是因为原子不会被GC回收。原子一旦被创造，就永远不会被回收。从用户输入中生成原子意味着用户可以注入足够多的不同名称来耗尽我们的系统内存。

实际上，在内存耗尽之前，您更有可能达到Erlang VM的最大原子数量限制，无论如何，这都会使您的系统停机。

我们将创建自己的进程注册表，将存储桶名称与存储桶进程相关联，而不是滥用内置名称功能。注册表需要保证始终是最新的，例如，如果其中一个存储桶进程因错误而崩溃，注册表必须注意到此更改，并避免提供陈旧的条目，在Elixir中，注册表需要监控每个桶，由于我们的注册表需要能够接收和处理来自系统的临时消息，因此agent API是不够的。

我们将使用`GenServer`创建一个可以监控存储桶进程的注册表进程，`GenServer`为在`Elixir`和`OTP`中构建服务器提供工业强度功能。

## GenServer回调

`GenServer`是在特定条件下调用一组有限函数的进程。当我们使用`Agent`时，我们会将客户端代码和服务器代码并排保存，如下：

```elixir
def put(bucket, key, value) do
    # Here is the client code
    Agent.update(bucket, fn state -> 
      # Here is the server code
      Map.put(state, key, value)
    end
    )
    # Back to the client code
end
```

在上述代码中，我们有一个进程，我们称之为“客户端”，向代理“服务器”发送请求。请求包含一个匿名函数，该函数必须由服务器执行。

在`GenServer`中，上面的代码将是两个独立的函数，大致如下：

```elixir
def put(buckt, key, value) do
    # Send the server  a :put "instruction"
    GenServer.call(bucket, {:put, key, value})
end

# 服务端回调

def handle_call({:put, key, value}, _from, state) do
    {:reply, :ok, Map.put(state, key, value)}
end
```

GenServer代码中还有相当多的仪式，但正如我们将看到的，它也带来了一些好处。

目前，我们只会为我们的存储桶注册逻辑编写服务器回调，而不提供适当的API，我们稍后会这样做。

创建一个`lib/kv/registry.ex`文件，内容如下：

```elixir
defmodule KV.Registry do
  use GenServer

  ## Missing Client API  - will add this later

  ## Defining  GenServer Callbacks

  @impl true
  def init(:ok) do
    {:ok, %{}}
  end

  @impl true
  def handle_call({:lookup, name}, _from, names) do
    {:reply, Map.fetch(names, name), names}
  end

  @impl true
  def handle_cast({:create, name}, names) do
    if Map.has_key?(names, name) do
      {:noreply,names}
    else
      {:ok, bucket} =KV.Bucket.start_link([])
      {:noreply, Map.put(names,name, bucket)}
    end
  end
end
```

您可以向`GenServer`发送两种类型的请求：`call`和`cast`。`call`是同步的，服务器必须向此类请求返回响应。当服务器计算响应时，客户端等待。`cast`是异步的：服务器不会发送响应，因此客户端不会等待响应。这两个请求都是发送到服务器的消息，将按顺序处理。在上述实现中，我们在`:create`消息上进行模式匹配，将作为`cast`处理，在`:lookup`消息上，将作为`call`处理。

为了调用上述回调，我们需要通过相应的`GenServer`函数。让我们启动一个注册表，创建一个有名称的桶，然后查找它：

```elixir
iex(1)> {:ok, registry} = GenServer.start_link(KV.Registry, :ok)
{:ok, #PID<0.149.0>}
iex(2)> GenServer.cast(registry, {:create, "shopping"})
:ok
iex(3)> {:ok, bk} = GenServer.call(registry, {:lookup, "shopping"})
{:ok, #PID<0.150.0>}
```

我们的`KV.Registry`进程按照这个顺序收到了带有`{:create, "shopping"}`的`cast`和带有`{:lookup, "shopping"}`的调用。一旦消息发送到注册表，`GenServer.cast`将立即返回。另一方面，`GenServer.call`是我们等待响应的地方，由上述`KV.Registry.handle_cal`l回调提供。您可能还注意到，我们在每个回调前都添加了`@impl true`。他告诉编译器，随后定义的函数是一个回调的实现，。如果我们碰巧在函数名称或参数数量上犯了错误，比如我们定义了`handle_call/2`，编译器会警告我们没有任何`handle_call/2`需要定义，并将向我们提供`GenServer`模块已知回调的完整列表。

这一切都很好，但我们仍然想为我们的用户提供一个API，允许我们隐藏我们的实现细节。

## 客户端API

`GenServer`分为两部分：客户端API和服务器回调。您可以将两个部分合并到一个模块中，也可以将它们分成客户端模块和服务器模块。客户端是调用客户端函数的任何进程。服务器始终是我们将显式作为参数传递给客户端API的进程标识符或进程名称。在这里，我们将为服务器回调和客户端API使用单个模块。

在`lib/kv/registry.ex`上编辑文件，为客户端API填空：

```elixir

  ## Client API

  @doc """
  Starts the registry
  """
  def start_link(opts) do
    GenServer.start_link(__MODULE__, :ok, opts)
  end

  @doc """
  Looks up the bucket pid for `name` stored in `server`.

  Returns `{:ok, pid}` id the bucket exists,  `:error` otherwise.
  """
  def lookup(server, name) do
    GenServer.call(server, {:lookup, name})
  end

  @doc """
  Ensures there is a bucket associated with the given `name` in `server`.
  """
  def create(server, name) do
    GenServer.cast(server, {:create, name})
  end

```

第一个函数是`start_link/1`，它启动一个新的`GenServer`，传递一个选项列表。`start_link/1`调用`GenServer.start_link/3`，它需要三个参数：

   1. 实现了服务器回调的模块，在这种情况下`__MODULE__`（指当前模块）
   2. 初始化参数，在这种情况下是原子`:ok`
   3. 可用于指定服务器名称等内容的选项列表。目前，我们将在`start_link/1`上收到的选项列表转发到`GenServer.start_link/3`

接下来的两个函数，`lookup/2`和`create/2`，负责将这些请求发送到服务器,在这种情况下，我们分别使用了`{:lookup, name}`和`{:create, name}`。请求通常被指定为元组，像这样，以便在第一个参数插槽中提供多个“参数”,通常将请求的操作指定为元组的第一个元素，并在其余元素中指定该操作的参数。请注意，请求必须与`handle_call/3`或`handle_cast/2`的第一个参数相匹配。

这就是客户端API的。在服务器端，我们可以实现各种回调，以保证服务器初始化、终止和处理请求。这些回调是可选的，目前，我们只实施了我们关心的回调。让我们总结一下。

第一个是`init/1`回调，它接收给`GenServer.start_link/3`的第二个参数，并返回`{:ok, state}`，其中`state`是一个map。。我们已经可以注意到`GenServer` API如何使客户端/服务器分离更加明显。`start_link/3`发生在客户端中，而`init/1`是在服务器上运行的相应回调。

对于`call/2`请求，我们实现了一个`handle_call/3`回调，该回调接收请求、我们接收请求的进程`（_from）`和当前服务器状态`（names）`。`handle_call/3`回调返回一个格式为`{:reply, reply, new_state}`的元组。元组的第一个元素`:reply`表示服务器应该向客户端发送回复。第二个元素，`reply`，是将发送给客户端的内容，而第三个，`new_state`是新的服务器状态。

对于`cast/2`请求，我们实现了接收请求和当前服务器状态（`names`）的`handle_cast/2`回调。`handle_cast/2`回调返回格式为`{:noreply, new_state}`的元组。请注意，在真实应用程序中，我们可能会使用同步调用而不是异步抛出来实现：创建回调。我们这样做是为了说明如何实现`cast`回调。

还有其他元组格式，`handle_call/3`和`handle_cast/2`回调都可以返回。我们可以实现其他回调，`terminate/2`和`code_change/3`。欢迎您探索完整的`GenServer`文档，以了解有关这些文档的更多信息。

## 测试GenServer

测试`GenServer`与测试Agent没有太大区别。我们将在`setup`回调上生成服务器，并在整个测试过程中使用它。在`test/registry_test.exs`中创建一个包含以下内容的文件：

```elixir
defmodule KV.RegistryTest do
  use ExUnit.Case, async: true

  setup do
    registry = start_supervised!(KV.Registry)
    %{registry: registry}
  end

  test "spawns buckets", %{registry: registry} do
    assert KV.Registry.lookup(registry, "shopping") == :error

    KV.Registry.create(registry, "shopping")
    assert {:ok, bucket} = KV.Registry.lookup(registry, "shopping")

    KV.Bucket.put(bucket, "milk", 1)
    assert KV.Bucket.get(bucket, "milk") == 1
  end
end
```

我们的测试用例首先断言我们的`registy`中没有`shopping bucket`，创建一个命名的`bucket`，查看它，并断言它作为`bucket`运行。

我们为`KV.Registry`编写的`setup`块和我们为`KV.Bucket`编写的`setup`块之间有一个重要的区别。我们没有通过调用`KV.Registry.start_link/1`手动启动`registry`，而是调`用ExUnit.Callbacks.start_supervised!/2`函数，将`KV.Registry`模块作为参数传递。

`start_supervised!`函数通过使用`ExUnit.Case`注入到测试模块中。它通过调用其`start_link/1`函数来启动`KV.Registry`进程,使`用start_supervised!`的优势`ExUnit`将保证在下一个测试开始前关闭`registry`进程。
换句话说，它有助于保证一个测试的状态不会干扰下一个测试，以防它们依赖于共享资源。

在测试期间启动进程时，我们应该始终使用`start_supervised!`。我们建议您将`bucket_test.exs`中的`setup`块也更改为`start_supervised！`。

## 监控需求

到目前为止，我们所做的一切都可以用`agent`实现。在本节中，我们将看到使用`GenServer`可以实现,`agent`无法实现的。

让我们从一个测试开始，该测试描述了如果存储桶停止或崩溃，我们期待的存储痛行为：

```elixir
test "removes buckets on exit", %{registry: registry} do
  KV.Registry.create(registry, "shopping")
  {:ok, bucket} = KV.Registry.lookup(registry, "shopping")
  Agent.stop(bucket)
  assert KV.Registry.lookup(registry, "shopping") == :error
end
```

上述测试将在最后一次断言中失败，因为即使我们停止存储桶进程后，存储桶`shopping`仍保留在`registry`中。

为了修复这个bug，我们需要`registry`来监控它生成的每个`bucket`。一旦我们设置了监视器，每次退出存储桶进程时，注册表都会收到通知，允许我们清理注册表。

让我们先用`iex-S mix`启动一个新的控制台来玩监视器：

```elixir
iex(1)> {:ok, pid} = KV.Bucket.start_link([])
{:ok, #PID<0.127.0>}
iex(2)> Process.monitor(pid)
#Reference<0.3017590657.1047789571.125463>
iex(3)> Agent.stop(pid)
:ok
iex(4)> flush()
{:DOWN, #Reference<0.3017590657.1047789571.125463>, :process, #PID<0.127.0>,
 :normal}
:ok
```

注意`Process.monitor(pid)`返回一个唯一的引用，允许我们将即将到来的消息与该监控引用进行匹配。在我们停止`agent`后，我们可以`flush/0`所有消息，并注意到有一条`:DOWN`消息，并带着由`monitor`返回的唯一的引用，通知`bucket`进程终止，原因`:normal`。

让我们重新实现服务端回调来修复错误，并通过测试。首先，我们将`GenServer`状态修改为两个字典：一个包含`name->pid`，另一个包含`ref->name`。然后，我们需要监控`handle_cast/2`上的存储桶，并实现`handle_info/2`回调来处理监控消息。完整的服务器回调实现如下所示:

请注意，我们能够在不更改任何客户端API的情况下大幅更改服务器实现。这是明确分离服务器和客户端的好处之一。

最后，与其他回调不同，我们为`handle_info/2`定义了一个“catch-all”子句，该子句丢弃并记录任何未知消息。为了了解原因，让我们进入下一节。

## `call`,`cast`还是`info`?

到目前为止，我们已经使用了：`handle_call/3`、`handle_cast/2`和`handle_info/2`三个回调。以下是我们在决定何时使用每个时应该考虑的内容：

- `handle_call/3`必须用于同步请求。这应该是默认选项，因为等待服务器回复是一个有用的背压机制。

- 当您不关心回复时，`handle_cast/2`必须用于异步请求。`cast`并不能保证服务器已收到消息，因此，应少使用。例如，我们在本章中定义的`create/2`函数应该的。使用`call/2`。我们使用`cast/2`仅出于教学目的。

- `handle_info/2`必须用于服务器可能收到的所有其他非通过`GenServer.call/2`或`GenServer.cast/2`发送的消息，包括使用`send/2`发送的常规消息。监控`:DOWN`消息就是一个例子。

由于任何消息，包括通过`send/2`发送的消息，都会转到`handle_info/2`，因此意外消息可能会到达服务器。因此，如果我们不定义`catch-all`子句，这些消息可能会导致我们的注册表崩溃，因为没有子句会匹配。不过，我们不需要担心`handle_call/3`和`handle_cast/2`的此类情况。Calls和Casts只能通过`GenServer API`完成，因此未知消息很可能是开发人员的错误。

为了帮助开发人员记住`call`、`cast`和`info`之间的差异、支持的返回值等，我们有一个很小的[GenServer小抄](https://elixir-lang.org/downloads/cheatsheets/gen-server.pdf)。

## Monitors or links?

我们之前在Process章节中了解过links。现在，随着学完registry，您可能想知道：我们什么时候应该使用monitor，什么时候应该使用links？

链接是双向的。如果您链接两个进程，其中一个进程崩溃，另一端也会崩溃（除非是捕获出口），监视器是单向的：只有监控过程才会收到有关被监控过程的通知。换句话说：当您想要关联的进程也崩溃时，请使用`links`，当您只想收到崩溃，推出的消息时，请使用`monitors`。

回到我们的`handle_cast/2`实现，您可以看到注册表既链接又监控存储桶。

```elixir
{:ok, bucket} = KV.Bucket.start_link([])
ref = Process.monitor(bucket)
```

这是一个坏主意，因为我们不希望存储桶崩溃时注册表崩溃。正确的修复方法是实际上不将存储桶链接到注册表。相反，我们将将每个存储桶链接到一种名为`Supervisors`的特殊类型进程，该进程专门用于处理故障和崩溃。我们将在下一章中了解更多关于它们的信息。