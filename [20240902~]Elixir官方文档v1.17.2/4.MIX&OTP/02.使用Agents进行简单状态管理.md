# 使用Agents进行简单的状态管理

在本章中，我们将学习如何在多个实体之间保持和共享状态。如果你以前有编程经验，你可能会想到全局共享变量，但我们在这里将学习的模型截然不同。

## 可变的状态

`Elixir`是一种不可变的语言，默认情况下什么都不共享。如果我们想共享可以从多个地方读取和修改的信息，我们在`Elixir`中有两个主要选项：

- 使用进程和消息传递
- ETS(Erlang Term Storage)

我们在入门指南中介绍了流程,我们很少自己手搓，相反，我们使用`Elixir`和`OTP`中可用的抽象：

- `Agent` state的简单包装器
- `GenServer` 封装状态、提供同步和非同步调用、支持代码重新加载等的“通用服务器”（进程）。
- `Task` 非同步计算单元，允许生成进程并在稍后检索其结果。

我们将探索这些抽象。请记住，它们都是在进程之上实现的，使用虚拟机提供的基本功能，如`send/2`、`receive/1`、`spawn/1`和`Process.link/1`。

接下来我么用agent创建名为`KV.Bucket`的模块，负责存储键值对，让他们可以被其他进程读取和修改。

## Agent 101

`Agent`是state的简单包装，如果你只是想要一个进程保持state，agent非常适合

```shell
iex -S mix

iex(1)> {:ok, agent} = Agent.start_link(fn -> [] end)
{:ok, #PID<0.127.0>}
iex(2)> Agent.update(agent, fn list -> ["eggs" | list] end)
:ok
iex(3)> Agent.get(agent, fn list -> list end)
["eggs"]
iex(4)> Agent.stop(agent)
:ok
```

 我们启动了一个初始状态为空列表的agent。我们更新了agent的状态，将我们的新项目添加到列表的首位。`Agent.update/3`的第二个参数是一个函数，它将agent的当前状态作为输入，并返回其所需的新状态。最后，我们检索了整个列表。`Agent.get/3`的第二个参数是一个函数，它将状态作为输入，并返回`Agent.get/3`本身将返回的值，我们可以调用`Agent.stop/3`来终止代理过程。

`Agent.update/3`函数接受任何接收一个参数并返回值的函数作为第二个参数：

```shell
iex(9)> {:ok, agent} = Agent.start_link(fn -> [] end)
{:ok, #PID<0.131.0>}
iex(10)> Agent.update(agent, fn _list -> 123 end)
:ok
iex(11)> Agent.update(agent, fn content -> %{a: content} end)
:ok
iex(12)> Agent.update(agent, fn content -> [12 | [content]] end)
:ok
iex(13)> Agent.update(agent, fn list -> [:nop | list] end)
:ok
iex(14)> Agent.get(agent, fn content -> content end)
[:nop, 12, %{a: 123}]
```

如您所见，我们可以以任何我们想要的方式修改agent状态。因此，我们很可能不想在我们的代码中许多不同的地方访问agent API。相反，我们希望将所有与代理相关的功能封装在一个模块中，我们将称之为`KV.Bucket`。在我们实现它之前，让我们编写一些测试，这些测试将概述我们模块公开的API。

```elixir
defmodule KV.BucketTest do
  use ExUnit.Case, async: true

  test "stores values by key" do
    {:ok, bucket} =KV.Bucket.start([])
    assert KV.Bucket.get(bucket, "milk") == nil

    KV.Bucket.put(bucket, "milk", 3)
    assert KV.Bucket.get(bucket, "milk") == 3
  end
end
```

使用`ExUnit.Case`负责设置我们的模块进行测试，并导入许多与测试相关的功能，如`test/2`宏

我们的第一次测试通过调用`start_link/1`并传递一个空的选项列表来启动一个新的`KV.Bucket`。然后我们对它执行一些`get/2`和`put/3`操作，断言结果。

另请注意`async：`传递给`ExUnit.Case`的`true`选项。此选项通过在我们的机器中使用多个核心，使测试用例与其他：异步测试用例并行运行。这对于加快我们的测试套件的速度非常有用。然而，只有当测试用例不依赖或更改任何全局值时，才必须设置`：async`。例如，如果测试需要写入文件系统或访问数据库，请保持同步（省略`：async`选项），以避免测试之间的竞争条件。

无论是否异步，我们的新测试显然应该失败，因为正在测试的模块中没有实现任何功能：

```shell
** (UndefinedFunctionError) function KV.Bucket.start_link/1 is undefined (module KV.Bucket is not available)
```

为了修复失败的测试，让我们在`lib/kv/bucket.ex`上创建一个包含以下内容的文件。在查看下面的实现之前，请随时尝试使用代理自己实现`KV.Bucket`模块。

```elixir
defmodule KV.Bucket do
  use Agent

  @doc """
  Starts a new bucket
  """
  def start_link(_opts) do
    Agent.start(fn -> %{} end)
  end

  @doc """
  Gets a value from the `bucket` by `key`
  """
  def get(bucket, key) do
    Agent.get(bucket, &Map.get(&1,key))
  end

  @doc """
  Put the `value` for the given `key` in the `bucket`
  """
  def put(bucket, key, value) do
    Agent.update(bucket, &Map.put(&1, key, value))
  end
end
```

我们实现的第一步是调用`use Agent`。我们将学习的大多数功能，如`GenServer`和`Supervisor`，都遵循这种模式。对于所有这些，调用`use`会生成一个具有默认配置的`child_spec/1`函数，当我们在第4章开始监督进程时，这将很方便。

然后我们定义了一个`start_link/1`函数，它将有效地启动agent。定义始终接受选项列表的`start_link/1`函数是一种惯例。然后我们继续调用`Agent.start_link/1`，它接收一个匿名函数，该函数返回代的初始状态。

我们在agent内保存了一张map，以存储我们的key和value。在map上获取和放置值是使用“入门指南”中介绍的agent API和捕获运算符`&`完成的。当调用`agent.get/2`和`agent.update/2`时，agent通过`&1`参数将其状态传递给匿名函数。

既然`KV.Bucket`模块已经定义，我们的测试应该会通过！您可以通过运行：`mix test`来自己尝试。

## 使用ExUnit回调设置测试

在继续向`KV.Bucket`添加更多功能之前，让我们来谈谈`ExUnit`回调。正如你所期望的那样，所有`KV.Bucket`测试都需要bucket agent才能启动和运行。幸运的是，`ExUnit`支持回调，允许我们跳过这种重复性任务。

```elixir
defmodule KV.BucketTest do
  use ExUnit.Case, async: true
  alias KV.Bucket

  setup do
    {:ok, bucket} = KV.Bucket.start_link([])
    %{bucket: bucket}
  end

  test "stores values by key", %{bucket: bucket} do
    assert Bucket.get(bucket, "milk") == nil
  
    Bucket.put(bucket, "milk", 3)
    assert Bucket.get(bucket, "milk") == 3
  end
end
```

我们首先在`setup/1`宏的帮助下定义了设置回调。`setup/1`宏定义了一个回调，该回调在每次测试前运行，**跟测试在同一个进程**。

需要一个机制将`bucket`PID 从回调传递到test，我们使用了test context，当在`setup`回调返回`%{bucket: bukcet}`，`ExUnit`会将这个`map`合并到 test context，因为test context本身也是一个map，因此可以使用类型匹配取出他

```elixir
test "stores values by key", %{bucket: bucket} do
  # `bucket` 现在就从setup语句块
end
```

## 其他agent actions

除了获取和更新agent state ，agents还允许使用`Agent.get_and_update/2`在获取值的同时更新值，下面实现一个`KV.Bucket.delete/2`函数用于从桶中删除一个键，返回他的当前值

```elixir
@doc """

"""
def delete(bucket, key) do
  Agent.get_and_upate(bucket, &Map.pop(&1, key))
end
``` 

## agent中的Client/Server  

在我们进入下一章之前，让我们来讨论一下代理中的客户端/服务器。让我们扩展我们刚刚实现的`delete/2`函数：

```elixir
def delete(bucket, key) do
  Agent.get_and_update(bucket, fn dict ->
    Map.pop(dict, key)
  end)
end
```

在`delete/2`函数中，我们传递给agent的函数在agent的进程中，在这种情况下，由于代理进程是接收和响应我们消息的进程，我们称代理进程是服务器。函数以外的一切都在客户端中发生。

这种区别很重要。如果有昂贵的操作需要完成，您必须考虑在客户端或服务器上执行这些操作是否更好。

```elixir

def delete(bucket, key) do
  Process.sleep(1000) # puts client to sleep
  Agent.get_and_update(bucket, fn dict -> 
    Process.sleep(1000) # puts server to sleep
    Map.pop(dict, key)
  end)
end
```

当在服务器上执行长操作时，对该特定服务器的所有其他请求将等待操作完成，这可能会导致一些客户端超时。