# [Dependencies and unbrella projects](https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/pages/mix-and-otp/dependencies-and-umbrella-projects.md#L1)

在本章中，我们将讨论如何在Mix中管理依赖项。

我们的kv应用程序已经完成，所以是时候实现处理我们在第一章中定义的请求的服务器了：

```text
CREATE shopping
OK

PUT shopping milk 1
OK

PUT shopping eggs 3
OK

GET shopping milk
1
OK

DELETE shopping eggs
OK
```

然而，我们不会在kv应用程序中添加更多代码，而是将TCP服务器构建为另一个应用程序，该应用程序是kv应用程序的客户端。由于整个运行时间和Elixir生态系统都面向应用程序，因此将我们的项目分解为一起工作的更小应用程序是有意义的，而不是构建一个大型的单体应用程序。

在创建新应用程序之前，我们必须讨论Mix如何处理依赖项。在实践中，我们通常处理两种依赖关系：内部依赖关系和外部依赖关系。mix支持两者。

## 外部依赖

外部依赖项是与您的业务领域无关的。例如，如果您的分布式KV应用程序需要HTTP API，您可以使用[`Plug`项目](https://github.com/elixir-lang/plug)作为外部依赖项。

安装外部依赖项很简单。最常见的是，我们使用`Hex软件包管理器`，通过在`mix.exs`文件中列出`deps`函数中的依赖项：

```elixir
def deps do
    [{:plug}, "~>1.0"]
end
```

此依赖项是指已推送到`Hex`的`1.x.x`版本系列中的最新版本`Plug`.这由版本号前面的`~>`表示。或有关指定版本要求的更多信息，请参阅[版本模块](https://hexdocs.pm/elixir/Version.html)的文档。

通常，稳定版本被推送到`Hex`。如果您想依赖仍在开发的外部依赖项，`Mix`也可以管理`Git`依赖项：

```elixir
def deps do
  [{:plug, git: "https://github.com/elixir-lang/plug.git"}]
end
```

您会注意到，当您向项目添加依赖项时，`Mix`会生成一个`mix.lock`文件，保证可重复的构建.锁定文件必须加入到您的版本控制系统，以保证每个使用该项目的人都将使用与您相同的依赖版本。

Mix提供了许多处理依赖项的任务，可以在`mix help`中看到：

```shell
mix help
mix deps              # Lists dependencies and their status
mix deps.clean        # Deletes the given dependencies' files
mix deps.compile      # Compiles dependencies
mix deps.get          # Gets all out of date dependencies
mix deps.tree         # Prints the dependency tree
mix deps.unlock       # Unlocks the given dependencies
mix deps.update       # Updates the given dependencies

```

最常见的任务是`mix deps.get`和`mix deps.update`。一旦获取，依赖项将自动为您编译。您可以通过输入`mix help deps`和`Mix.Tasks.Deps`[模块的文档](https://hexdocs.pm/mix/Mix.Tasks.Deps.html)来阅读有关deps的更多信息。

## 内部依赖

内部依赖关系是特定于您的项目的依赖关系。在你的项目/公司/组织范围之外，它们通常没有意义。大多数时候，无论是出于技术、经济还是商业原因，您都希望将其保密。

如果您有内部依赖项，`Mix`支持两种方法来处理它们：Git存储库或伞式项目。

例如，如果您将kv项目推送到Git存储库，您需要在deps代码中列出它才能使用它：

```elixir
def deps do
  [{:kv, git: "https://github.com/YOUR_ACCOUNT/kv.git"}]
end
```

不过，如果存储库是私有的，您可能需要指定私有URL `git@github.com:YOUR_ACCOUNT/kv.git`。无论如何，只要您有适当的凭据，Mix就可以为您获取它。

在Elixir中，使用Git存储库进行内部依赖有些不鼓励。请记住，运行时和Elixir生态系统已经提供了应用程序的概念。因此，我们希望您经常将代码分解为可以逻辑组织的应用程序，即使在单个项目中也是如此。

然而，如果您将每个应用程序作为单独的项目推送到Git存储库，您的项目可能会变得非常难以维护，因为您将花很多时间管理这些Git存储库，而不是编写代码。

出于这个原因，Mix支持“伞式项目”。伞式项目用于构建在单个存储库中一起运行的应用程序。这正是我们将在下一节中探索的风格。

让我们创建一个新的Mix项目。我们将创造性地将其命名为`kv_umbrella`，这个新项目将同时拥有现有的`kv`应用程序和新的`kv_server`应用程序。目录结构如下：

```markdown
+ kv_umbrella
  + apps
    + kv
    + kv_server
```

这种方法的有趣之所是，Mix在处理此类项目时有很多便利，例如能够通过单个命令编译和测试应用程序中的所有应用程序。然而，尽管它们都在应用程序中一起列出，但它们仍然相互分离，因此如果您愿意，您可以单独构建、测试和部署每个应用程序。

## Umbrealla projects

让我们使用`mix new`开始一个新项目。这个新项目将命名为`kv_umbrella`，在创建它时，我们需要通`过--umbrella`选项。不要在现有的kv项目中创建这个新项目！

```shell
› mix new kv_umbrella --umbrella
* creating README.md
* creating .formatter.exs
* creating .gitignore
* creating mix.exs
* creating apps
* creating config
* creating config/config.exs
```

从打印的信息中，我们可以看到生成的文件要少得多。生成的`mix.exs`文件也不同。让我们来看看（注释已被删除）：

```elixir
defmodule KvUmbrella.MixProject do
  use Mix.Project

  def project do
    [
      apps_path: "apps",
      start_permanent: Mix.env() == :prod,
      deps: deps()
    ]
  end

  defp deps do
    []
  end
end
```

这个项目与前一个项目的不同之處在于项目定义中的`apps_path:"apps"`条目。这意味着这个项目将作为一个伞式项目。此类项目没有源文件或测试，尽管它们可以有自己的依赖项。每个子应用程序必须在应用程序目录中定义。

让我们进入应用程序目录，然后开始构建`kv_server`。这一次，我们将传递`--sup`标志，这将告诉Mix自动为我们生成一个监督树，而不是像前几章那样手动构建一个：

```shell
cd kv_umbrella/apps
mix new kv_server --module KVServer --sup
```

生成的文件与我们首次为kv生成的文件相似，但有一些不同。让我们打开`mix.exs`：

```elixir
defmodule KVServer.MixProject do
  use Mix.Project

  def project do
    [
      app: :kv_server,
      version: "0.1.0",
      build_path: "../../_build",
      config_path: "../../config/config.exs",
      deps_path: "../../deps",
      lockfile: "../../mix.lock",
      elixir: "~> 1.14",
      start_permanent: Mix.env() == :prod,
      deps: deps()
    ]
  end

  # Run "mix help compile.app" to learn about applications
  def application do
    [
      extra_applications: [:logger],
      mod: {KVServer.Application, []}
    ]
  end

  # Run "mix help deps" to learn about dependencies
  defp deps do
    [
      # {:dep_from_hexpm, "~> 0.3.0"},
      # {:dep_from_git, git: "https://github.com/elixir-lang/my_dep.git", tag: "0.1.0"},
      # {:sibling_app_in_umbrella, in_umbrella: true},
    ]
  end
end
```

首先，由于我们`在kv_umbrella/apps`中生成了这个项目，`Mix`自动检测了伞结构，并在项目定义中添加了四行：

```elixir
build_path: "../../_build",
config_path: "../../config/config.exs",
deps_path: "../../deps",
lockfile: "../../mix.lock",
```

这些选项意味着所有依赖项都将检查到`kv_umbrella/deps`，它们将共享相同的构建、配置和锁定文件。我们还没有讨论过配置，但从这里我们可以直观地知道，所有配置和依赖项都是在一个保护伞中的所有项目中共享的，而不是每个应用程序

第二个变化是在`mix.exs`内的`applicaiton`函数中：

```elixir
def application do
    [
        extra_applications: [:logger],
        mod: {KVServer.Application,{}}
    ]
end
```

由于我们传递了`--sup`标签，Mix自动添加了`mod：{KVServer.Application，[]}`，指定`KVServer.Application`是我们的应用程序回调模块。`KVServer.Application`将启动我们的应用程序监督树。

让我们打开`lib/kv_server/application.ex`：

```elixir
defmodule KVServer.Application do
  # See https://hexdocs.pm/elixir/Application.html
  # for more information on OTP Applications
  @moduledoc false

  use Application

  @impl true
  def start(_type, _args) do
    # List all child processes to be supervised
    children = [
      # Starts a worker by calling: KVServer.Worker.start_link(arg)
      # {KVServer.Worker, arg},
    ]

    # See https://hexdocs.pm/elixir/Supervisor.html
    # for other strategies and supported options
    opts = [strategy: :one_for_one, name: KVServer.Supervisor]
    Supervisor.start_link(children, opts)
  end
end
```

请注意，它定义了应用程序回调函数`start/2`，而不是定义一个名为`KVServer`的监督器。使用`Supervisor`模块的主管，而是方便地定义了主管内联！您可以通过阅读主管模块文档来阅读有关此类主管的更多信息。

我们已经可以尝试我们的第一个子项目。我们可以在`apps/kv_server`目录中运行测试，但这不会很有趣。相反，转到伞式项目的根目录并运行`mix test`。

由于我们希望`kv_server`最终使用我们在kv中定义的功能，我们需要将kv添加作为我们的应用程序的依赖项。

## 伞式项目的依赖

伞式项目中应用程序之间的依赖关系仍然必须明确定义，mix很容易的实现。打开`apps/kv_server/mix.exs`，并将`deps/0`函数更改为以下内容：

```elixir
defp deps do
    [{:kv, in_umbrella: true}]
end
```

上行使`:kv`在`:kv_server`中作为依赖项可用，并在服务器启动前自动启动`:kv`应用程序。

最后，将我们迄今为止构建的kv应用程序复制到我们新伞式项目中的应用程序目录中。最终的目录结构应该与我们之前提到的结构相匹配

```markdown
+ kv_umbrella
  + apps
    + kv
    + kv_server
```

我们现在需要修改`apps/kv/mix.exs`，以包含我们在`apps/kv_server/mix.exs`中看到的总括条目。打开`apps/kv/mix.exs`并添加到`project/0`功能：

```elixir
build_path: "../../_build",
config_path: "../../config/config.exs",
deps_path: "../../deps",
lockfile: "../../mix.lock",
```

现在，您可以通过`mix test`从伞根运行两个项目的测试。

## Don't drink the kool aid

保护伞项目是帮助您组织和管理多个应用程序的便利。虽然它在应用程序之间提供了一定程度的分离，但这些应用程序并没有完全分离，因为它们共享相同的配置和相同的依赖关系。将多个应用程序保存在同一存储库中的模式被称为“单存储库”。Umbrella项目通过提供一次编译、测试和运行多个应用程序的便利来最大化这种模式。

如果您发现自己希望在每个应用程序中为相同的依赖项使用不同的配置或使用不同的依赖项版本，那么您的代码库很可能已经超出了保护伞所能提供的范围。

好消息是，拆开伞非常简单，因为您只需要将应用程序移出保护伞项目的应用程序/目录，并更新项目的`mix.exs`文件，不再设置`build_path`、`config_path`、`deps_path`和`lockfile`配置。您可以通过多种方式依赖伞外的私人项目：

1. 将其移动到同一存储库中的单独文件夹，并使用路径依赖项（no-repo pattern）指向它
2. 将存储库移动到单独的Git存储库并依赖它
3. 将该项目发布给私人Hex.pm组织

## summing up

在本章中，我们学习了更多关于Mix依赖项和保护伞项目的信息。虽然我们可能在没有服务器的情况下运行kv，但我们的`kv_server`直接依赖于`kv`。通过将它们分解成单独的应用程序，我们可以更好地控制它们的开发和测试方式。

在使用伞应用程序时，它们之间有一个明确的界限很重要。我们即将推出的`kv_server`只能访问`kv`中定义的公共API.将您的总括应用程序视为任何其他依赖项，甚至`Elixir`本身：您只能访问公开和记录的内容。在您的依赖项中访问私有功能是一种糟糕的做法，当新版本发布时，最终会导致您的代码崩溃。

伞式应用程序也可以作为最终从代码库中提取应用程序的垫脚石。例如，想象一下一个必须向用户发送“推送通知”的Web应用程序。整个“推送通知系统”可以作为保护伞中的单独应用程序进行开发，并具有自己的监督树和API。如果您遇到另一个项目需要推送通知系统的情况，系统可以移动到私有存储库或hex package。

最后，请记住，伞式项目中的应用程序都共享相同的配置和依赖项。如果您的伞中的两个应用程序需要以截然不同的方式配置相同的依赖项，甚至使用不同的版本，您可能已经摆脱了伞带来的好处。请记住，你可以打破伞，但仍然利用“mono-repos”背后的好处。

随着我们的伞式项目启动和运行，是时候开始编写我们的服务器了。