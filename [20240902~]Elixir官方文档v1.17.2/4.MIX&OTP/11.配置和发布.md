# [配置和发布](https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/pages/mix-and-otp/config-and-releases.md#L1)


在这个最后的指南中，我们将使我们的分布式键值存储的路由表可配置，最后将软件打包用于生产。

## 程序环境

到目前为止，我们已将路由表硬编码到 `KV.Router` 模块中。然而，我们希望使该表动态化。这不仅可以让我们配置开发/测试/生产环境，还可以让不同的节点以不同的路由表条目运行。OTP 有一个功能正好可以做到这一点：应用程序环境。每个应用程序都有一个环境，用于通过键存储应用程序特定的配置。例如，我们可以将路由表存储在 `:kv `应用程序环境中，赋予它一个默认值，并允许其他应用程序根据需要更改该表。

请打开` apps/kv/mix.exs `文件，并将 `application/0` 函数更改为返回以下内容：

```elixir
def application do
  [
    extra_applications: [:logger],
    env: [routing_table: []],
    mod: {KV, []}
  ]
end
```

我们在应用程序中添加了一个新的 `:env` 键。它返回应用程序的默认环境，其中包含一个键为 `:routing_table`、值为空列表的条目。应用程序环境配备一个空表是合理的，因为特定的路由表取决于测试/部署结构。

为了在我们的代码中使用应用程序环境，我们需要将 `KV.Router.table/0` 替换为下面的定义：

```elixir
@doc """
The routing table.
"""
def table do
  Application.fetch_env!(:kv, :routing_table)
end
```

我们使用 `⁠Application.fetch_env!/2` 来读取 `⁠:kv` 应用程序环境中的 `⁠:routing_table` 条目。你可以在` ⁠Application` 模块中找到更多信息和其他用于操作应用程序环境的函数。

由于我们的路由表现在是空的，我们的分布式测试应该会失败。请重新启动应用程序并重新运行测试以观察失败。

```shell
iex --sname bar -S mix
elixir --sname foo -S mix test --only distributed
```

我们需要一种方法来配置应用程序环境。这时我们会使用配置文件。

## 配置文件

配置文件为我们提供了一种方法来配置任何应用程序的环境。Elixir 提供了两个配置入口点：

- ⁠config/config.exs：该文件在构建时读取，在我们编译应用程序和加载依赖项之前。这意味着我们无法访问应用程序或依赖项中的代码。然而，这使我们能够控制它们的编译方式。

- ⁠config/runtime.exs：该文件在我们的应用程序和依赖项编译之后读取，因此可以配置我们的应用程序在运行时的工作方式。如果你想读取系统环境变量（通过 ⁠System.get_env/1）或任何外部配置，这里是合适的地方。

例如，我们可以将 `IEx` 的默认提示符配置为其他值。让我们创建一个 `⁠config/runtime.exs` 文件，内容如下：

```elixir
import Config
config :iex, default_prompt: ">>>"
```

这意味着我们也可以直接在 `config/runtime.exs` 文件中配置我们的 `:routing_table`。然而，我们应该使用哪个配置值呢？

目前我们有两个标记为` @tag :distributed` 的测试。`KVServerTest` 中的“服务器交互”测试和 `KV.RouterTest` 中的“跨节点路由请求”测试。由于这两个测试都需要一个路由表，而当前路由表为空，所以它们都失败了。为了简化起见，我们将定义一个总是指向当前节点的路由表。这是我们将在开发和大多数测试中使用的表。在 c`onfig/runtime.exs` 中，添加这一行：

```elixir
config :kv, :routing_table, [{?a..?z, node()}]
```

然而，对于 `KV.RouterTest` 中的测试，我们实际上需要路由表中的两个节点。为此，我们将编写一个在该文件中所有测试之前运行的`setup`块。该设置块会更改应用程序环境，并在完成后将其恢复，具体如下：

```elixir
defmodule KV.RouterTest do
  use ExUnit.Case

  setup_all do
    current = Application.get_env(:kv, :routing_table)

    Application.put_env(:kv, :routing_table, [
      {?a..?m, :"foo@computer-name"},
      {?n..?z, :"bar@computer-name"}
    ])

    on_exit fn -> Application.put_env(:kv, :routing_table, current) end
  end

  @tag :distributed
  test "route requests across nodes" do
```

请注意，我们从 `use ExUnit.Case` 中移除了 `async: true`。由于应用程序环境是一个全局存储，因此修改它的测试不能并发运行。所有更改完成后，所有测试都应该通过，包括分布式测试。

## 发布

现在我们的应用程序可以分布式运行，您可能在想我们如何将应用程序打包以在生产环境中运行。毕竟，到目前为止，我们的所有代码都依赖于当前系统中安装的 `Erlang` 和 `Elixir` 版本。为了实现这个目标，`Elixir` 提供了发行版（releases）。

发行版是一个自包含的目录，包含了您的应用程序代码、所有依赖项以及完整的 `Erlang` 虚拟机（VM）和运行时。一旦发行版组装完成，就可以将其打包并部署到目标，只要目标运行在与组装发行版的机器相同的操作系统（OS）发行版和版本上。

在常规项目中，我们只需运行` mix release` 即可组装发行版。然而，我们有一个伞形项目，在这种情况下，`Elixir` 需要我们提供一些额外的输入。让我们看看需要什么：

```shell
MIX_ENV=prod mix release
** (Mix) Umbrella projects require releases to be explicitly defined with a non-empty applications key that chooses which umbrella children should be part of the releases:

releases: [
  foo: [
    applications: [child_app_foo: :permanent]
  ],
  bar: [
    applications: [child_app_bar: :permanent]
  ]
]

Alternatively you can perform the release from the children applications

```

这就是因为一个 umbrella 项目在部署软件时给我们提供了很多选择。我们可以：
- 将 umbrella 中的所有应用程序部署到一个同时作为 TCP 服务器和键值存储的节点上。
- 将 :kv_server 应用程序仅作为 TCP 服务器部署，只要路由表仅指向其他节点。
- 当我们希望某个节点仅作为存储（没有 TCP 访问权限）时，仅部署 :kv 应用程序。

作为起点，让我们定义一个包含 `:kv_server` 和 `:kv` 应用程序的发行版。我们还将为其添加一个版本。在 umbrella 根目录中打开 `mix.exs` 文件，并在` def project` 中添加以下内容：

```elixir
releases: [
  foo: [
    version: "0.0.1",
    applications: [kv_server: :permanent, kv: :permanent]
  ]
]
```

这定义了一个名为 `foo` 的发布版本，其中包含 `kv_server` 和 `kv `应用程序。它们的模式被设置为 :permanent，这意味着如果这些应用程序崩溃，整个节点也会终止。这是合理的，因为这些应用程序对我们的系统至关重要。

在我们组装发布版本之前，让我们也为生产环境定义路由表。考虑到我们预计将有两个节点，我们需要将 `config/runtime.exs` 更新为如下所示：

```elixir
import Config

config :kv, :routing_table, [{?a..?z, node()}]

if config_env() == :prod do
  config :kv, :routing_table, [
    {?a..?m, :"foo@computer-name"},
    {?n..?z, :"bar@computer-name"}
  ]
end
```

我们已经对表格和节点名称进行了硬编码，这对于我们的示例来说已经足够，但在实际的生产环境中，您可能会将其移到外部配置系统中。我们还将其包装在 `config_env() == :prod` 检查中，因此这个配置不适用于其他环境。配置就位后，让我们再尝试一次组装发布版本：

```shell
MIX_ENV=prod mix release foo
* assembling foo-0.0.1 on MIX_ENV=prod
* skipping runtime configuration (config/runtime.exs not found)

Release created at _build/prod/rel/foo!

    # To start your system
    _build/prod/rel/foo/bin/foo start

Once the release is running:

    # To connect to it remotely
    _build/prod/rel/foo/bin/foo remote

    # To stop it gracefully (you may also send SIGINT/SIGTERM)
    _build/prod/rel/foo/bin/foo stop

To list all commands:

    _build/prod/rel/foo/bin/foo
```

优秀！一个发布版本已经在 `_build/prod/rel/foo` 中组装完成。在这个发布版本中，将有一个 `bin/foo` 文件作为系统的入口点。它支持多种命令，例如：

- `bin/foo start`，`bin/foo start_iex`，`bin/foo restart` 和` bin/foo stop` — 用于一般管理发布版本

- `bin/foo rpc COMMAND `和 `bin/foo remote` — 用于在运行的系统上运行命令或连接到运行的系统

- `bin/foo eval COMMAND `— 启动一个新的系统，执行单个命令，然后关闭

- `bin/foo daemon` 和 `bin/foo daemon_iex` — 在类Unix系统上将系统作为守护进程启动

- `bin/foo install` — 在Windows机器上将系统安装为服务

如果你运行 `bin/foo start`，它将使用一个短名称 (`--sname`)，该名称等于发布名称，在本例中为 `foo`。下一步是启动一个名为 `bar` 的系统，这样我们就可以像在上一章那样将 `foo` 和 `bar` 连接在一起。但在做到这一点之前，让我们先谈谈发布版本的好处。

## Why releases?

发布让开发者将他们的所有代码和运行时预编译并打包成一个单一的单元。发布的好处包括：

- 代码预加载。虚拟机有两种加载代码的机制：交互式和嵌入式。默认情况下，它在交互式模式下运行，当模块第一次被使用时动态加载。第一次当您的应用调用 Enum.map/2 时，虚拟机会找到 Enum 模块并将其加载。这有一个缺点。当您在生产环境中启动一个新服务器时，它可能需要加载许多其他模块，导致第一次请求的响应时间异常增加。发布在嵌入式模式下运行，预先加载所有可用模块，确保系统在启动后可以准备好处理请求。

- 配置和定制。发布让开发者对系统配置和启动系统时使用的虚拟机标志有更精细的控制。

- 自包含。发布不需要在生产产物中包含源代码。所有代码都是预编译和打包的。发布甚至不需要在您的服务器上安装 Erlang 或 Elixir，因为它们默认包含了 Erlang 虚拟机及其运行时。此外，Erlang 和 Elixir 的标准库经过精简，仅包含您实际使用的部分。

- 多个发布。您可以根据每个应用的不同配置或甚至完全不同的应用组合不同的发布版本。

我们已经撰写了关于发布的详细文档，请查阅官方文档以获取更多信息。现在，我们将继续探讨上述概述的一些特性。

## 组合多个发布

到目前为止，我们已经组装了一个名为 `foo` 的发布版本，但我们的路由表中同时包含了 `foo` 和` bar` 的信息。让我们启动 `foo`：

```elixir
_build/prod/rel/foo/bin/foo start
16:58:58.508 [info]  Accepting connections on port 4040
```

让我们连接到它，并在另一个终端发出请求：

```shell
telnet 127.0.0.1 4040
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
CREATE bitsandpieces
OK
PUT bitsandpieces sword 1
OK
GET bitsandpieces sword
1
OK
GET shopping foo
Connection closed by foreign host.
```

我们的应用在我们操作名为“bitsandpieces”的桶时已经可以正常工作。但由于“shopping”桶会存储在bar上，因此请求失败，因为bar不可用。如果你返回到运行foo的终端，你将看到：

```elixir
17:16:19.555 [error] Task #PID<0.622.0> started from #PID<0.620.0> terminating
** (stop) exited in: GenServer.call({KV.RouterTasks, :"bar@computer-name"}, {:start_task, [{:"foo@josemac-2", #PID<0.622.0>, #PID<0.622.0>}, [#PID<0.622.0>, #PID<0.620.0>, #PID<0.618.0>], :monitor, {KV.Router, :route, ["shopping", KV.Registry, :lookup, [KV.Registry, "shopping"]]}], :temporary, nil}, :infinity)
    ** (EXIT) no connection to bar@computer-name
    (elixir) lib/gen_server.ex:1010: GenServer.call/3
    (elixir) lib/task/supervisor.ex:454: Task.Supervisor.async/6
    (kv) lib/kv/router.ex:21: KV.Router.route/4
    (kv_server) lib/kv_server/command.ex:74: KVServer.Command.lookup/2
    (kv_server) lib/kv_server.ex:29: KVServer.serve/1
    (elixir) lib/task/supervised.ex:90: Task.Supervised.invoke_mfa/2
    (stdlib) proc_lib.erl:249: :proc_lib.init_p_do_apply/3
Function: #Function<0.128611034/0 in KVServer.loop_acceptor/1>
    Args: []
```

让我们现在为 `:bar` 定义一个发布。第一步可以在` mix.exs` 中定义一个与 `foo` 完全相同的发布。此外，我们将两个发布的 cookie 选项设置为` weknoweachother`，以便允许它们相互连接。有关此主题的更多信息，请参阅分布式 Erlang 文档。

```elixir
releases: [
  foo: [
    version: "0.0.1",
    applications: [kv_server: :permanent, kv: :permanent],
    cookie: "weknoweachother"
  ],
  bar: [
    version: "0.0.1",
    applications: [kv_server: :permanent, kv: :permanent],
    cookie: "weknoweachother"
  ]
]
```

现在我们来组合两个版本：

```shell
MIX_ENV=prod mix release foo
MIX_ENV=prod mix release bar
```

如果 `foo` 仍在运行，请停止它，然后重新启动以加载 `cookie`：

```shell
_build/prod/rel/foo/bin/foo start
```

在另一个终端中启动`bar`：

```shell
_build/prod/rel/bar/bin/bar start
```

你应该看到下面的错误发生5次，然后应用程序才会最终关闭：

```shell
    17:21:57.567 [error] Task #PID<0.620.0> started from KVServer.Supervisor terminating
    ** (MatchError) no match of right hand side value: {:error, :eaddrinuse}
        (kv_server) lib/kv_server.ex:12: KVServer.accept/1
        (elixir) lib/task/supervised.ex:90: Task.Supervised.invoke_mfa/2
        (stdlib) proc_lib.erl:249: :proc_lib.init_p_do_apply/3
    Function: #Function<0.98032413/0 in KVServer.Application.start/2>
        Args: []
```

那是因为发布的 `foo` 已经在监听 `4040` 端口，而 `bar` 也试图监听同样的端口！一个选择是将 `:port` 配置移动到应用环境，就像我们为路由表所做的那样，并为每个节点设置不同的端口。

但我们尝试一些其他的东西。我们只让条形释放包含 `:kv` 应用，这样它就可以作为存储使用，但没有前端。将 `:bar` 的信息更改为：

```elixir
releases: [
  foo: [
    version: "0.0.1",
    applications: [kv_server: :permanent, kv: :permanent],
    cookie: "weknoweachother"
  ],
  bar: [
    version: "0.0.1",
    applications: [kv: :permanent],
    cookie: "weknoweachother"
  ]
]
```

现在我们再一次组装`bar`：

```shell
MIX_ENV=prod mix release bar
```

最后成功启动它：

```shell
_build/prod/rel/bar/bin/bar start
```

如果你再次连接到本地主机并进行另一个请求，一切应该都能正常工作，只要路由表中包含正确的节点名称。太棒了!

通过发布，我们能够创建项目的不同部分，并准备它们在生产环境中运行，所有内容都打包到一个目录中。

## 配置发布

发布版还提供内置的钩子，以配置生产系统几乎所有的需求：

- `config/config.exs` — 提供构建时的应用配置，该配置在我们的应用程序编译之前执行。此文件通常根据环境导入配置文件，例如 `config/dev.exs` 和 `config/prod.exs`。

- `config/runtime.exs` — 提供运行时的应用配置。它在每次启动释放版时执行，并且可以通过配置提供者进一步扩展。

- `rel/env.sh.eex` 和 `rel/env.bat.eex` — 模板文件，会在每个释放版中复制，并在每个命令执行时运行，用于设置环境变量，包括特定于虚拟机的变量以及一般环境的变量。

- `rel/vm.args.eex` — 一个模板文件，会在每个释放版中复制，提供 `Erlang` 虚拟机的静态配置和其他运行时标志。

正如我们所看到的，c`onfig/config.exs` 和 `config/runtime.exs` 在释放版和常规 `Mix` 命令期间加载。另一方面，`rel/env.sh.eex` 和 `rel/vm.args.eex` 则特定于释放版。让我们来看看。

## 操作系统环境配置

每个发布版都包含一个环境文件，在类`Unix`系统上名为 `env.sh`，在 `Windows` 机器上名为 `env.bat`，该文件在 `Elixir` 系统启动之前执行。在这个文件中，您可以执行任何操作系统级的代码，例如调用其他应用程序、设置环境变量等。其中一些环境变量甚至可以配置发布版本身的运行方式。

例如，发布版本是使用短名称（`--sname`）运行的。然而，如果您想在生产环境中实际运行一个分布式键值存储，您将需要多个节点，并使用`--name`选项启动释放版本。我们可以通过在`env.sh`和`env.bat`文件中设置`RELEASE_DISTRIBUTION`环境变量来实现。`Mix`已经为这些文件提供了一个模板，我们可以自定义，因此让我们请求`Mix`将它们复制到我们的应用程序中：

```shell
mix release.init
* creating rel/vm.args.eex
* creating rel/remote.vm.args.eex
* creating rel/env.sh.eex
* creating rel/env.bat.eex
```

如果你打开 `rel/env.sh.eex`，你会看到：

```shell
#!/bin/sh

# # Sets and enables heart (recommended only in daemon mode)
# case $RELEASE_COMMAND in
#   daemon*)
#     HEART_COMMAND="$RELEASE_ROOT/bin/$RELEASE_NAME $RELEASE_COMMAND"
#     export HEART_COMMAND
#     export ELIXIR_ERL_OPTIONS="-heart"
#     ;;
#   *)
#     ;;
# esac

# # Set the release to load code on demand (interactive) instead of preloading (embedded).
# export RELEASE_MODE=interactive

# # Set the release to work across nodes.
# # RELEASE_DISTRIBUTION must be "sname" (local), "name" (distributed) or "none".
# export RELEASE_DISTRIBUTION=name
# export RELEASE_NODE=<%= @release.name %>

```

在这个示例中，跨节点工作的步骤已经被注释掉。你可以通过去掉最后两行前面的#来启用全面分布。如果你在 `Windows` 上，你需要打开 `rel/env.bat.eex`，在那里你会找到这个：

```powershell
@echo off
rem Set the release to load code on demand (interactive) instead of preloading (embedded).
rem set RELEASE_MODE=interactive

rem Set the release to work across nodes.
rem RELEASE_DISTRIBUTION must be "sname" (local), "name" (distributed) or "none".
rem set RELEASE_DISTRIBUTION=name
rem set RELEASE_NODE=<%= @release.name %>
```

请再次取消最后两行的注释，去掉开头的 `rem`，以启用完整的分发。就这样！

## VM 参数

`rel/vm.args.eex` 允许您指定控制` Erlang VM` 及其运行时操作的低级标志。您可以像在命令行中指定参数一样指定条目，并且也支持代码注释。以下是默认生成的文件：

```text
## Customize flags given to the VM: https://www.erlang.org/doc/man/erl.html
## -mode/-name/-sname/-setcookie are configured via env vars, do not set them here

## Increase number of concurrent ports/sockets
##+Q 65536

## Tweak GC to run more often
##-env ERL_FULLSWEEP_AFTER 10
```

你可以在`Erlang`文档中查看完整的虚拟机参数和标志列表。

## 总结

在整个指南中，我们构建了一个非常简单的分布式键值存储，以便探索许多构造，例如通用服务器、监督者、任务、代理、应用程序等等。不仅如此，我们还为整个应用程序编写了测试，熟悉了 `ExUnit`，并学习了如何使用 `Mix` 构建工具来完成各种任务。

如果你在寻找一个分布式键值存储用于生产环境，你一定要考虑`Riak`，它运行在Erlang虚拟机上。在`Riak`中，桶是被复制的，以避免数据丢失，并且它使用一致性哈希而不是路由器将桶映射到节点。一致性哈希算法有助于减少在你的实时系统中添加新的存储节点时需要迁移的数据量。

当然，Elixir不仅可以用于分布式键值存储。嵌入式系统、数据处理和摄取、Web 应用程序、音频/视频流系统以及其他众多领域都是 Elixir 擅长的地方。我们希望这本指南能让你为探索这些领域或未来想要应用 Elixir 的任何领域做好准备。